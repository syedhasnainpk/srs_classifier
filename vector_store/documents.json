[{"id": 0, "text": "Hypothesis Modern machine learning algorithms can be optimized to deliver effective and accurate face recognition on low-end devices, such as those commonly used on construction sites, thereby enhancing security and compliance in the construction industry. Problem Description Construction companies need to verify worker identity for safety and compliance using face recognition.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 0, "total_chunks": 10}}, {"id": 1, "text": "Problem Description Construction companies need to verify worker identity for safety and compliance using face recognition. Unlike high-end environments like airports, construction managers often only have access to standard laptops. Thus, there's a pressing need to evaluate which ML algorithms offer the best performance on resource-constrained hardware.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 1, "total_chunks": 10}}, {"id": 2, "text": "Thus, there's a pressing need to evaluate which ML algorithms offer the best performance on resource-constrained hardware. Aims To evaluate and compare the performance of two face recognition algorithms in real-time scenarios on low-end hardware and determine the most suitable one for deployment in the construction industry.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 2, "total_chunks": 10}}, {"id": 3, "text": "Aims To evaluate and compare the performance of two face recognition algorithms in real-time scenarios on low-end hardware and determine the most suitable one for deployment in the construction industry. Objectives Select two widely-used ML algorithms for face recognition (e.g., Haar Cascades vs. MobileNet with TensorFlow Lite). Implement both on a low-spec laptop system.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 3, "total_chunks": 10}}, {"id": 4, "text": "Implement both on a low-spec laptop system. Build a small dataset or use an existing public dataset relevant to real-world outdoor environments. Measure accuracy, latency, and CPU/memory consumption. Compare findings with a model project or benchmark dataset. Draw conclusions and make deployment recommendations.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 4, "total_chunks": 10}}, {"id": 5, "text": "Draw conclusions and make deployment recommendations. Methodology Literature Review: Research related work on lightweight face recognition systems. Implementation: Use Python, OpenCV, and TensorFlow Lite. Evaluation: Run both models on the same dataset and hardware, log performance metrics, and produce visual and tabular comparisons.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 5, "total_chunks": 10}}, {"id": 6, "text": "Evaluation: Run both models on the same dataset and hardware, log performance metrics, and produce visual and tabular comparisons. Benchmarking: Compare against known performance stats from model projects or academic benchmarks. Project Plan Weeks 1\u20132: Finalize research question, gather sources. Weeks 3\u20135: Complete literature review and select algorithms.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 6, "total_chunks": 10}}, {"id": 7, "text": "Weeks 3\u20135: Complete literature review and select algorithms. Weeks 6\u20139: Implement face recognition systems. Weeks 10\u201312: Conduct tests and collect performance data. Weeks 13\u201314: Analyze results and begin writing IPR. Weeks 15\u201320: Finalize project, write report, prepare demonstration.", "metadata": {"filename": "MSc Project.docx", "chunk_index": 7, "total_chunks": 10}}, {"id": 8, "text": "Weeks 15\u201320: Finalize project, write report, prepare demonstration. Deliverables Comparative performance report Prototype software implementation Dataset usage description Final report (approx. 10,000 words) Live demonstration", "metadata": {"filename": "MSc Project.docx", "chunk_index": 8, "total_chunks": 10}}, {"id": 9, "text": "10,000 words) Live demonstration", "metadata": {"filename": "MSc Project.docx", "chunk_index": 9, "total_chunks": 10}}, {"id": 10, "text": "MSc Project Handbook School of Physics, Engineering and Computer Science Authored by Dr Olga Angelopoulou Version 9. 2 Revision E.Jukes August 2021 MSc Project Handbook 1 This page is intentionally left blank MSc Project Handbook 2 Table of Contents 1. Introduction 4 1.1 Useful information on the module 4 1.1.1 Recommended reading 4 1.1.2 Canvas 5 1.2 Supervision 5 2.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 0, "total_chunks": 224}}, {"id": 11, "text": "Introduction 4 1.1 Useful information on the module 4 1.1.1 Recommended reading 4 1.1.2 Canvas 5 1.2 Supervision 5 2. The Process 6 2.1 Getting started on your project and how it is assessed 6 2.1.1 Investigative project 6 2.1.2 Development project 8 2.2 Ethics approval 8 2.3 Project ma nagement 9 2.3.1 Further guidance 9 2.3.2 Project Journey 10 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 1, "total_chunks": 224}}, {"id": 12, "text": "The Process 6 2.1 Getting started on your project and how it is assessed 6 2.1.1 Investigative project 6 2.1.2 Development project 8 2.2 Ethics approval 8 2.3 Project ma nagement 9 2.3.1 Further guidance 9 2.3.2 Project Journey 10 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 2, "total_chunks": 224}}, {"id": 13, "text": "Meeting objective 30 2. Preparation (reading material, completed work etc.) 30 3. Action Items for next meeting 31 5. Planned next meeting 31 MSc Project Handbook 4 1.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 3, "total_chunks": 224}}, {"id": 14, "text": "Planned next meeting 31 MSc Project Handbook 4 1. Introduction The purpose of the handbook is to accompany you during the preparation of your project for the completion of your Master\u2019s programme in the School of Physics, Engineerin g and Computer Science at the University of Hertfordshire .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 4, "total_chunks": 224}}, {"id": 15, "text": "Introduction The purpose of the handbook is to accompany you during the preparation of your project for the completion of your Master\u2019s programme in the School of Physics, Engineerin g and Computer Science at the University of Hertfordshire . The successful completion of your MSc Project, your final project report and demonstration is worth 60 credits.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 5, "total_chunks": 224}}, {"id": 16, "text": "The successful completion of your MSc Project, your final project report and demonstration is worth 60 credits. It is necessary for the award of a Master\u2019s level qualification to demonstrate your ability to bring together a variety of skills, experience and knowledge derived from different sources.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 6, "total_chunks": 224}}, {"id": 17, "text": "It is necessary for the award of a Master\u2019s level qualification to demonstrate your ability to bring together a variety of skills, experience and knowledge derived from different sources.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 7, "total_chunks": 224}}, {"id": 18, "text": "The main purpose of the Master's project is to allow students to extend the principles and concepts they have learnt during study of advanced modules, a nd apply that knowledge in the context of a substantial piece of independent work. You are expected to work on a practical investigative or development project. You should be trying to answer some research question s.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 8, "total_chunks": 224}}, {"id": 19, "text": "You should be trying to answer some research question s. There needs to be an appropriate balance between research and development and you should demonstrate that you have acquired the sk ills to apply the knowledge gained from your research to your practical work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 9, "total_chunks": 224}}, {"id": 20, "text": "There needs to be an appropriate balance between research and development and you should demonstrate that you have acquired the sk ills to apply the knowledge gained from your research to your practical work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 10, "total_chunks": 224}}, {"id": 21, "text": "The project is a showpiece opportunity for yo u to demonstrate what you know about current research and practices in your field of study and demonstrate your skills in selecting and using appropriate techniques and tools employed in these areas to conduct a practical investigation into a particular pr oblem.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 11, "total_chunks": 224}}, {"id": 22, "text": "It is a self -directed piece of work, conducted with minimum supervision , that demonstrates your ability to plan and manage a substantial piece of work, and direct your own efforts. You are expected to be thorough in your work, and in particular, identify and tackle any difficult or challenging aspects of the problem you are trying to solve.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 12, "total_chunks": 224}}, {"id": 23, "text": "You are expected to be thorough in your work, and in particular, identify and tackle any difficult or challenging aspects of the problem you are trying to solve. It is not just the quantity, or even the quality of work , that is considered when grading the project, but the level of difficulty and the scope of the problem b eing addressed . The aims of the MSc Project are to enable you to 1.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 13, "total_chunks": 224}}, {"id": 24, "text": "The aims of the MSc Project are to enable you to 1. Select and use appropriate tools and techniques in order to conduct a practical investigation or solve a problem, and critically evaluate your own work. 2. Demonstrate that you can work independently with minimum supervision, plan your work effectively, and present the outcome of the work in written and oral form. 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 14, "total_chunks": 224}}, {"id": 25, "text": "3. Draw on what you already know about the subject area in order to identify further areas of study, and extend your knowledge by making critical use of the technical and scientific literature and oth er materials, and conceive original ideas of your own.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 15, "total_chunks": 224}}, {"id": 26, "text": "Draw on what you already know about the subject area in order to identify further areas of study, and extend your knowledge by making critical use of the technical and scientific literature and oth er materials, and conceive original ideas of your own.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 16, "total_chunks": 224}}, {"id": 27, "text": "1.1 Useful information on the module 1.1.1 Recommended reading \u2022 \u201cProjects in Computing and Information Systems: A Student\u2019s Guide\u201d, any edition, Christian W Dawson, Addison Wesley. \u2022 \u201cThesis Projects: A Guide for Students in Computer Science and Information Systems\u201d, any edition, Mikael Berndtsson, J\u00f6rgen Hansson, Bj\u00f6rn Olsson and Bj\u00f6rn Lundell, Springer.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 17, "total_chunks": 224}}, {"id": 28, "text": "\u2022 \u201cThesis Projects: A Guide for Students in Computer Science and Information Systems\u201d, any edition, Mikael Berndtsson, J\u00f6rgen Hansson, Bj\u00f6rn Olsson and Bj\u00f6rn Lundell, Springer. MSc Project Handbook 5 1.1.2 Canvas Where possible, distributed materials for this module will be put onto Canvas in the module area for 7COM1039 Advanced Computer Science Masters Project .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 18, "total_chunks": 224}}, {"id": 29, "text": "MSc Project Handbook 5 1.1.2 Canvas Where possible, distributed materials for this module will be put onto Canvas in the module area for 7COM1039 Advanced Computer Science Masters Project . All the other masters\u2019 project modules are slaved to this site, so those students registered on other project modules will be redirected automatically.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 19, "total_chunks": 224}}, {"id": 30, "text": "All the other masters\u2019 project modules are slaved to this site, so those students registered on other project modules will be redirected automatically. 1.2 Supervision You must ad vise the module leader if you have already agreed supervision with a s taff member , otherwise the module team will assign a supervisor to you.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 20, "total_chunks": 224}}, {"id": 31, "text": "1.2 Supervision You must ad vise the module leader if you have already agreed supervision with a s taff member , otherwise the module team will assign a supervisor to you.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 21, "total_chunks": 224}}, {"id": 32, "text": "You cannot necessarily expect that your project supervisor will be an expert in your chosen field, if s/he is then you can consider it a bonus, but they will advise and support you on the project ; to help you to manage it, and as an academic advisor. However, they will not tell you what to do, nor will they take responsibility for your mistakes .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 22, "total_chunks": 224}}, {"id": 33, "text": "However, they will not tell you what to do, nor will they take responsibility for your mistakes . The supervisor\u2019s role is not to contribute to any part of the project for you. The individual project supervisor is a v aluable resource and you should use them wisely since the resource is limited.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 23, "total_chunks": 224}}, {"id": 34, "text": "The individual project supervisor is a v aluable resource and you should use them wisely since the resource is limited. Therefore, you should make sure you meet with them regularly at a time that is mutually convenient for both of you. For these meetings to be beneficial, you will need to do some work every week, or else you won\u2019t have anything to discuss with your supervisor.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 24, "total_chunks": 224}}, {"id": 35, "text": "For these meetings to be beneficial, you will need to do some work every week, or else you won\u2019t have anything to discuss with your supervisor. A typical meeting with your supervisor should approximately last 15 minutes each week for one-semester (full -time) projects and every fortnight for double -semester (part -time) projects. However, there are variances that depend on your needs.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 25, "total_chunks": 224}}, {"id": 36, "text": "However, there are variances that depend on your needs. Your supervisor may take some annual leave during the course of your project. Supervision meetings could be scheduled with you individually , or as a group. It is a general observation that students who do not meet with their supervisors regularly do not achieve good results in their project s. MSc Project Handbook 6 2.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 26, "total_chunks": 224}}, {"id": 37, "text": "MSc Project Handbook 6 2. The Process 2.1 Getting started on your project and how it is assessed The project is a n individual , rigorous, critical and complex piece of work . It is not an assignment set by a tutor, where you mainly provide information that is coming from someone else\u2019s research with your personal critical thinking . It is n ot just a piece of software development .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 27, "total_chunks": 224}}, {"id": 38, "text": "It is n ot just a piece of software development . You are expected to study what other people have done, and more importantly generate information yourself and develop expertise in your area of study.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 28, "total_chunks": 224}}, {"id": 39, "text": "You are expected to study what other people have done, and more importantly generate information yourself and develop expertise in your area of study.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 29, "total_chunks": 224}}, {"id": 40, "text": "Depending on your study mode, t he MSc Project is c arried out over an extended period and you should dedicate approximately 600 hour s over one or two semesters -- the equivalent of 43 hours a week for one-semester (full -time) projects ; for double -semester (part -time) projects , the equivalent of 2 1.5 hours per week on your project work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 30, "total_chunks": 224}}, {"id": 41, "text": "It is very important to plan ahead your work and not leave it to the last few weeks . Your participation is imperative. You should never forget to be working full -time on your project. Please avoid taking leave in general. If you must be absent, then plan with your supervisor in advance and adjust your schedule . Always k eep in touch and keep up!", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 31, "total_chunks": 224}}, {"id": 42, "text": "Always k eep in touch and keep up! There are eight different project modules, but only TWO really different kinds of project ; investigative or development . You must do the type of project specified b y the award you seek . Learning outcomes for ALL students 1.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 32, "total_chunks": 224}}, {"id": 43, "text": "Learning outcomes for ALL students 1. be able to plan and manage a substantial body of work, identify any risks inherent in their chosen approach, and work independently with minimum supervision; 2. be able to both critically evaluate and discuss the outcome of their project w ork in written and oral form 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 33, "total_chunks": 224}}, {"id": 44, "text": "be able to both critically evaluate and discuss the outcome of their project w ork in written and oral form 3. be able to articulate the broader contexts of their work in relation to legal, social, ethical, and professional issues, and assess the economic impact of their project. 2.1.1 Investigative project This type of project requires you to work on an investigative and practical project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 34, "total_chunks": 224}}, {"id": 45, "text": "2.1.1 Investigative project This type of project requires you to work on an investigative and practical project. It applies to those of you who study Software Engineering, AI with Robotics, Networking , Cyber Security , Data Science with Analytics or Advanced C omputer Science .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 35, "total_chunks": 224}}, {"id": 46, "text": "It applies to those of you who study Software Engineering, AI with Robotics, Networking , Cyber Security , Data Science with Analytics or Advanced C omputer Science .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 36, "total_chunks": 224}}, {"id": 47, "text": "\u201cThis type of project involves a thorough investigation of a particular area; improving your understanding of that area, identifying strengths and weaknesses within the field, discussing how the field has evolved, and acknowledging areas su itable for further development and investigation. This kind of project will involve some form of literature search and review.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 37, "total_chunks": 224}}, {"id": 48, "text": "This kind of project will involve some form of literature search and review. A research -based project may well have to do more than establish the fi eld of study.\u201d (Dawson, 2009) You must have a specific research question or hypothesis to investigate.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 38, "total_chunks": 224}}, {"id": 49, "text": "A research -based project may well have to do more than establish the fi eld of study.\u201d (Dawson, 2009) You must have a specific research question or hypothesis to investigate.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 39, "total_chunks": 224}}, {"id": 50, "text": "AI with/ and Robot ics project (7COM1036 /86) \u2022 be able to undertake a practical piece of work that demonstrates that they can apply their knowledge and skills to the design and development of computerised solutions to a particular problem within the domain of computer science .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 40, "total_chunks": 224}}, {"id": 51, "text": "Computer Networking Principles and Practice project (7COM 1037 ) \u2022 be able to select and use appropriate techniques and tools employed in computer networking, distributed systems, and system security in order to conduct a practical investigation into a particular distributed systems or system security problem.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 41, "total_chunks": 224}}, {"id": 52, "text": "Software En gineering project (7COM1038 ) \u2022 be able to select and use appropriate software engineering models, methodologies, measures and tools in order to conduct a practical investigation or solve a particular software engineering problem .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 42, "total_chunks": 224}}, {"id": 53, "text": "Advanced CS project (7COM10 39) \u2022 be able to select and use appropriate techniques and tools employed in computer science in order to conduct a practical investigation of a particular advanced computer science problem .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 43, "total_chunks": 224}}, {"id": 54, "text": "Cyber Security project (7COM1070) \u2022 be able to select and use appropr iate techniques and tools employed in cyber security in order to conduct a practical investigation into a particular cyber security problem .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 44, "total_chunks": 224}}, {"id": 55, "text": "Data Science and Analytics Masters Project (7COM1075) \u2022 be able to select and use appropriate techniques and tools em ployed in data science and analytics in order to conduct a practical investigation into a particular data science and analytics problem .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 45, "total_chunks": 224}}, {"id": 56, "text": "Computer Networks and Systems Security Project (7COM1077) \u2022 be able to select and use appropriate techniques and tools employed in computer networking, distributed systems, and system security in order to conduct a practical investigation into a particular distributed systems or sys tem security problem.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 46, "total_chunks": 224}}, {"id": 57, "text": "MSc Project Handbook 8 2.1.2 Development project *If you are on the \u201ccrossover\u201d award, the requirements are significantly different . The development project \u201cincludes the development of, not only software and hardware systems, but also of process models, methods, algorithms, theories, designs, requirement specifications, and other interim documents.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 47, "total_chunks": 224}}, {"id": 58, "text": "The development project \u201cincludes the development of, not only software and hardware systems, but also of process models, methods, algorithms, theories, designs, requirement specifications, and other interim documents. Examples of software development projects include database systems, multimedia systems, information systems, and web -based systems.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 48, "total_chunks": 224}}, {"id": 59, "text": "Examples of software development projects include database systems, multimedia systems, information systems, and web -based systems. For some developments (notably software) you will be required to in clude requirements documentation, designs, analyses, and fully documented test results along with user manuals or guides.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 49, "total_chunks": 224}}, {"id": 60, "text": "For some developments (notably software) you will be required to in clude requirements documentation, designs, analyses, and fully documented test results along with user manuals or guides. Depending on the nature of your course, the focus for a development project may vary.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 50, "total_chunks": 224}}, {"id": 61, "text": "Depending on the nature of your course, the focus for a development project may vary. Whichever kind of development project you tackl e, it is unlikely that the development of a product would be acceptable on its own. In addition, you would normally be expected to include a critical evaluation of the product as well as the development process used.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 51, "total_chunks": 224}}, {"id": 62, "text": "In addition, you would normally be expected to include a critical evaluation of the product as well as the development process used. Critical evaluation emphasises the dist inction between the academic qualities of your wor k from technical ability alone.\u201d (Dawson, 2009) Development project learning outcomes 1.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 52, "total_chunks": 224}}, {"id": 63, "text": "Critical evaluation emphasises the dist inction between the academic qualities of your wor k from technical ability alone.\u201d (Dawson, 2009) Development project learning outcomes 1. be able to demonstrate a deep understanding of different approaches to modell ing, design and programming; 2.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 53, "total_chunks": 224}}, {"id": 64, "text": "be able to demonstrate a deep understanding of different approaches to modell ing, design and programming; 2. show how the se approaches might affect the nature of solutions to computational problems and critically evaluate their deploym ent in appropriate contexts. 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 54, "total_chunks": 224}}, {"id": 65, "text": "3. be able to refer to the findings of other academic writers to justify their chosen approach to the development o f a solution, and to evaluate the out comes of their project work. 4.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 55, "total_chunks": 224}}, {"id": 66, "text": "4. be able to undertake a practical piece of work that demonstrates that they can apply their knowledge and skills to the design and development of complex computerised solutions to a particul ar problem within the domain of computer science. 2.2 Ethics approval If you are planning to use other people in your project, you MUST apply to UH for Ethics Approval.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 56, "total_chunks": 224}}, {"id": 67, "text": "2.2 Ethics approval If you are planning to use other people in your project, you MUST apply to UH for Ethics Approval. You will need to get ethics approval before running a survey, conducting interviews, or getting people to evaluate your system.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 57, "total_chunks": 224}}, {"id": 68, "text": "You will need to get ethics approval before running a survey, conducting interviews, or getting people to evaluate your system. However, if the questions you propose to ask are noncontroversial, and you promise to keep the responses anonymous, this should be a formality , but not trivial , BUT it takes some time. Allow plenty of time.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 58, "total_chunks": 224}}, {"id": 69, "text": "Allow plenty of time. To get approval, you need to complete some form s, write a statement that explains in detail what kind of questions you will ask ( -- it would be better , and speed up the process, if you could provide the actual qu estions). You should email all the documents to your supervisor to check before submitting for the Ethics Approval .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 59, "total_chunks": 224}}, {"id": 70, "text": "You should email all the documents to your supervisor to check before submitting for the Ethics Approval . Your application will be reviewed by the university\u2019s Ethics Committee. The y have many forms to look at, so you need to give them enough inf ormation to decide quickly. You should apply at least three weeks in advance .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 60, "total_chunks": 224}}, {"id": 71, "text": "You should apply at least three weeks in advance . For example, do not just say \u201cconduct a survey \u201d or \u201cinterview some clients \u201d, because you haven't told them enough to let them judge whether there MSc Project Handbook 9 might be a problem with what you propose to do. You should explain the purpose(s) of the survey/interviews (e.g.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 61, "total_chunks": 224}}, {"id": 72, "text": "You should explain the purpose(s) of the survey/interviews (e.g. to determine functional requirements, or to obtain feedback on the quality of the user interface) and say what the questions will be about. Read the ethics notes on Canvas for further guidance and find the relevant links for your application. Breaching ethics rules can result in failure !", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 62, "total_chunks": 224}}, {"id": 73, "text": "Breaching ethics rules can result in failure ! 2.3 Project management You should always have in mind that this is your project and you set the agenda for it. You should expect to learn new thin gs while working on your MSc Project and not just complete something you could have done as an undergraduate.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 63, "total_chunks": 224}}, {"id": 74, "text": "You should expect to learn new thin gs while working on your MSc Project and not just complete something you could have done as an undergraduate. You are responsible for your work and management and y ou need to manage the time you spend on your project including the time you spend with your supervisor . After all your t ime management is very important for the outcome of your work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 64, "total_chunks": 224}}, {"id": 75, "text": "After all your t ime management is very important for the outcome of your work. You need to concentrate on your aim, defin e appropriate deadlines , and also plan on what you are working on and reading each day . It is important not to be over optimistic and have a plan. You can divide the time you have available into weeks and keep a note of whether you are on schedule or not.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 65, "total_chunks": 224}}, {"id": 76, "text": "You can divide the time you have available into weeks and keep a note of whether you are on schedule or not. You should expect parallel processes in your project plan and also allow enough time for writing up your report, inste ad of planning to write up everything at the end. You could t ry planning forward at the end of each day , so that you have a diary for the following day.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 66, "total_chunks": 224}}, {"id": 77, "text": "You could t ry planning forward at the end of each day , so that you have a diary for the following day. Often you may need to r e-plan and re -organise in order to take account of the actual state of your proj ect. However, there is no need to submit revised plans since you should use this for the organisation and management of your own project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 67, "total_chunks": 224}}, {"id": 78, "text": "However, there is no need to submit revised plans since you should use this for the organisation and management of your own project. It is a wise idea to prepar e and maintain weekly progress report s. A weekly progress report will help you to get the m ost out of your meeting with your supervisor as well. This might include what you have done , learnt , troublesh ot, planned for next week.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 68, "total_chunks": 224}}, {"id": 79, "text": "This might include what you have done , learnt , troublesh ot, planned for next week. It will also help your project supervisor to focus on important issues on your next meeting , while i t will force you to be clear about what you have achieved, and to be honest about any problems you are having .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 69, "total_chunks": 224}}, {"id": 80, "text": "It will also help your project supervisor to focus on important issues on your next meeting , while i t will force you to be clear about what you have achieved, and to be honest about any problems you are having . When the problems are fixed, they can be described under what have been done and learnt as one of your achievements.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 70, "total_chunks": 224}}, {"id": 81, "text": "When the problems are fixed, they can be described under what have been done and learnt as one of your achievements. It is a good practise to keep it short , so that it fits on one A4 sized page . Small tasks are best and you should keep it measurable, e.g. I wrote 6 lines of code or I read 270 pages of the book, \u201cC++ in 21 days\u201d.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 71, "total_chunks": 224}}, {"id": 82, "text": "I wrote 6 lines of code or I read 270 pages of the book, \u201cC++ in 21 days\u201d. Examples of non -reasonable achievements are: reading about VPNs, learning VB, thinking about the design, or s tarted on implementation .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 72, "total_chunks": 224}}, {"id": 83, "text": "Examples of non -reasonable achievements are: reading about VPNs, learning VB, thinking about the design, or s tarted on implementation . Be aware of the Serious Adverse Cir cumstances (SAC) rules and procedures, as y ou cannot get extr a time to finish without SACs, nor a better mark than the work deserves (even with SACs). If you are applying for a SAC, do it as soon as possible.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 73, "total_chunks": 224}}, {"id": 84, "text": "If you are applying for a SAC, do it as soon as possible. 2.3.1 Further guidance \u2022 If your project involves building a system, make sure you leave time for evaluation. \u2022 Planning helps \u2022 Also, writing a weekly progress report really helps .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 74, "total_chunks": 224}}, {"id": 85, "text": "\u2022 Planning helps \u2022 Also, writing a weekly progress report really helps . MSc Project Handbook 10 \u2022 To reach your goal, you do something (a \u201ctask\"), and , at the end , have something to show (a \u201cdeliverable\") that demonstrates you have met your objective. \u2022 ALWAYS maintain back -up copies o f the most recent version of your work in MORE THAN ONE location.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 75, "total_chunks": 224}}, {"id": 86, "text": "\u2022 ALWAYS maintain back -up copies o f the most recent version of your work in MORE THAN ONE location. 2.3.2 Project Journey As part of your project management you are required to maintain a project journey that acts as a journal for your project .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 76, "total_chunks": 224}}, {"id": 87, "text": "2.3.2 Project Journey As part of your project management you are required to maintain a project journey that acts as a journal for your project .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 77, "total_chunks": 224}}, {"id": 88, "text": "It is a journal that records the details of every meeting you have with your supervisor, outlines your actions for your next meeting and identifies the work you have undertaken form your previous meeting aims to provide structure in the way you manage your work. Your project journey also acts as a measuri ng item to demonstrate your engagement on the project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 78, "total_chunks": 224}}, {"id": 89, "text": "Your project journey also acts as a measuri ng item to demonstrate your engagement on the project. Therefore, you are recommended to share it with the supervisor on a regular basis. Your supervisor could use it to monitor your progress in your project work. A template for the Project Journey in App endix E. MSc Project Handbook 11 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 79, "total_chunks": 224}}, {"id": 90, "text": "MSc Project Handbook 11 3. The Project 3.1 Instructions on the Detailed Project Proposal (DPP) You should select a topic you are REALLY interested in , AND which is relevant to your programme. Don\u2019t forget that you will need to dedicate 600 hours on this project. You can find some project ideas on the module site , but you may also propose your own project .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 80, "total_chunks": 224}}, {"id": 91, "text": "You can find some project ideas on the module site , but you may also propose your own project . You could search for ideas in past dissertations, journal articles, research reports, books, media, discussi ons with academics and experts in the field. You are strongly encouraged to discuss your idea with (potential ) supervisors. Your proposal can, and maybe should, change after submission.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 81, "total_chunks": 224}}, {"id": 92, "text": "Your proposal can, and maybe should, change after submission. However, the more detailed the better, even if it is guesswork ! You s hould arrange to meet your supervisor as soon as possible and discuss your proposal with them. It is acceptable to be wrong about a few things during this stage . The project proposal has no marks (0%) allocati on.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 82, "total_chunks": 224}}, {"id": 93, "text": "The project proposal has no marks (0%) allocati on. However, you are strongly encouraged to invest time in the preparation of this proposal. A complete project proposal will give you a structured plan on how to work on your project , and is of great help to your supervisor .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 83, "total_chunks": 224}}, {"id": 94, "text": "A complete project proposal will give you a structured plan on how to work on your project , and is of great help to your supervisor . The preparation of your proposal should comprise of extensive reading on y our chosen topic that will allow you to develop plans for a literature review.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 84, "total_chunks": 224}}, {"id": 95, "text": "The preparation of your proposal should comprise of extensive reading on y our chosen topic that will allow you to develop plans for a literature review. Some questions that will help answering while working on your proposal are the following: \u2022 Does your project rely on data, information or code that will be difficult to access? \u2022 Are you planning to do something that will not help your grade?", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 85, "total_chunks": 224}}, {"id": 96, "text": "\u2022 Are you planning to do something that will not help your grade? \u2022 Are you expecting the supervisor to tell you what to do for your project? \u2022 Is it realistic in terms of time? \u2022 Is it the right kind of project? \u2022 Does your proposal include some kind of investig ation/ development? \u2022 What will you learn? \u2022 What is your contribution? \u2022 What question are you answering?", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 86, "total_chunks": 224}}, {"id": 97, "text": "\u2022 What question are you answering? The project proposal also forms a plan to your work. You should be able to tell from your lists of tasks what you will do on your project, e.g. \u201cI will investigate...\u201d. It should also include what this will involve, and it should lead you to your Project P lan. A template for your project proposal can be found in Appendix A.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 87, "total_chunks": 224}}, {"id": 98, "text": "A template for your project proposal can be found in Appendix A. You should make sure you start the work on your project immediately after you submit the proposal and always consult your supervisor about major changes to your plans. 3.1.1 Detailed Project P roposal (DPP) presentation \u2022 The same font should be used throughout.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 88, "total_chunks": 224}}, {"id": 99, "text": "3.1.1 Detailed Project P roposal (DPP) presentation \u2022 The same font should be used throughout. We would prefer you to use 12 -point Times, though any reasonable alternative (such as Arial) will be accepted (except for mathematical formulae, where you may use whichever font is most a ppropriate, and program code examples, where you should use a non -proportional font such as Courier) .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 89, "total_chunks": 224}}, {"id": 100, "text": "We would prefer you to use 12 -point Times, though any reasonable alternative (such as Arial) will be accepted (except for mathematical formulae, where you may use whichever font is most a ppropriate, and program code examples, where you should use a non -proportional font such as Courier) .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 90, "total_chunks": 224}}, {"id": 101, "text": "MSc Project Handbook 12 \u2022 Lines should be single -spaced, with between 1/2 a line and a whole line of extra space after each paragraph. \u2022 Margins: at least 20 mm left and right; 25 m m top and bottom. \u2022 No more than three pages in length, excluding the cover sheet, contents list, bibliography and any appendices.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 91, "total_chunks": 224}}, {"id": 102, "text": "\u2022 No more than three pages in length, excluding the cover sheet, contents list, bibliography and any appendices. 3.2 Instructions on the Interim Progress Report (IPR) You should have done about 260 hours work on your project by the time you submit your Interim Progress Report (IPR) . In other words, you are nearly half way through your project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 92, "total_chunks": 224}}, {"id": 103, "text": "In other words, you are nearly half way through your project. We expect you will have made significant inroads into your practical investigation, as well as carrying out backg round research. You should prepare a written report on the progress you have made.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 93, "total_chunks": 224}}, {"id": 104, "text": "You should prepare a written report on the progress you have made. This report should not be aimed at your supervisor (who should already know what you are doing), but at a technically competent reader who knows nothing about your project, such as the independent marker. Say how far you have got: tell us what you have completed, why you have done it. Discuss any problems .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 94, "total_chunks": 224}}, {"id": 105, "text": "Discuss any problems . The report should be numbered in one continuous sequence. The Interim Progress Report (IPR) weights 5% of your overall gr ade and you will receive marks based on the quality of the project, the quality and amount of the practical work, your report structure and the presentation of your report. The submission must ONLY be via Canvas .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 95, "total_chunks": 224}}, {"id": 106, "text": "The submission must ONLY be via Canvas . You will receive feedback from your supervisor . The IPR should include the following sections: 3.2.1 Section 1: Introduction and overview It is suggested that this section should be about 2 -3 pages long in total, and you may add any appropriate section or sub -section headings you wish to this li st.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 96, "total_chunks": 224}}, {"id": 107, "text": "The IPR should include the following sections: 3.2.1 Section 1: Introduction and overview It is suggested that this section should be about 2 -3 pages long in total, and you may add any appropriate section or sub -section headings you wish to this li st.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 97, "total_chunks": 224}}, {"id": 108, "text": "You may reuse parts of your Detailed P roject Proposal (DPP) if appropriate [ and in turn you may re -use parts of the Interim Progress Report (IPR) in your final report] . Describe the research question your project sets out to address as well as your proposed practical investigation .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 98, "total_chunks": 224}}, {"id": 109, "text": "Describe the research question your project sets out to address as well as your proposed practical investigation . Describe any technical work that you are undertaking as part of that investigation, such as the construction of data -sets or software /hardware apparatus. Say what tools and techniques you are using for your investigation, exp erimentation, and evaluation of your work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 99, "total_chunks": 224}}, {"id": 110, "text": "Say what tools and techniques you are using for your investigation, exp erimentation, and evaluation of your work. You should list the specific deliverables you intend to produce during your project: design, documents, programs, questionnaires, databases, test plans, experimental designs, results, etc.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 100, "total_chunks": 224}}, {"id": 111, "text": "You should list the specific deliverables you intend to produce during your project: design, documents, programs, questionnaires, databases, test plans, experimental designs, results, etc. 3.2.2 Section 2: Progress to date It is suggested that you write about 2 -3 pages and add an appropriate section heading and any necessary sub -headings. Describe the progress you have made so far i.e.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 101, "total_chunks": 224}}, {"id": 112, "text": "Describe the progress you have made so far i.e. what you have done. Be specific. Problems encountered or anticipated and steps taken /to be taken to solve them. Explain the supporting evidence you can provide for the work you have done, the documents that demonstrate your achievements, and include these documents as appendices.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 102, "total_chunks": 224}}, {"id": 113, "text": "Explain the supporting evidence you can provide for the work you have done, the documents that demonstrate your achievements, and include these documents as appendices. MSc Project Handbook 13 3.2.3 Section 3: Planned work This section is expected to be ab out half to one page in length. Again, add an appropriate section heading and any necessary sub -headings.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 103, "total_chunks": 224}}, {"id": 114, "text": "Again, add an appropriate section heading and any necessary sub -headings. List the major tasks that need to be completed for the project to be a success, from start to finish (including any you have already completed) with t arget completion dates. Explain what each task means and what deliverables it will produce.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 104, "total_chunks": 224}}, {"id": 115, "text": "Explain what each task means and what deliverables it will produce. Say how you will judge the quality of your project work and how you intend to evaluate the process through which you have gone . Don't forget to include time for writing up the final report and preparing for the demonstration/presentation after submission. 3.2.4 Bibliography List any sources that you cite in your report.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 105, "total_chunks": 224}}, {"id": 116, "text": "3.2.4 Bibliography List any sources that you cite in your report. You should also list any sources that you have used, even if not cited directly. Use the Harvard syste m for your in -text citations, and for your references, producing one list, ordered by author surname (whether the material is drawn from books, journals, web pages, forums or blogs, or is a piece of software).", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 106, "total_chunks": 224}}, {"id": 117, "text": "Use the Harvard syste m for your in -text citations, and for your references, producing one list, ordered by author surname (whether the material is drawn from books, journals, web pages, forums or blogs, or is a piece of software). 3.2.5 Appendices Include supporting evidence as ap pendices to your report.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 107, "total_chunks": 224}}, {"id": 118, "text": "3.2.5 Appendices Include supporting evidence as ap pendices to your report. These should be numbered (Appendix 1, Appendix 2 etc.) and each should start on a new page and be given a title. Your tutor is not required to read the appendices but may refer to them for evidence to back up your claims. Typically , appendices will include evidence of design, investigative or practical work (e.g.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 108, "total_chunks": 224}}, {"id": 119, "text": "Typically , appendices will include evidence of design, investigative or practical work (e.g. formal specifications, code, questionnaires, and so on). At this stage, it will mostly be work - in-progress, and it is fine for this to be handwritten.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 109, "total_chunks": 224}}, {"id": 120, "text": "At this stage, it will mostly be work - in-progress, and it is fine for this to be handwritten. You may scan document s and include them with your submission if you wish ; but you may not wish not to spend too much time on tasks like scanning handwriting notes. I nstead , you could take the materials to your next project meeting so that your supervisor is aware of the progress you have made .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 110, "total_chunks": 224}}, {"id": 121, "text": "I nstead , you could take the materials to your next project meeting so that your supervisor is aware of the progress you have made . 3.2.6 IPR report p resentation The report sh ould be prepared as follows: \u2022 The same font should be used throughout.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 111, "total_chunks": 224}}, {"id": 122, "text": "3.2.6 IPR report p resentation The report sh ould be prepared as follows: \u2022 The same font should be used throughout.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 112, "total_chunks": 224}}, {"id": 123, "text": "We would prefer you to use 12-point Times, though any reasonable alternative (such as Arial) will be accepted , (except for mathematical formulae, where you may use whichever font is most appropriate, and program code examples, where you should use a non -proportional font such as Courier) .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 113, "total_chunks": 224}}, {"id": 124, "text": "\u2022 Lines should be single -spaced, with between 1/2 a line and a whole line of extra space after each paragraph. \u2022 Margins: at least 20 mm left and right; 25 mm top and bottom. \u2022 The whole report is expected to be no more than eight pages in length, excluding t he cover sheet, contents list, bibliography and any appendices.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 114, "total_chunks": 224}}, {"id": 125, "text": "\u2022 The whole report is expected to be no more than eight pages in length, excluding t he cover sheet, contents list, bibliography and any appendices.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 115, "total_chunks": 224}}, {"id": 126, "text": "MSc Project Handbook 14 3.3 Instructions on the Final Project Report (FPR) After your IPR report submission, y ou should have done another 340 hours of work on your project, amounting to about 600 hours of effort by the time you submit your project report.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 116, "total_chunks": 224}}, {"id": 127, "text": "The final project report is worth 95% of the overall assessment for the module; Please allow plenty of the time to the collation, writing, editing and formatting of the report and supporting documents, and the preparati on and time given to a demonstration and face to face (or online) discussion of your work with your assessors.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 117, "total_chunks": 224}}, {"id": 128, "text": "You should be aware from the outset that FPR and your explanation of your work is the primary evidence used in the assessment - and it is th is assessment of your abilities to conduct and deliver a project that is key. You should assume that your audience has the level of knowledge of a good Masters \u2019 student who has taken the same modules as you.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 118, "total_chunks": 224}}, {"id": 129, "text": "You should assume that your audience has the level of knowledge of a good Masters \u2019 student who has taken the same modules as you. Keep this in mind when writing about background te chnical information and do not present large amounts of material that such a reader would already know , or that could be read in a standard textbook.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 119, "total_chunks": 224}}, {"id": 130, "text": "Keep this in mind when writing about background te chnical information and do not present large amounts of material that such a reader would already know , or that could be read in a standard textbook. Reference the textbook in your bibliography and keep the information you present specific to the project work that you have done .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 120, "total_chunks": 224}}, {"id": 131, "text": "Reference the textbook in your bibliography and keep the information you present specific to the project work that you have done . Any software product , model , or artefact that you may have produced during your project is not the focus of the assessment. The project module is about assessing your abilities as a student in your discipline area.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 121, "total_chunks": 224}}, {"id": 132, "text": "The project module is about assessing your abilities as a student in your discipline area. Do not underestimate the time it takes to produce your report . You may want to get your supervisor to read part of it to comment on your style before you submit . You m ay need to redraft the FPR several times.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 122, "total_chunks": 224}}, {"id": 133, "text": "You m ay need to redraft the FPR several times. Don\u2019t forget that i nternet/computing facilities could become unavailable at short notice at critical times . Allow plenty of time and have backup plans. 3.3.1 FPR report presentation The report should be prepared as follows: \u2022 Approximately 10,000 words in length \u2022 The bibliography and appendices are not included in the word length.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 123, "total_chunks": 224}}, {"id": 134, "text": "3.3.1 FPR report presentation The report should be prepared as follows: \u2022 Approximately 10,000 words in length \u2022 The bibliography and appendices are not included in the word length. \u2022 Do not use the cover sheet (So NO assignment briefing sheet ). \u2022 The same font should be used throughout.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 124, "total_chunks": 224}}, {"id": 135, "text": "\u2022 The same font should be used throughout. We would prefer you to use 12 -point Times, though any reasonable alternative (such as Arial) will be accepted , (except for mathematica l formulae, where you may use whichever font is most appropriate, and program code examples, where you should use a non -proportional font such as Courier) .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 125, "total_chunks": 224}}, {"id": 136, "text": "We would prefer you to use 12 -point Times, though any reasonable alternative (such as Arial) will be accepted , (except for mathematica l formulae, where you may use whichever font is most appropriate, and program code examples, where you should use a non -proportional font such as Courier) .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 126, "total_chunks": 224}}, {"id": 137, "text": "\u2022 Lines should be single -spaced, with between 1/2 a line and a whole line of extra space after each p aragraph. \u2022 Margins: at least 20 mm left and right; 25 mm top and bottom. \u2022 Pages should be numbered in one continuous sequence. 3.3.2 Assessment process The submission of the final project report must ONLY be through Canvas.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 127, "total_chunks": 224}}, {"id": 138, "text": "3.3.2 Assessment process The submission of the final project report must ONLY be through Canvas. MSc Project Handbook 15 3.3.3 Marking process Two markers will independently assess your work. \u2022 If the grades they award differ by 10 the most, the grades will be averaged, combined with the grade for the Interim Progress Report (IPR) , and presented to the Board of Examiners for approval.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 128, "total_chunks": 224}}, {"id": 139, "text": "\u2022 If the grades they award differ by 10 the most, the grades will be averaged, combined with the grade for the Interim Progress Report (IPR) , and presented to the Board of Examiners for approval. \u2022 Where the markers diffe r 11 or more marks, the standard School procedure will be followed to resolve the difference. 3.3.4 Plagiarism checking This assignment must be completed individually.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 129, "total_chunks": 224}}, {"id": 140, "text": "3.3.4 Plagiarism checking This assignment must be completed individually. Be aware of the University\u2019s policies on plagiarism and collusion: these are severe offences with severe penalties.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 130, "total_chunks": 224}}, {"id": 141, "text": "Be aware of the University\u2019s policies on plagiarism and collusion: these are severe offences with severe penalties.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 131, "total_chunks": 224}}, {"id": 142, "text": "A \u2018mock\u2019 submission point will be set up to allow you to upload and check the similarity report on Turnitin before your (real) final submission. Any \u2018mock\u2019 submissions are not stored in a repository and you may re -submit multiple times. 3.3.5 Project Demonstration You must give a live demonstration of your work to your supervisor and second marker who will ask questions about your work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 132, "total_chunks": 224}}, {"id": 143, "text": "3.3.5 Project Demonstration You must give a live demonstration of your work to your supervisor and second marker who will ask questions about your work. This demonstration is part of the formal assessment process and counts 20% of your final project mark. It is your responsibility to agree a time and date for this with your supervisor (who would contact the 2nd marker on your behalf) .", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 133, "total_chunks": 224}}, {"id": 144, "text": "It is your responsibility to agree a time and date for this with your supervisor (who would contact the 2nd marker on your behalf) . It should normally take place after both markers have assessed the report and you must arrive on time and be well-prepared for your demonstration . Please consider the following project demonstration guide: 1.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 134, "total_chunks": 224}}, {"id": 145, "text": "Please consider the following project demonstration guide: 1. All students are required to give a demonstration or other presentat ion of the work they have produced for their project. You will have 10 minutes to show your work. If you go on longer than 10 minutes you may be interrupted. Then there will be 10 minutes for answering questions.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 135, "total_chunks": 224}}, {"id": 146, "text": "Then there will be 10 minutes for answering questions. The time is very short so you will need to plan and should discuss how best to present your work with your project supervisor. Please do not attempt to do a PowerPoint presentation telling us about what you did: you need to show us the actual work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 136, "total_chunks": 224}}, {"id": 147, "text": "Please do not attempt to do a PowerPoint presentation telling us about what you did: you need to show us the actual work. Suppose, for example, that the main deliverable from your project consists of an extensive set of test results and analysis of those results. We would not want to be told what you did, we would want you to present the actual results, and talk us through them.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 137, "total_chunks": 224}}, {"id": 148, "text": "We would not want to be told what you did, we would want you to present the actual results, and talk us through them. MSc Project Handbook 16 2. The assessment will be carried out by your supervisor and the second marker for your project, who will both attend your demonstration. 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 138, "total_chunks": 224}}, {"id": 149, "text": "3. Subject to Covid rules, y ou may use one of the university computers (please make sure the lab is going to be free at the arranged time for your presentation befor ehand) or your own laptop. 4. We cannot provide networking facilities for your laptop machine beyond what is normally available in the area where your demonstration takes place.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 139, "total_chunks": 224}}, {"id": 150, "text": "We cannot provide networking facilities for your laptop machine beyond what is normally available in the area where your demonstration takes place. But in general, it is perfectly acceptable to demonstrate a networking, client -server or web -based project using the loopback address 127.0.0.1 (localhost).", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 140, "total_chunks": 224}}, {"id": 151, "text": "But in general, it is perfectly acceptable to demonstrate a networking, client -server or web -based project using the loopback address 127.0.0.1 (localhost). If one or two features (such as automated email to another machine) cannot be demonstrated for sound technical reasons that is unlikely to be a problem unless they are at the core of your system. 5.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 141, "total_chunks": 224}}, {"id": 152, "text": "5. [NOTE - THIS IS SUBJECT TO VID REGULATIONS] If you need to use specialist software that is not installed in the general laboratory area then you could consider to approach Library and Compu ting Services Helpdesk about getting the software installed on one of the UH machines. THIS NEEDS TO BE DONE AS SOON AS POSSIBLE.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 142, "total_chunks": 224}}, {"id": 153, "text": "THIS NEEDS TO BE DONE AS SOON AS POSSIBLE. Please be aware, however, that we cannot permit the installation of software for which neither we, nor you, have a valid licen se (if the software is being installed under your license you will be asked to prove that you have one). 6. If you miss the demonstration this is like missing an examination.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 143, "total_chunks": 224}}, {"id": 154, "text": "If you miss the demonstration this is like missing an examination. If there is a good reason for missing the appointment for your demonstration, there may be an opportunity to reschedule the demo, but if this happens you will need valid and documented serious adverse circumstances (SAC) presented to the Board of Examiners in the usual way.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 144, "total_chunks": 224}}, {"id": 155, "text": "If there is a good reason for missing the appointment for your demonstration, there may be an opportunity to reschedule the demo, but if this happens you will need valid and documented serious adverse circumstances (SAC) presented to the Board of Examiners in the usual way. 3.3.6 Late submissions Standard penalties will apply to late submiss ions.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 145, "total_chunks": 224}}, {"id": 156, "text": "3.3.6 Late submissions Standard penalties will apply to late submiss ions. If you submit your report late , the standard lateness penalty will be applied . If you submit more than five days late you will get zero for your final submission. If you do not give a demonstration you will be treated as having failed to submit evidence to back up the claims made in your report.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 146, "total_chunks": 224}}, {"id": 157, "text": "If you do not give a demonstration you will be treated as having failed to submit evidence to back up the claims made in your report. If you wish to put forward serious adverse circumstances (SAC) in mitigation of late submission, or failure to attend the demonstration, then you must complete the Serious Adverse Circumstances (SAC) form with documentary evidence of the circumstances.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 147, "total_chunks": 224}}, {"id": 158, "text": "If you wish to put forward serious adverse circumstances (SAC) in mitigation of late submission, or failure to attend the demonstration, then you must complete the Serious Adverse Circumstances (SAC) form with documentary evidence of the circumstances. This should be done as soon as possible, and in any case before the meeting of the Board of Examiners who will con sider the matter.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 148, "total_chunks": 224}}, {"id": 159, "text": "This should be done as soon as possible, and in any case before the meeting of the Board of Examiners who will con sider the matter.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 149, "total_chunks": 224}}, {"id": 160, "text": "Even if your serious adverse circumstances (SAC) are accepted, your project cannot be marked according to the schedule described here unless it is received on time; if it is submitted substantially later than the due date, demonstrations and assessments may be deferred to the assessment period at the end of the next semester.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 150, "total_chunks": 224}}, {"id": 161, "text": "MSc Project Handbook 17 3.4 Final project report supporting structure 3.4.1 Title Page Please use the template provided (see Appendix B). 3.4.2 Abstract The abstract should be a statement up to half a page in length describing the subject matter of the project report and the main findings and conclusions presented in the report.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 151, "total_chunks": 224}}, {"id": 162, "text": "3.4.2 Abstract The abstract should be a statement up to half a page in length describing the subject matter of the project report and the main findings and conclusions presented in the report. A reader should be able to decide what the report is about by reading this alone.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 152, "total_chunks": 224}}, {"id": 163, "text": "A reader should be able to decide what the report is about by reading this alone. 3.4.3 Acknowledgements (if any) 3.4.4 Contents page The table of contents must show the chapters of the report, with the title of each and the page number on which each chapter begins. If your chapters are organised in sections, with a title for each, show these sections on the contents page as well.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 153, "total_chunks": 224}}, {"id": 164, "text": "If your chapters are organised in sections, with a title for each, show these sections on the contents page as well. Do not go to greater detail than sections, as the table of contents should fit on a single page. 3.4.5 Chapter 1: Introduction to the project This chapter should introduce the project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 154, "total_chunks": 224}}, {"id": 165, "text": "3.4.5 Chapter 1: Introduction to the project This chapter should introduce the project. Say what the project was about, such as what are the research question s you were attempting to address, give some brief background information (sufficient to \u2018set the scene\u2019) and list the objectives you were tryin g to achieve by doing the project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 155, "total_chunks": 224}}, {"id": 166, "text": "Say what the project was about, such as what are the research question s you were attempting to address, give some brief background information (sufficient to \u2018set the scene\u2019) and list the objectives you were tryin g to achieve by doing the project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 156, "total_chunks": 224}}, {"id": 167, "text": "These should be based on what you said in your project plan, but they may have changed since the plan was submitted; any changes should be explained later in the report, probably in the overall evaluation of the work. This chapter should also introduce the report.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 157, "total_chunks": 224}}, {"id": 168, "text": "This chapter should also introduce the report. Give a very brief statement of how your report is structured, including what is in each chapter (and the most important appendices), just to help the reader gain an idea of how you have presented your work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 158, "total_chunks": 224}}, {"id": 169, "text": "Give a very brief statement of how your report is structured, including what is in each chapter (and the most important appendices), just to help the reader gain an idea of how you have presented your work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 159, "total_chunks": 224}}, {"id": 170, "text": "3.4.6 Collection of main chapters How to present these will depend largely on the subject of the project, but h ere are a few points of advice: (a) You may assume that your readership has the level of knowledge of a good Masters \u2019 student who has taken the same modul es as you.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 160, "total_chunks": 224}}, {"id": 171, "text": "Bear this in mind when writing about background technical information and do not present large amounts of material that such a reader would already know or that could be read in a standard textbook. Simply reference the textbook in your bibliogr aphy and keep the information you present specific to your own work. Explain how any background material you present has been used in your project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 161, "total_chunks": 224}}, {"id": 172, "text": "Explain how any background material you present has been used in your project. MSc Project Handbook 18 (b) The main chapters of your report are where you describe your achievements. Instead of just listing the tasks that you carried out diary -style, in the order you did them, it is better to organize the chapters around topics.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 162, "total_chunks": 224}}, {"id": 173, "text": "Instead of just listing the tasks that you carried out diary -style, in the order you did them, it is better to organize the chapters around topics.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 163, "total_chunks": 224}}, {"id": 174, "text": "(c) In these chapters, you should tell the reader what you have done, why you did it, what results you obtained, what you think you hav e achieved (including the problems you have overcome), how you calculated the commercial risk for your project and how you managed it, and how you went about evaluating your work (criteria applied, tests performed, and so on).", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 164, "total_chunks": 224}}, {"id": 175, "text": "Be sure to present the result s of your project work properly. (d) It is important to present in the written report information about your work that will not be conveyed at the demonstration.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 165, "total_chunks": 224}}, {"id": 176, "text": "(d) It is important to present in the written report information about your work that will not be conveyed at the demonstration.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 166, "total_chunks": 224}}, {"id": 177, "text": "In this chapter, you shoul d summarise your main findings/results and evaluate what you have achieved and how you went about it. You may find it more convenient to include an evaluation of your work in the chapters where it is presented and summarise that evaluation here. What is crucial is to have a critical self -evaluation of the extent to which you have achieved the things you set out to do.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 167, "total_chunks": 224}}, {"id": 178, "text": "What is crucial is to have a critical self -evaluation of the extent to which you have achieved the things you set out to do. Assess the extent to which you met your objectives.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 168, "total_chunks": 224}}, {"id": 179, "text": "Assess the extent to which you met your objectives. You will not be penalised for acknowledging that you failed to achieve everything you set out to do, and especially not the more advanced things, but you certainly would be criticised if you gave the impression of not having noticed that you had failed to meet an objective.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 169, "total_chunks": 224}}, {"id": 180, "text": "You will not be penalised for acknowledging that you failed to achieve everything you set out to do, and especially not the more advanced things, but you certainly would be criticised if you gave the impression of not having noticed that you had failed to meet an objective.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 170, "total_chunks": 224}}, {"id": 181, "text": "You should have a short section on management of the project (usually one to two pages), including how you planned to allocate time at the start of the year and how it worked out in practice. Additionally, you should demonstrate you have considered the commercial and economic context of your project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 171, "total_chunks": 224}}, {"id": 182, "text": "Additionally, you should demonstrate you have considered the commercial and economic context of your project. 3.4.8 Bibliography and r eferencing After the final chapter, and before any appendices, list any sources (books, journals, web pages etc.) that you cite in your report. You should also list any sources that you have used, even if not cited directly.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 172, "total_chunks": 224}}, {"id": 183, "text": "You should also list any sources that you have used, even if not cited directly. Use the Harvard system for your in -text citations, and for your references, producing one list, ordered by author surname (whether the material is drawn from books, journals, forums or blogs, or is a piece of software).", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 173, "total_chunks": 224}}, {"id": 184, "text": "Use the Harvard system for your in -text citations, and for your references, producing one list, ordered by author surname (whether the material is drawn from books, journals, forums or blogs, or is a piece of software).", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 174, "total_chunks": 224}}, {"id": 185, "text": "A guide to the Harvard referencing system is provided at http://www.studynet.herts.ac.uk/ptl/common/LIS.nsf/lis/busharvard MSc Project Handbook 19 The University provides an online \" Library SkillUP \" tutorial on citing sources and referencing that you should work through.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 175, "total_chunks": 224}}, {"id": 186, "text": "It is available at http://www.studynet.herts.ac.uk/ptl/common/LIS.nsf/lis/citing_menu 3.4.9 Appendices The appendices to your report provide supporting evidence of the quality and quantity of the work you have done. Your appendices should contain any specifications, design documents, survey forms and results, screen shots, and other documentation produced as pa rt of your project.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 176, "total_chunks": 224}}, {"id": 187, "text": "Your appendices should contain any specifications, design documents, survey forms and results, screen shots, and other documentation produced as pa rt of your project. Without this supporting evidence, it is possible that the markers will take the view that you have not done everything you claim to have done. However, the appendices are only there to back up the claims made in your report.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 177, "total_chunks": 224}}, {"id": 188, "text": "However, the appendices are only there to back up the claims made in your report. Markers can only be expected to look at those parts of the appendices you draw their attention to in the main body of the report. They are not obliged to read the appendices in detail, though they may do so.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 178, "total_chunks": 224}}, {"id": 189, "text": "They are not obliged to read the appendices in detail, though they may do so.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 179, "total_chunks": 224}}, {"id": 190, "text": "If you think it is important to draw the markers' attentio n to a document , or a part of a document, tell them where to find (don't just say \"the code for this is in appendix 3\", give a page number, and/or other information that makes it clear how to find it; better still, include the relevant fragment of the code in the body of your report).", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 180, "total_chunks": 224}}, {"id": 191, "text": "Any program code written by you must be presented in the appendices . But do not include code that is machine generated, or that comes from a different author, unless it is necessary for the reader to understand the work you have done. If you do include code that you did not write yourself, it is your responsibility to make clear which parts of the program are your own and which parts are not.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 181, "total_chunks": 224}}, {"id": 192, "text": "If you do include code that you did not write yourself, it is your responsibility to make clear which parts of the program are your own and which parts are not. If you present automatically generated code, or the code of another programmer, as if it were your own, you may be accused of plagiarism.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 182, "total_chunks": 224}}, {"id": 193, "text": "If you present automatically generated code, or the code of another programmer, as if it were your own, you may be accused of plagiarism. Do not include copies of any web pages that you have referred to, unless it is necessary for the reader to see them to make your point: just put the citation deta ils in your bibliography.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 183, "total_chunks": 224}}, {"id": 194, "text": "Do not include copies of any web pages that you have referred to, unless it is necessary for the reader to see them to make your point: just put the citation deta ils in your bibliography. Samples of the work that is presented in the appendices may (and probably should) be included in the body of your report to illuminate a point or for discussion purposes.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 184, "total_chunks": 224}}, {"id": 195, "text": "Samples of the work that is presented in the appendices may (and probably should) be included in the body of your report to illuminate a point or for discussion purposes.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 185, "total_chunks": 224}}, {"id": 196, "text": "\u2022 Background reading and the results of text -based research; \u2022 Problem definition; \u2022 Quality of solution: design and implementation; experimental work; MSc Project Handbook 20 \u2022 Quality of appr oach: suitability of method, choice of tools and skill in using them; \u2022 Testing; analysis and evaluation of end -product(s) and results.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 186, "total_chunks": 224}}, {"id": 197, "text": "The first three factors are important in any project; the remaining ones may vary in relevance. We expect all students t o be able to explain their work and show an appropriate level of understanding of any technical material they have used or developed.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 187, "total_chunks": 224}}, {"id": 198, "text": "We expect all students t o be able to explain their work and show an appropriate level of understanding of any technical material they have used or developed. Such explanations and demonstrations of understanding should be evident in the written report and during the presentation and demonstration: a body of work that is not backed up by evidence of understanding is likely to achieve a poor grade.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 188, "total_chunks": 224}}, {"id": 199, "text": "Such explanations and demonstrations of understanding should be evident in the written report and during the presentation and demonstration: a body of work that is not backed up by evidence of understanding is likely to achieve a poor grade. 3.5.1 For a numeric g rade of 80 or above We expect the work to be truly outstanding.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 189, "total_chunks": 224}}, {"id": 200, "text": "3.5.1 For a numeric g rade of 80 or above We expect the work to be truly outstanding. 3.5.2 For a numeric g rade between 70 and 79 We expect the w ork to be of an excellent standard.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 190, "total_chunks": 224}}, {"id": 201, "text": "3.5.2 For a numeric g rade between 70 and 79 We expect the w ork to be of an excellent standard. We expect to see evidence that you understand how the concepts and principles underpinning the subject area of your degree are relevant to your project work, that you have made well -reasoned choices of appropriate tools and techniques and applied them in a thoughtful manner.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 191, "total_chunks": 224}}, {"id": 202, "text": "We expect to see evidence that you understand how the concepts and principles underpinning the subject area of your degree are relevant to your project work, that you have made well -reasoned choices of appropriate tools and techniques and applied them in a thoughtful manner.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 192, "total_chunks": 224}}, {"id": 203, "text": "There should be evidence of substantial achievement of very high quality, and your report should demonstrate that you can explain and critique what you have done, why you did it, what you achieved by doing it, and how your work might be improved or extended.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 193, "total_chunks": 224}}, {"id": 204, "text": "We expect all major issues, including the really hard and perhaps un -resolvable ones, to be properly evaluated and commented upon in the project report. We are not looking for an original contrib ution to knowledge, but we expect you to have unearthed and addressed all the complexities of the problem, and not to have avoided any difficulties.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 194, "total_chunks": 224}}, {"id": 205, "text": "We are not looking for an original contrib ution to knowledge, but we expect you to have unearthed and addressed all the complexities of the problem, and not to have avoided any difficulties. We expect the report to be well -structured, coherent, well -written and free of significant grammatical erro rs. 3.5.3 For a numeric g rade between 60 and 69 We expect the work to be of a very good standard.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 195, "total_chunks": 224}}, {"id": 206, "text": "3.5.3 For a numeric g rade between 60 and 69 We expect the work to be of a very good standard. We expect to see a broad -ranging and thorough investigation of the project topic, with a methodical presentation of all the main issues.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 196, "total_chunks": 224}}, {"id": 207, "text": "We expect to see a broad -ranging and thorough investigation of the project topic, with a methodical presentation of all the main issues. There should be evidence of a substantial quantity of work of a high standard, in which you have brought to bear relevant principles and practices and chosen and applied appropriate tools and techniques.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 197, "total_chunks": 224}}, {"id": 208, "text": "There should be evidence of a substantial quantity of work of a high standard, in which you have brought to bear relevant principles and practices and chosen and applied appropriate tools and techniques. We expect to see evidence that you appreciate how your project work is related to your other studies. We expect you to evaluate properly all the main points arising in the work.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 198, "total_chunks": 224}}, {"id": 209, "text": "We expect you to evaluate properly all the main points arising in the work. We also expect you to show that you are aware of the limitations of the work, and to recognise and comment on aspects of it that would merit further study. We would expect your report to be well -structured, coherent, and largely free of grammatical errors.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 199, "total_chunks": 224}}, {"id": 210, "text": "We would expect your report to be well -structured, coherent, and largely free of grammatical errors. MSc Project Handbook 21 3.5.4 For a numeric g rade between 50 and 59 We expect the work to be of a good or at least satisfactory standard.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 200, "total_chunks": 224}}, {"id": 211, "text": "MSc Project Handbook 21 3.5.4 For a numeric g rade between 50 and 59 We expect the work to be of a good or at least satisfactory standard. We expect to see evidence that you have taken a methodical approach to the work, and that you have undertaken practical work of reasonable scale and at least to an average standard.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 201, "total_chunks": 224}}, {"id": 212, "text": "We expect to see evidence that you have taken a methodical approach to the work, and that you have undertaken practical work of reasonable scale and at least to an average standard.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 202, "total_chunks": 224}}, {"id": 213, "text": "We also expect you to demonstrate an understanding of the principal issue s in your project work, and to show that you can describe what you have achieved, and that you can explain the things you have done and why you have done them. We expect your report to be coherent and largely free of grammatical errors.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 203, "total_chunks": 224}}, {"id": 214, "text": "We expect your report to be coherent and largely free of grammatical errors. MSc Project Handbook 22 Appendices All appendices are on Canvas under the relevant sections MSc Project Handbook 23 Appendix A: Detailed Project Proposal (DPP) Template Detailed Project Proposal (DPP) Working Title of the Dissertation 1. Hypothesis 2. The Problem / Short description of your idea 3. The project aim(s) 4.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 204, "total_chunks": 224}}, {"id": 215, "text": "The project aim(s) 4. The project objectives 5. How you plan to conduct your research 6. Project plan 7.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 205, "total_chunks": 224}}, {"id": 216, "text": "Project plan 7.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 206, "total_chunks": 224}}, {"id": 217, "text": "Summary of progress to date (maximum 15) 0 4 8 12 15 Score Little or no evidence of progress Inconsistent, some evidence of progress but lacking continuity Satisfactory summary of progress, little implementation work Good summary of progress, some implementation of work Excellent summary of progress, substantial implementation work 3.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 207, "total_chunks": 224}}, {"id": 218, "text": "Consideration of ethical/legal/professional and social is sues (maximum 20) 0 5 10 15 20 Score MSc Project Handbook 26 None submitted, or irrelevant Na\u00efve/superficial consideration of ethical / legal /professional/social issues Most but not all ethical/ legal/professional/social issues considered Very good consideration of legal/ professional/ social issues.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 208, "total_chunks": 224}}, {"id": 219, "text": "Some awareness of University procedures in relation to ethics approval demonstrated Excellent consideration of legal/ professional/social issues, and knowledge of University procedures in relation to ethics approval demonstrated 4.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 209, "total_chunks": 224}}, {"id": 220, "text": "Project plan (maximum 10) 0 2 5 8 10 Score Little or no evidence of project planning Some evidence of project planning but too vague Satisfactory, concise and coherent project planning with some defined tasks and timelines Good, concise and coherent project plan.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 210, "total_chunks": 224}}, {"id": 221, "text": "Clearly defined tasks and timelines with minor errors Excellent, concise and coherent project plan with clearly defined tas ks and timelines 5. Appendices (maximum 10) 0 2 5 8 10 Score No appendices Appendices provide little evidence of progress Appendices provide some evidence of progress Appendices provide good evidence of progress e.g.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 211, "total_chunks": 224}}, {"id": 222, "text": "Appendices (maximum 10) 0 2 5 8 10 Score No appendices Appendices provide little evidence of progress Appendices provide some evidence of progress Appendices provide good evidence of progress e.g. record of supervisory meetings, source code, screenshots Appendices provide excellent evidence of progress e.g. record of supervisory meetings, source code, screenshots, version control, test plans 6.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 212, "total_chunks": 224}}, {"id": 223, "text": "record of supervisory meetings, source code, screenshots, version control, test plans 6.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 213, "total_chunks": 224}}, {"id": 224, "text": "Referencing (maximum 10) 0 2 5 8 10 Score Little or no coherent referencing and use of technical terms Incomplete referencing and use of technical terms, frequent mistakes Satisfactory referencing and use of technical terms, minor mistakes Good use of referencing and technical terms, occasional mistakes Excellent referencing and use of technical terms, MSc Project Handbook 27 7.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 214, "total_chunks": 224}}, {"id": 225, "text": "Report structure and coherence (maximum 10) 0 2 5 8 10 Score No discernible structure. No presentation of ideas Lacking structure , Few clear ideas presented Writing is mainly clear with some structural issues. Ideas presented with some issues in clarity Fluently written with very few errors. Very minor structural errors. Ideas presented with excellent clarity Lucid presentation high clari ty.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 215, "total_chunks": 224}}, {"id": 226, "text": "Ideas presented with excellent clarity Lucid presentation high clari ty. No structural errors. Ideas presented with exceptional clarity 8. Readability, grammar and spelling (maximum 10) 0 2 5 8 10 Score Very difficult to follow. Many grammar/ spelling er rors. Argument difficult to follow. Patchy presentation, frequent errors in formatting compromising meaning and readability.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 216, "total_chunks": 224}}, {"id": 227, "text": "Patchy presentation, frequent errors in formatting compromising meaning and readability. Poor spelling and gram mar. Satisfactory presentation, minor errors in spelling/ grammar and formatting, but text conveys meaning. High standard of production, infrequent production errors, clear and labelled diagrams. Very minor grammar/spelling errors.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 217, "total_chunks": 224}}, {"id": 228, "text": "Very minor grammar/spelling errors. Outstanding standard of production, report set out in clear and attractive format. No grammar/ spelling l errors. TOTAL SCORE Please note, the Interim Progress Report is worth 5% of the overall assessment for the module.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 218, "total_chunks": 224}}, {"id": 229, "text": "TOTAL SCORE Please note, the Interim Progress Report is worth 5% of the overall assessment for the module.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 219, "total_chunks": 224}}, {"id": 230, "text": "Marker\u2019s c omments MSc Project Handbook 28 Appendix D: Sample - Final Project Report (FPR) Marking Sheet MSc Project Handbook 29 Appendix E: MSc Project Journey Template School of Physics, Engineering and Computer Science Don\u2019t forget to upload your project journey on Canvas after your meeting!", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 220, "total_chunks": 224}}, {"id": 231, "text": "MSc Project Journey Project title: Student\u2019s name: Date of Meeting: (MM/DD/YYYY) Supervisor\u2019s name Location: (on campus/ online) 1. Meeting objective 2. Preparation (reading material, completed work etc.) Description School of Physics, Engineering and Computer Science Don\u2019t forget to upload your project journey on Canvas after your meeting! 3. Action Items for next meeting Action Due Date 5.", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 221, "total_chunks": 224}}, {"id": 232, "text": "Action Items for next meeting Action Due Date 5. Planned next meeting Date: (MM/DD/YYYY) Time: Location:", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 222, "total_chunks": 224}}, {"id": 233, "text": "Planned next meeting Date: (MM/DD/YYYY) Time: Location:", "metadata": {"filename": "MScProject_Handbook v9.2.pdf", "chunk_index": 223, "total_chunks": 224}}, {"id": 234, "text": "AntonX 1SUBMITTED BY ANTONX PROPOSAL #2022-144 SMARTEX MOBILE APP DEVELOPMENTPROPOSAL: 2022-144 CLIENT NAME : SmartEx ATTENTION: Manze DATE ISSUED: November 22, 2022 SUBMITTED BY: Atif Ur Rahman PHONE NUMBER : +92 308 844 3144 EMAIL ADDRESS: atif@antonx.com WEBSITE: www.antonx.comThis document is a proposed solution to the needs of our client.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 0, "total_chunks": 43}}, {"id": 235, "text": "It details the rec - ommended services and deliverables nec - essary to satisfy the client\u2019s objectives for this engagement. Following approval of this proposed engagement, we will create a Statement of Work (SOW) which will act as a formal agreement between the client and our agency.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 1, "total_chunks": 43}}, {"id": 236, "text": "Following approval of this proposed engagement, we will create a Statement of Work (SOW) which will act as a formal agreement between the client and our agency.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 2, "total_chunks": 43}}, {"id": 237, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 2ANTONX (PRIVATE) LIMITED SMARTEX OBJECTIVES Gone are the days of needing a Swedish BankID to take full advantage of all that Swe - den has to offer - with SmartEx, you can access a whole range of mobile banking ser - vices without ever having to set foot in a bank.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 3, "total_chunks": 43}}, {"id": 238, "text": "Not only does this make life easier for immigrants and seniors, but it also opens up a world of possibilities for anyone who doesn\u2019t have a Swedish BankID. With SmartEx, you can buy cards and redeem them in your mobile account, pay your utility bills, and even submit requests to the team to make payments on your behalf.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 4, "total_chunks": 43}}, {"id": 239, "text": "With SmartEx, you can buy cards and redeem them in your mobile account, pay your utility bills, and even submit requests to the team to make payments on your behalf. In the future, this process will be automated, making it even easier to take care of your finances without ever having to visit a bank.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 5, "total_chunks": 43}}, {"id": 240, "text": "In the future, this process will be automated, making it even easier to take care of your finances without ever having to visit a bank. To create a user-friendly customer app, and vendor\u2019s portal.To create a dashboard for the team to see and fulfill requests.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 6, "total_chunks": 43}}, {"id": 241, "text": "To create a user-friendly customer app, and vendor\u2019s portal.To create a dashboard for the team to see and fulfill requests. SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED3MOBILE APP DESIGN & DEVELOPMENT PHASES We will do a competitve analysis to understand the strengths and weaknesses of the competitors and move on to high-fidelity de - sign.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 7, "total_chunks": 43}}, {"id": 242, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED3MOBILE APP DESIGN & DEVELOPMENT PHASES We will do a competitve analysis to understand the strengths and weaknesses of the competitors and move on to high-fidelity de - sign.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 8, "total_chunks": 43}}, {"id": 243, "text": "That\u2019s why, we be - gin our development process by analysing existing applications. This allows us to see what features are already out there, and identify any potential areas that we can improve upon. It also helps us understand how users interact with similar applications, so that we can design in an effecient manner.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 9, "total_chunks": 43}}, {"id": 244, "text": "It also helps us understand how users interact with similar applications, so that we can design in an effecient manner. INCLUDED IN THIS ENGAGEMENT Analysing the FinTech space in Sweden, identifying competi - tors and understanding their strengths and weaknesses.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 10, "total_chunks": 43}}, {"id": 245, "text": "INCLUDED IN THIS ENGAGEMENT Analysing the FinTech space in Sweden, identifying competi - tors and understanding their strengths and weaknesses. SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED5PHASE 01 (contd.) USER INTERFACE & EXPERIENCE DESIGN WIREFRAMES Creating wireframes for an app is essential for a smooth design process.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 11, "total_chunks": 43}}, {"id": 246, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED5PHASE 01 (contd.) USER INTERFACE & EXPERIENCE DESIGN WIREFRAMES Creating wireframes for an app is essential for a smooth design process. Wireframes help define the layout of the app and also provide a blueprint for the design team.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 12, "total_chunks": 43}}, {"id": 247, "text": "Wireframes help define the layout of the app and also provide a blueprint for the design team. The process is typically divided into three steps: First, we identify the key screens based on the features of the app; second, we sketch out the layout for each screen; and third, we refine the sketches into formal wire - frames.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 13, "total_chunks": 43}}, {"id": 248, "text": "The process is typically divided into three steps: First, we identify the key screens based on the features of the app; second, we sketch out the layout for each screen; and third, we refine the sketches into formal wire - frames.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 14, "total_chunks": 43}}, {"id": 249, "text": "INCLUDED IN THIS ENGAGEMENT Wireframes for the design (internal use only) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED6PHASE 01 (contd.) USER INTERFACE & EXPERIENCE DESIGN HIGH-FI DESIGN & REVISIONS High-fidelity designs take the wireframes and flesh them out with visual elements. This is where you start to see the design come to life with colors, fonts and images.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 15, "total_chunks": 43}}, {"id": 250, "text": "This is where you start to see the design come to life with colors, fonts and images. Once the design is ready, we will send it over to you for a review, then based on your com - ments, we will revise the designs. It typically takes 1-3 rounds of revisions before we move on to the next phase.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 16, "total_chunks": 43}}, {"id": 251, "text": "It typically takes 1-3 rounds of revisions before we move on to the next phase. INCLUDED IN THIS ENGAGEMENT Complete UI design (finalised through 1-3 revisions) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED7PHASE 02 FRONT-END DEVELOPMENT FLUTTER DEV After we have the design of our app finalised, we will start build - ing the front-end using Flutter.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 17, "total_chunks": 43}}, {"id": 252, "text": "INCLUDED IN THIS ENGAGEMENT Complete UI design (finalised through 1-3 revisions) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED7PHASE 02 FRONT-END DEVELOPMENT FLUTTER DEV After we have the design of our app finalised, we will start build - ing the front-end using Flutter. Flutter is a mobile app SDK that allows us to create high-quality apps for iOS and Android.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 18, "total_chunks": 43}}, {"id": 253, "text": "Flutter is a mobile app SDK that allows us to create high-quality apps for iOS and Android. With Flutter, we will be able to create a fast and responsive user interface that looks great on all devices. As we continue to build the app, we will take advantage of all that Flutter has to offer in order to create a truly amazing experience for the users.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 19, "total_chunks": 43}}, {"id": 254, "text": "As we continue to build the app, we will take advantage of all that Flutter has to offer in order to create a truly amazing experience for the users. INCLUDED IN THIS ENGAGEMENT Coded interface (.apk & .ipa) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED8PHASE 03 BACK-END DEVELOPMENT NODE.JS Back-end is what happens behind the scenes to make your ap - plication work.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 20, "total_chunks": 43}}, {"id": 255, "text": "INCLUDED IN THIS ENGAGEMENT Coded interface (.apk & .ipa) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED8PHASE 03 BACK-END DEVELOPMENT NODE.JS Back-end is what happens behind the scenes to make your ap - plication work. While there are many back-end technologies, our favourites are Laravel and Node.js. In this phase, we will create a database.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 21, "total_chunks": 43}}, {"id": 256, "text": "In this phase, we will create a database. This will store all the in - formation that we need to keep track of, such as user accounts, carts, wishlists etc. Next, we will write the code to connect the front-end and back-end. This code will allow us to retrieve the data from the backend and display it on the front-end.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 22, "total_chunks": 43}}, {"id": 257, "text": "This code will allow us to retrieve the data from the backend and display it on the front-end. INCLUDED IN THIS ENGAGEMENT Database design (ERD) and APIs development SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED9PHASE 04 API DEVELOPMENT INTEGRATION & TESTING Application Programing Interfaces or APIs are like the glue that holds different parts of a software together.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 23, "total_chunks": 43}}, {"id": 258, "text": "INCLUDED IN THIS ENGAGEMENT Database design (ERD) and APIs development SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED9PHASE 04 API DEVELOPMENT INTEGRATION & TESTING Application Programing Interfaces or APIs are like the glue that holds different parts of a software together.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 24, "total_chunks": 43}}, {"id": 259, "text": "They provide a way for different parts of the software to communicate with each other, exchange data and perform various tasks. In this phase, we will integrate the APIs with the front-end, and also test them to ensure seamless communication.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 25, "total_chunks": 43}}, {"id": 260, "text": "In this phase, we will integrate the APIs with the front-end, and also test them to ensure seamless communication. INCLUDED IN THIS ENGAGEMENT APIs integration with the front-end SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED10PHASE 05 QA TESTING & DEPLOYMENT BUG-FIXES Once the APIs have been integrated successfully, it\u2019s time for Quality Assurance testing.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 26, "total_chunks": 43}}, {"id": 261, "text": "INCLUDED IN THIS ENGAGEMENT APIs integration with the front-end SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED10PHASE 05 QA TESTING & DEPLOYMENT BUG-FIXES Once the APIs have been integrated successfully, it\u2019s time for Quality Assurance testing. This is when we put the app through its paces and make sure it meets all the requirements.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 27, "total_chunks": 43}}, {"id": 262, "text": "This is when we put the app through its paces and make sure it meets all the requirements. Once the QA is complete, we will deploy the app.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 28, "total_chunks": 43}}, {"id": 263, "text": "Once the QA is complete, we will deploy the app. INCLUDED IN THIS ENGAGEMENT Identifying bugs and fixing them SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED11PHASE 05 (contd.) QA TESTING & DEPLOYMENT DEPLOYMENT Deployment is the process of making an app live and accessible to users.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 29, "total_chunks": 43}}, {"id": 264, "text": "INCLUDED IN THIS ENGAGEMENT Identifying bugs and fixing them SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED11PHASE 05 (contd.) QA TESTING & DEPLOYMENT DEPLOYMENT Deployment is the process of making an app live and accessible to users. It involves uploading the app to a server (Google Play/ App Store) and making it available online.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 30, "total_chunks": 43}}, {"id": 265, "text": "It involves uploading the app to a server (Google Play/ App Store) and making it available online. After deployment, users can download the application. INCLUDED IN THIS ENGAGEMENT Deployment on Google Play and App Store SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED12 OPTIONAL BRANDING Additionally, we provide branding services if needed.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 31, "total_chunks": 43}}, {"id": 266, "text": "INCLUDED IN THIS ENGAGEMENT Deployment on Google Play and App Store SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED12 OPTIONAL BRANDING Additionally, we provide branding services if needed. The services will be priced separately.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 32, "total_chunks": 43}}, {"id": 267, "text": "The services will be priced separately. INCLUDED IN THIS ENGAGEMENT Name, Logo & Style Guide SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED13 PROJECT MANAGEMENT Our projects are managed on JIRA to ensure total trans - parency throughout the execution of the project. Both AntonX and client team members will have access to the project on the JIRA board.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 33, "total_chunks": 43}}, {"id": 268, "text": "Both AntonX and client team members will have access to the project on the JIRA board. Our goal is to provide full visi - bility on the project 24/7.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 34, "total_chunks": 43}}, {"id": 269, "text": "Our goal is to provide full visi - bility on the project 24/7.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 35, "total_chunks": 43}}, {"id": 270, "text": "The estimated timelines provided in this document are based upon an assumption that the client will provide feedback and approvals within one day of AntonX\u2019s delivery milestones.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 36, "total_chunks": 43}}, {"id": 271, "text": "ESTIMATED PROJECT COMPLETION DATE MARCH 30, 2023 - APRIL 30, 2023 If the project is not completed within 30 days of the Estimated Project Completion Date due to client delays in providing feedback, assets, approvals, content, direction, and so forth, we reserve the right to discuss and submit a change order to accommodate unfore - seen expenses due to the unplanned extension of the project.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 37, "total_chunks": 43}}, {"id": 272, "text": "* A FinTech app requires a robust security system, hence a security audit will be essen - tial before launching the app to the public. SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED15ESTIMATED PROJECT BUDGET The details and costs associated with this proposal are valid for 60 days from the docu - ment date.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 38, "total_chunks": 43}}, {"id": 273, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED15ESTIMATED PROJECT BUDGET The details and costs associated with this proposal are valid for 60 days from the docu - ment date. This represents a \u201cpackage price.\u201d If elements are added to or removed from the scope of the project, the pricing for other elements may be affected.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 39, "total_chunks": 43}}, {"id": 274, "text": "This represents a \u201cpackage price.\u201d If elements are added to or removed from the scope of the project, the pricing for other elements may be affected.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 40, "total_chunks": 43}}, {"id": 275, "text": "NEXT STEPS STATEMENT OF WORK (SOW) We would be delighted to work with you to satisfy the IT needs of your business. Each engagement with our agency includes a detailed statement of work which defines our services in detail. The statement of work will act as a formal agreement between both our agency and you, as our client.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 41, "total_chunks": 43}}, {"id": 276, "text": "The statement of work will act as a formal agreement between both our agency and you, as our client.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 42, "total_chunks": 43}}, {"id": 277, "text": "AntonX 1SUBMITTED BY ANTONX PROPOSAL #2022-144 SMARTEX MOBILE APP DEVELOPMENTPROPOSAL: 2022-144 CLIENT NAME : SmartEx ATTENTION: Manze DATE ISSUED: November 22, 2022 SUBMITTED BY: Atif Ur Rahman PHONE NUMBER : +92 308 844 3144 EMAIL ADDRESS: atif@antonx.com WEBSITE: www.antonx.comThis document is a proposed solution to the needs of our client.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 0, "total_chunks": 43}}, {"id": 278, "text": "It details the rec - ommended services and deliverables nec - essary to satisfy the client\u2019s objectives for this engagement. Following approval of this proposed engagement, we will create a Statement of Work (SOW) which will act as a formal agreement between the client and our agency.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 1, "total_chunks": 43}}, {"id": 279, "text": "Following approval of this proposed engagement, we will create a Statement of Work (SOW) which will act as a formal agreement between the client and our agency.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 2, "total_chunks": 43}}, {"id": 280, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 2ANTONX (PRIVATE) LIMITED SMARTEX OBJECTIVES Gone are the days of needing a Swedish BankID to take full advantage of all that Swe - den has to offer - with SmartEx, you can access a whole range of mobile banking ser - vices without ever having to set foot in a bank.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 3, "total_chunks": 43}}, {"id": 281, "text": "Not only does this make life easier for immigrants and seniors, but it also opens up a world of possibilities for anyone who doesn\u2019t have a Swedish BankID. With SmartEx, you can buy cards and redeem them in your mobile account, pay your utility bills, and even submit requests to the team to make payments on your behalf.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 4, "total_chunks": 43}}, {"id": 282, "text": "With SmartEx, you can buy cards and redeem them in your mobile account, pay your utility bills, and even submit requests to the team to make payments on your behalf. In the future, this process will be automated, making it even easier to take care of your finances without ever having to visit a bank.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 5, "total_chunks": 43}}, {"id": 283, "text": "In the future, this process will be automated, making it even easier to take care of your finances without ever having to visit a bank. To create a user-friendly customer app, and vendor\u2019s portal.To create a dashboard for the team to see and fulfill requests.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 6, "total_chunks": 43}}, {"id": 284, "text": "To create a user-friendly customer app, and vendor\u2019s portal.To create a dashboard for the team to see and fulfill requests. SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED3MOBILE APP DESIGN & DEVELOPMENT PHASES We will do a competitve analysis to understand the strengths and weaknesses of the competitors and move on to high-fidelity de - sign.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 7, "total_chunks": 43}}, {"id": 285, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED3MOBILE APP DESIGN & DEVELOPMENT PHASES We will do a competitve analysis to understand the strengths and weaknesses of the competitors and move on to high-fidelity de - sign.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 8, "total_chunks": 43}}, {"id": 286, "text": "That\u2019s why, we be - gin our development process by analysing existing applications. This allows us to see what features are already out there, and identify any potential areas that we can improve upon. It also helps us understand how users interact with similar applications, so that we can design in an effecient manner.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 9, "total_chunks": 43}}, {"id": 287, "text": "It also helps us understand how users interact with similar applications, so that we can design in an effecient manner. INCLUDED IN THIS ENGAGEMENT Analysing the FinTech space in Sweden, identifying competi - tors and understanding their strengths and weaknesses.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 10, "total_chunks": 43}}, {"id": 288, "text": "INCLUDED IN THIS ENGAGEMENT Analysing the FinTech space in Sweden, identifying competi - tors and understanding their strengths and weaknesses. SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED5PHASE 01 (contd.) USER INTERFACE & EXPERIENCE DESIGN WIREFRAMES Creating wireframes for an app is essential for a smooth design process.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 11, "total_chunks": 43}}, {"id": 289, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED5PHASE 01 (contd.) USER INTERFACE & EXPERIENCE DESIGN WIREFRAMES Creating wireframes for an app is essential for a smooth design process. Wireframes help define the layout of the app and also provide a blueprint for the design team.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 12, "total_chunks": 43}}, {"id": 290, "text": "Wireframes help define the layout of the app and also provide a blueprint for the design team. The process is typically divided into three steps: First, we identify the key screens based on the features of the app; second, we sketch out the layout for each screen; and third, we refine the sketches into formal wire - frames.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 13, "total_chunks": 43}}, {"id": 291, "text": "The process is typically divided into three steps: First, we identify the key screens based on the features of the app; second, we sketch out the layout for each screen; and third, we refine the sketches into formal wire - frames.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 14, "total_chunks": 43}}, {"id": 292, "text": "INCLUDED IN THIS ENGAGEMENT Wireframes for the design (internal use only) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED6PHASE 01 (contd.) USER INTERFACE & EXPERIENCE DESIGN HIGH-FI DESIGN & REVISIONS High-fidelity designs take the wireframes and flesh them out with visual elements. This is where you start to see the design come to life with colors, fonts and images.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 15, "total_chunks": 43}}, {"id": 293, "text": "This is where you start to see the design come to life with colors, fonts and images. Once the design is ready, we will send it over to you for a review, then based on your com - ments, we will revise the designs. It typically takes 1-3 rounds of revisions before we move on to the next phase.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 16, "total_chunks": 43}}, {"id": 294, "text": "It typically takes 1-3 rounds of revisions before we move on to the next phase. INCLUDED IN THIS ENGAGEMENT Complete UI design (finalised through 1-3 revisions) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED7PHASE 02 FRONT-END DEVELOPMENT FLUTTER DEV After we have the design of our app finalised, we will start build - ing the front-end using Flutter.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 17, "total_chunks": 43}}, {"id": 295, "text": "INCLUDED IN THIS ENGAGEMENT Complete UI design (finalised through 1-3 revisions) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED7PHASE 02 FRONT-END DEVELOPMENT FLUTTER DEV After we have the design of our app finalised, we will start build - ing the front-end using Flutter. Flutter is a mobile app SDK that allows us to create high-quality apps for iOS and Android.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 18, "total_chunks": 43}}, {"id": 296, "text": "Flutter is a mobile app SDK that allows us to create high-quality apps for iOS and Android. With Flutter, we will be able to create a fast and responsive user interface that looks great on all devices. As we continue to build the app, we will take advantage of all that Flutter has to offer in order to create a truly amazing experience for the users.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 19, "total_chunks": 43}}, {"id": 297, "text": "As we continue to build the app, we will take advantage of all that Flutter has to offer in order to create a truly amazing experience for the users. INCLUDED IN THIS ENGAGEMENT Coded interface (.apk & .ipa) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED8PHASE 03 BACK-END DEVELOPMENT NODE.JS Back-end is what happens behind the scenes to make your ap - plication work.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 20, "total_chunks": 43}}, {"id": 298, "text": "INCLUDED IN THIS ENGAGEMENT Coded interface (.apk & .ipa) SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED8PHASE 03 BACK-END DEVELOPMENT NODE.JS Back-end is what happens behind the scenes to make your ap - plication work. While there are many back-end technologies, our favourites are Laravel and Node.js. In this phase, we will create a database.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 21, "total_chunks": 43}}, {"id": 299, "text": "In this phase, we will create a database. This will store all the in - formation that we need to keep track of, such as user accounts, carts, wishlists etc. Next, we will write the code to connect the front-end and back-end. This code will allow us to retrieve the data from the backend and display it on the front-end.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 22, "total_chunks": 43}}, {"id": 300, "text": "This code will allow us to retrieve the data from the backend and display it on the front-end. INCLUDED IN THIS ENGAGEMENT Database design (ERD) and APIs development SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED9PHASE 04 API DEVELOPMENT INTEGRATION & TESTING Application Programing Interfaces or APIs are like the glue that holds different parts of a software together.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 23, "total_chunks": 43}}, {"id": 301, "text": "INCLUDED IN THIS ENGAGEMENT Database design (ERD) and APIs development SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED9PHASE 04 API DEVELOPMENT INTEGRATION & TESTING Application Programing Interfaces or APIs are like the glue that holds different parts of a software together.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 24, "total_chunks": 43}}, {"id": 302, "text": "They provide a way for different parts of the software to communicate with each other, exchange data and perform various tasks. In this phase, we will integrate the APIs with the front-end, and also test them to ensure seamless communication.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 25, "total_chunks": 43}}, {"id": 303, "text": "In this phase, we will integrate the APIs with the front-end, and also test them to ensure seamless communication. INCLUDED IN THIS ENGAGEMENT APIs integration with the front-end SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED10PHASE 05 QA TESTING & DEPLOYMENT BUG-FIXES Once the APIs have been integrated successfully, it\u2019s time for Quality Assurance testing.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 26, "total_chunks": 43}}, {"id": 304, "text": "INCLUDED IN THIS ENGAGEMENT APIs integration with the front-end SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED10PHASE 05 QA TESTING & DEPLOYMENT BUG-FIXES Once the APIs have been integrated successfully, it\u2019s time for Quality Assurance testing. This is when we put the app through its paces and make sure it meets all the requirements.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 27, "total_chunks": 43}}, {"id": 305, "text": "This is when we put the app through its paces and make sure it meets all the requirements. Once the QA is complete, we will deploy the app.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 28, "total_chunks": 43}}, {"id": 306, "text": "Once the QA is complete, we will deploy the app. INCLUDED IN THIS ENGAGEMENT Identifying bugs and fixing them SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED11PHASE 05 (contd.) QA TESTING & DEPLOYMENT DEPLOYMENT Deployment is the process of making an app live and accessible to users.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 29, "total_chunks": 43}}, {"id": 307, "text": "INCLUDED IN THIS ENGAGEMENT Identifying bugs and fixing them SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED11PHASE 05 (contd.) QA TESTING & DEPLOYMENT DEPLOYMENT Deployment is the process of making an app live and accessible to users. It involves uploading the app to a server (Google Play/ App Store) and making it available online.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 30, "total_chunks": 43}}, {"id": 308, "text": "It involves uploading the app to a server (Google Play/ App Store) and making it available online. After deployment, users can download the application. INCLUDED IN THIS ENGAGEMENT Deployment on Google Play and App Store SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED12 OPTIONAL BRANDING Additionally, we provide branding services if needed.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 31, "total_chunks": 43}}, {"id": 309, "text": "INCLUDED IN THIS ENGAGEMENT Deployment on Google Play and App Store SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED12 OPTIONAL BRANDING Additionally, we provide branding services if needed. The services will be priced separately.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 32, "total_chunks": 43}}, {"id": 310, "text": "The services will be priced separately. INCLUDED IN THIS ENGAGEMENT Name, Logo & Style Guide SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED13 PROJECT MANAGEMENT Our projects are managed on JIRA to ensure total trans - parency throughout the execution of the project. Both AntonX and client team members will have access to the project on the JIRA board.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 33, "total_chunks": 43}}, {"id": 311, "text": "Both AntonX and client team members will have access to the project on the JIRA board. Our goal is to provide full visi - bility on the project 24/7.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 34, "total_chunks": 43}}, {"id": 312, "text": "Our goal is to provide full visi - bility on the project 24/7.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 35, "total_chunks": 43}}, {"id": 313, "text": "The estimated timelines provided in this document are based upon an assumption that the client will provide feedback and approvals within one day of AntonX\u2019s delivery milestones.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 36, "total_chunks": 43}}, {"id": 314, "text": "ESTIMATED PROJECT COMPLETION DATE MARCH 30, 2023 - APRIL 30, 2023 If the project is not completed within 30 days of the Estimated Project Completion Date due to client delays in providing feedback, assets, approvals, content, direction, and so forth, we reserve the right to discuss and submit a change order to accommodate unfore - seen expenses due to the unplanned extension of the project.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 37, "total_chunks": 43}}, {"id": 315, "text": "* A FinTech app requires a robust security system, hence a security audit will be essen - tial before launching the app to the public. SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED15ESTIMATED PROJECT BUDGET The details and costs associated with this proposal are valid for 60 days from the docu - ment date.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 38, "total_chunks": 43}}, {"id": 316, "text": "SMARTEX MOBILE APP DESGN & DEVELOPMENT // 2022-144 ANTONX (PRIVATE) LIMITED15ESTIMATED PROJECT BUDGET The details and costs associated with this proposal are valid for 60 days from the docu - ment date. This represents a \u201cpackage price.\u201d If elements are added to or removed from the scope of the project, the pricing for other elements may be affected.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 39, "total_chunks": 43}}, {"id": 317, "text": "This represents a \u201cpackage price.\u201d If elements are added to or removed from the scope of the project, the pricing for other elements may be affected.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 40, "total_chunks": 43}}, {"id": 318, "text": "NEXT STEPS STATEMENT OF WORK (SOW) We would be delighted to work with you to satisfy the IT needs of your business. Each engagement with our agency includes a detailed statement of work which defines our services in detail. The statement of work will act as a formal agreement between both our agency and you, as our client.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 41, "total_chunks": 43}}, {"id": 319, "text": "The statement of work will act as a formal agreement between both our agency and you, as our client.", "metadata": {"filename": "2022-144 SmartEx.pdf", "chunk_index": 42, "total_chunks": 43}}, {"id": 320, "text": "DEPARTMENT OF COMPUTER SCIENCE & INFORMATION TECHNOLOGY UNIVERSITY OF ENGINEERING & TECHNOLOGY, PESHAWAR Lab Manual BS(CS) Spring 2025 Artificial Intelligence Subject: Artificial Intelligence (Lab) Code: CS- 401 (L) Instructor: Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 0, "total_chunks": 193}}, {"id": 321, "text": "Wajeeha Khalil Session: 2025 Semester (S/F): 6th (Spring) Lab Week # 01 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 01: Implement Breadth-First Search BFS using Python Introduction Breadth-First Search (BFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 1, "total_chunks": 193}}, {"id": 322, "text": "It operates by visiting all nodes in a graph level by level, starting from a designated source node.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 2, "total_chunks": 193}}, {"id": 323, "text": "Learn how to represent problem domains and states for BFS-based intelligent agents. Gain proficiency in implementing BFS algorithm to explore state spaces efficiently. Develop problem-solving skills by applying BFS to various scenarios and domains in AI.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 3, "total_chunks": 193}}, {"id": 324, "text": "Develop problem-solving skills by applying BFS to various scenarios and domains in AI. Appreciate the importance of search algorithms in building intelligent agents capable of navigating complex environments and achieving desired goals.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 4, "total_chunks": 193}}, {"id": 325, "text": "Appreciate the importance of search algorithms in building intelligent agents capable of navigating complex environments and achieving desired goals. Steps: Algorithm: Breadth-First Search (BFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 5, "total_chunks": 193}}, {"id": 326, "text": "Steps: Algorithm: Breadth-First Search (BFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 6, "total_chunks": 193}}, {"id": 327, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Dequeue a state current_state from the frontier. If current_state is the goal state, return the path to current_state. Add current_state to the explored set.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 7, "total_chunks": 193}}, {"id": 328, "text": "Add current_state to the explored set. For each action a in the set of legal actions applicable to current_state: Calculate the successor state next_state by applying action a to current_state. If next_state is not in frontier or explored: Enqueue next_state onto the frontier. Set the parent of next_state to current_state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 8, "total_chunks": 193}}, {"id": 329, "text": "Set the parent of next_state to current_state. Termination: If the frontier becomes empty without finding the goal state, return failure. Explanation: The algorithm starts by initializing a queue (frontier) to store states to be explored and a set (explored) to keep track of visited states. It continues to dequeue states from the frontier and explores their successors by applying legal actions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 9, "total_chunks": 193}}, {"id": 330, "text": "It continues to dequeue states from the frontier and explores their successors by applying legal actions. If a successor state has not been visited before, it is enqueued onto the frontier. The algorithm terminates either when the goal state is found or when the frontier becomes empty.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 10, "total_chunks": 193}}, {"id": 331, "text": "The algorithm terminates either when the goal state is found or when the frontier becomes empty. If the goal state is found, the algorithm backtracks from the goal state to the initial state using parent pointers to construct the solution path. Note: Refer to the generalized Algorithm studied in theory class for more understanding.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 11, "total_chunks": 193}}, {"id": 332, "text": "Note: Refer to the generalized Algorithm studied in theory class for more understanding. Task Implement the above algorithm in Python for the following problem where 12 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 12, "total_chunks": 193}}, {"id": 333, "text": "Task Implement the above algorithm in Python for the following problem where 12 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 13, "total_chunks": 193}}, {"id": 334, "text": "Solution: Importing Required Libraries: Networkx: Library used for the graph creation Matplotlib: Library used for plotting the graph dequeue: A queue from collection library for visiting the nodes Breadth First Search Implementation Part: The BFS algorithm is implemented using a queue (FIFO structure). It explores the graph level by level before moving deeper.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 14, "total_chunks": 193}}, {"id": 335, "text": "It explores the graph level by level before moving deeper.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 15, "total_chunks": 193}}, {"id": 336, "text": "Unlike BFS, which explores nodes level by level, DFS explores as far as possible along each branch before backtracking.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 16, "total_chunks": 193}}, {"id": 337, "text": "DFS is widely employed in AI applications such as: Pathfinding State space exploration Solving Puzzle and Mazes By traversing the graph depth-wise, DFS is particularly useful for exploring all possible paths in a graph, making it ideal for problems like cycle detection, topological sorting, and solving constraint satisfaction problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 17, "total_chunks": 193}}, {"id": 338, "text": "Learning Objectives Understand the steps involved in Depth-First Search for solving AI problems. Learn how to represent problem domains and states for DFS-based intelligent agents. Gain proficiency in implementing the DFS algorithm to explore state spaces efficiently. Develop problem-solving skills by applying DFS to various AI scenarios.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 18, "total_chunks": 193}}, {"id": 339, "text": "Develop problem-solving skills by applying DFS to various AI scenarios. Appreciate the importance of search algorithms in building intelligent agents. Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 19, "total_chunks": 193}}, {"id": 340, "text": "Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 20, "total_chunks": 193}}, {"id": 341, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Pop a node (current_node) from the frontier. If current_node is the goal node, return the path to current_node. Add current_node to the explored set.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 21, "total_chunks": 193}}, {"id": 342, "text": "Add current_node to the explored set. For each neighbor of current_node: If the neighbor is not in frontier or explored: Push the neighbor onto the frontier. Set the parent of the neighbor to current_node. Termination: If the frontier becomes empty without finding the goal node, return failure.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 22, "total_chunks": 193}}, {"id": 343, "text": "Termination: If the frontier becomes empty without finding the goal node, return failure. Explanation: break down the provided Breadth-First Search (BFS) algorithm for intelligent agents step by step: Initialization: We start by initializing a queue named frontier to keep track of states to be explored. We enqueue the initial state onto the frontier.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 23, "total_chunks": 193}}, {"id": 344, "text": "We enqueue the initial state onto the frontier. An empty set explored is created to store visited states. Main Loop: We enter a loop that continues until the frontier is not empty. Within each iteration of the loop: We dequeue a state current_state from the frontier. We check if current_state is the goal state by calling the Problem.goal_test(current_state) function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 24, "total_chunks": 193}}, {"id": 345, "text": "We check if current_state is the goal state by calling the Problem.goal_test(current_state) function. If it is, we return the path to this state. If current_state is not the goal state, we mark it as explored by adding it to the explored set. We iterate over all applicable actions for the current_state by calling Problem.actions(current_state).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 25, "total_chunks": 193}}, {"id": 346, "text": "We iterate over all applicable actions for the current_state by calling Problem.actions(current_state). For each action: We calculate the successor state next_state by applying the action to the current_state using the Problem.result(current_state, action) function. If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 26, "total_chunks": 193}}, {"id": 347, "text": "If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier. We set the parent of next_state to current_state. This step is crucial for reconstructing the path once the goal state is found.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 27, "total_chunks": 193}}, {"id": 348, "text": "This step is crucial for reconstructing the path once the goal state is found. Termination: If the frontier becomes empty without finding the goal state, we return failure, indicating that the goal state is unreachable from the initial state. Output: If the goal state is found during the search, we return the path from the initial state to the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 28, "total_chunks": 193}}, {"id": 349, "text": "Output: If the goal state is found during the search, we return the path from the initial state to the goal state. This path can be constructed by following the parent pointers from the goal state back to the initial state. Note: Refer to the generalized Algorithm studied in theory class for more understanding.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 29, "total_chunks": 193}}, {"id": 350, "text": "Note: Refer to the generalized Algorithm studied in theory class for more understanding. Task Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 30, "total_chunks": 193}}, {"id": 351, "text": "Task Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 31, "total_chunks": 193}}, {"id": 352, "text": "In this puzzle: A man wants to cross a river with three items: a wolf, a chicken, and a corn. The boat can carry a maximum of two entities (the man plus one item). Constraints: If the wolf and chicken are left alone without the man, the wolf will eat the chicken. If the chicken and corn are left alone without the man, the chicken will eat the corn.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 32, "total_chunks": 193}}, {"id": 353, "text": "If the chicken and corn are left alone without the man, the chicken will eat the corn. Your task is to help the man safely transport all items to the other side of the river without violating the constraints. Learning Objectives Understand the concept of state-space search in AI. Apply logical reasoning to solve constraint-based problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 33, "total_chunks": 193}}, {"id": 354, "text": "Apply logical reasoning to solve constraint-based problems. Implement a search algorithm (e.g., BFS or DFS) to find a valid sequence of moves. Develop problem-solving skills by exploring possible states and transitions. Problem Setup Entities: Man, Wolf, Chicken, Corn. Boat Capacity: Maximum of 2 (Man + 1 item). Constraints: Wolf cannot be left alone with Chicken.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 34, "total_chunks": 193}}, {"id": 355, "text": "Constraints: Wolf cannot be left alone with Chicken. Chicken cannot be left alone with Corn. State Representation Each state can be represented as a tuple: (Man, Wolf, Chicken, Corn) Man: Left or Right (side of the river). Wolf, Chicken, Corn: Left or Right (side of the river).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 35, "total_chunks": 193}}, {"id": 356, "text": "Wolf, Chicken, Corn: Left or Right (side of the river). Example: Initial State: ('Left', 'Left', 'Left', 'Left') Goal State: ('Right', 'Right', 'Right', 'Right') Task State-Space Search: Represent the problem as a state-space graph. Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 36, "total_chunks": 193}}, {"id": 357, "text": "Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions. Find a Valid Sequence: Find a sequence of moves that transports all items to the right side of the river without violating the constraints. Implement the Solution: Write a Python program to solve the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 37, "total_chunks": 193}}, {"id": 358, "text": "Implement the Solution: Write a Python program to solve the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 38, "total_chunks": 193}}, {"id": 359, "text": "In this implementation, we will focus on the 8-puzzle variant, where the puzzle is divided into a 3x3 grid with eight numbered tiles and one empty space. We'll use the A* search algorithm to efficiently find the shortest path from the initial state to the goal state. Learning Objectives Understand the N-Puzzle problem and its rules. Implement the A* search algorithm in Python.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 39, "total_chunks": 193}}, {"id": 360, "text": "Implement the A* search algorithm in Python. Learn how to represent states, actions, and transitions in the N-Puzzle problem. Gain experience in solving optimization problems using heuristic search techniques. Steps: Algorithm: A* search Input: Receive the initial and goal configurations of the puzzle. Output: Display the steps required to reach the goal state from the initial state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 40, "total_chunks": 193}}, {"id": 361, "text": "Output: Display the steps required to reach the goal state from the initial state. Initialization: Initialize the A* algorithm with the initial state, priority queue, and heuristic function. Main Loop: Iteratively expand nodes based on their estimated cost until the goal state is reached or no more nodes are left to explore.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 41, "total_chunks": 193}}, {"id": 362, "text": "Main Loop: Iteratively expand nodes based on their estimated cost until the goal state is reached or no more nodes are left to explore. Termination: Terminate the algorithm when the goal state is reached or when no solution is found. Explanation: 1. INPUT: Define the problem domain including the initial state and the goal state of the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 42, "total_chunks": 193}}, {"id": 363, "text": "INPUT: Define the problem domain including the initial state and the goal state of the puzzle. Define the actions applicable to each state, the transition model, the goal test, and the cost function. 2. OUTPUT: Return the sequence of actions that lead from the initial state to the goal state. 3. INITIALIZATION: Initialize an empty priority queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 43, "total_chunks": 193}}, {"id": 364, "text": "INITIALIZATION: Initialize an empty priority queue frontier to store states to be explored. Enqueue the initial state onto the frontier with a priority of 0. Initialize an empty set explored to store visited states. 4. MAIN LOOP: While the frontier is not empty: Dequeue a state from the frontier. If the dequeued state is the goal state, return the sequence of actions leading to it.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 44, "total_chunks": 193}}, {"id": 365, "text": "If the dequeued state is the goal state, return the sequence of actions leading to it. Add the dequeued state to the explored set For each action applicable to the current state: Calculate the successor state by applying the action. If the successor state has not been explored or enqueued: Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 45, "total_chunks": 193}}, {"id": 366, "text": "If the successor state has not been explored or enqueued: Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic. Set the parent of the successor state to the current state. 5. TERMINATION: If the frontier becomes empty without finding the goal state, return failure.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 46, "total_chunks": 193}}, {"id": 367, "text": "TERMINATION: If the frontier becomes empty without finding the goal state, return failure. Explanation N-Puzzle or sliding puzzle is a popular puzzle that consists of N tiles where N can be 8, 15, 24 and so on. In our example N = 8. The puzzle is divided into sqrt(N+1) rows and sqrt(N+1) columns. Eg. 15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 47, "total_chunks": 193}}, {"id": 368, "text": "15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns. The puzzle consists of N tiles and one empty space where the tiles can be moved. Start and Goal configurations (also called state) of the puzzle are provided. The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 48, "total_chunks": 193}}, {"id": 369, "text": "The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration. Rules for solving the puzzle. Instead of moving the tiles in the empty space we can visualize moving the empty space in place of the tile, basically swapping the tile with the empty space. The empty space can only move in four directions viz., 1. Up 2.Down 3. Right or 4.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 49, "total_chunks": 193}}, {"id": 370, "text": "Right or 4. Left The empty space cannot move diagonally and can take only one step at a time (i.e. move the empty space one position at a time). The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 50, "total_chunks": 193}}, {"id": 371, "text": "The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state. The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 51, "total_chunks": 193}}, {"id": 372, "text": "The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution. It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 52, "total_chunks": 193}}, {"id": 373, "text": "It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems. A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 53, "total_chunks": 193}}, {"id": 374, "text": "A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search. It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 54, "total_chunks": 193}}, {"id": 375, "text": "It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node. Heuristic Cost (h): An estimated cost from the current node to the goal node (often called the heuristic function). The key to A*'s efficiency lies in its selection of nodes to explore.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 55, "total_chunks": 193}}, {"id": 376, "text": "The key to A*'s efficiency lies in its selection of nodes to explore. At each step, it chooses the node that minimizes the sum of the path cost g and the estimated remaining cost to the goal h (often represented as f = g + h). This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 56, "total_chunks": 193}}, {"id": 377, "text": "This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function. Task Implement the above algorithm in Python for the following problem the N-Puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 57, "total_chunks": 193}}, {"id": 378, "text": "Task Implement the above algorithm in Python for the following problem the N-Puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 58, "total_chunks": 193}}, {"id": 379, "text": "This lab explores solving TSP using the Simulated Annealing (SA) algorithm and analyzing its performance. Learning Objectives: Understand the concept of TSP and heuristic optimization. Implement Simulated Annealing (SA) for solving TSP. Analyze performance metrics such as path length and execution time. Compare SA with other optimization techniques. Algorithm: 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 59, "total_chunks": 193}}, {"id": 380, "text": "Algorithm: 1. Input: A set of cities with random (x, y) coordinates. Distance function (e.g., Euclidean distance) to evaluate the path cost. 2. Output: Optimized path with the shortest distance. Graphical representation of the final tour. 3. Initialization: Generate an initial random tour. Set initial temperature and cooling rate for Simulated Annealing. Define an acceptance probability function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 60, "total_chunks": 193}}, {"id": 381, "text": "Define an acceptance probability function. 4. Main Loop: Iteratively swap cities in the tour to generate a new solution. Evaluate the cost difference between current and new solutions. Accept the new solution based on the probability function. Gradually reduce the temperature until termination conditions are met. 5. Termination: Stop when the temperature reaches a predefined threshold.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 61, "total_chunks": 193}}, {"id": 382, "text": "Termination: Stop when the temperature reaches a predefined threshold. Return the best solution found. Explanation: 1. INPUT: Number of cities (e.g., 20 for initial experiments, extendable to 100). Coordinate values for cities. Initial temperature, cooling rate, and maximum iterations. 2. OUTPUT: Optimized tour with minimal travel cost. Graphical visualization of the tour.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 62, "total_chunks": 193}}, {"id": 383, "text": "Graphical visualization of the tour. Execution time and convergence analysis. 3. INITIALIZATION: Generate a random initial tour. Define temperature and cooling schedule. Set an initial best cost value. 4. MAIN LOOP: Randomly select two cities and swap them. Calculate the new tour\u2019s total distance. Use Simulated Annealing acceptance criteria to decide whether to accept the new solution.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 63, "total_chunks": 193}}, {"id": 384, "text": "Use Simulated Annealing acceptance criteria to decide whether to accept the new solution. Decrease temperature iteratively. 5. TERMINATION: Stop when the temperature reaches near zero or after a fixed number of iterations. Return the best-found solution. Task Implement Simulated Annealing (SA) to solve TSP. Visualize the computed shortest tour.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 64, "total_chunks": 193}}, {"id": 385, "text": "Visualize the computed shortest tour. Analyze performance based on: Path length Execution time Number of iterations Extend the problem to 100 cities and compare results. Implement Tabu Search and evaluate its effectiveness against SA.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 65, "total_chunks": 193}}, {"id": 386, "text": "Implement Tabu Search and evaluate its effectiveness against SA. Code Solution Imported important Libraries Distance Calculation for TSP Total Distance Algorithm for Simulated Annealing Visualization Function Output SA for STP Tabu Search Implementation Visualization Output Comparison Simulated Annealing VS Tabu Search Comparison Table: Simulated Annealing vs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 66, "total_chunks": 193}}, {"id": 387, "text": "Code Solution Imported important Libraries Distance Calculation for TSP Total Distance Algorithm for Simulated Annealing Visualization Function Output SA for STP Tabu Search Implementation Visualization Output Comparison Simulated Annealing VS Tabu Search Comparison Table: Simulated Annealing vs. Tabu Search Short Report: Simulated Annealing vs. Tabu Search 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 67, "total_chunks": 193}}, {"id": 388, "text": "Tabu Search 1. Algorithm Explanation Simulated Annealing (SA): Simulated Annealing is a probabilistic optimization technique inspired by the annealing process in metallurgy. The algorithm starts with a high temperature, which gradually decreases. At each iteration, it explores a new solution by swapping two cities.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 68, "total_chunks": 193}}, {"id": 389, "text": "At each iteration, it explores a new solution by swapping two cities. If the new solution is better, it is accepted; otherwise, it may still be accepted with a probability that decreases over time. This helps avoid local optima and allows exploration of the solution space.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 69, "total_chunks": 193}}, {"id": 390, "text": "This helps avoid local optima and allows exploration of the solution space. Tabu Search (TS): Tabu Search is a local search method that enhances hill-climbing by maintaining a list of recently visited solutions (tabu list) to prevent cycling back to previous solutions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 70, "total_chunks": 193}}, {"id": 391, "text": "Tabu Search (TS): Tabu Search is a local search method that enhances hill-climbing by maintaining a list of recently visited solutions (tabu list) to prevent cycling back to previous solutions. It systematically explores the solution space by swapping cities and tracking the best solutions while avoiding short-term revisits. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 71, "total_chunks": 193}}, {"id": 392, "text": "2. Performance Analysis From the comparison table, we can analyze: Path Length: Simulated Annealing found a shorter path (643.42) compared to Tabu Search (382.94), indicating its better exploration capability. Execution Time: Simulated Annealing took 0.62 seconds, which is shorter than Tabu Search\u2019s 19.27 seconds due to more iterations and its probabilistic nature.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 72, "total_chunks": 193}}, {"id": 393, "text": "Execution Time: Simulated Annealing took 0.62 seconds, which is shorter than Tabu Search\u2019s 19.27 seconds due to more iterations and its probabilistic nature. Number of Iterations: SA runs significantly more iterations than TS, but this helps it avoid local optima and explore more of the solution space. 3. SA vs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 73, "total_chunks": 193}}, {"id": 394, "text": "SA vs. Tabu Search Comparison Lab Week # 06 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 06: Implementation of Genetic Algorithm Introduction The Traveling Salesman Problem (TSP) is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 74, "total_chunks": 193}}, {"id": 395, "text": "Tabu Search Comparison Lab Week # 06 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 06: Implementation of Genetic Algorithm Introduction The Traveling Salesman Problem (TSP) is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 75, "total_chunks": 193}}, {"id": 396, "text": "Genetic Algorithms (GAs) are evolutionary algorithms inspired by natural selection and genetics, commonly used to solve optimization and search problems. Learning Objectives Understand the application of Genetic Algorithms in solving optimization problems like the Traveling Salesman Problem. Learn about Roulette Wheel Selection Method for parent selection in Genetic Algorithms.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 76, "total_chunks": 193}}, {"id": 397, "text": "Learn about Roulette Wheel Selection Method for parent selection in Genetic Algorithms. Implement a basic Genetic Algorithm solution for the Traveling Salesman Problem in Python. Algorithm: Genetic Algorithm Input: A set of cities with their coordinates. Population size. Crossover rate. Mutation rate. Termination condition (e.g., maximum number of generations, convergence criteria).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 77, "total_chunks": 193}}, {"id": 398, "text": "Termination condition (e.g., maximum number of generations, convergence criteria). Output: The best route found (shortest tour) that visits each city exactly once and returns to the original city. Initialization: Create Initial Population: Generate an initial population of candidate solutions (chromosomes).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 78, "total_chunks": 193}}, {"id": 399, "text": "Initialization: Create Initial Population: Generate an initial population of candidate solutions (chromosomes). Each chromosome represents a possible route for the salesman, typically represented as a permutation of city indices. Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 79, "total_chunks": 193}}, {"id": 400, "text": "Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route. Main Loop: Repeat until Termination Condition is met: Selection: Perform Roulette Wheel Selection: Select parents for mating based on their fitness. The probability of selection is proportional to the fitness of each chromosome.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 80, "total_chunks": 193}}, {"id": 401, "text": "The probability of selection is proportional to the fitness of each chromosome. Crossover: Apply Crossover Operation: Generate offspring by combining genetic material (routes) from selected parents. Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 81, "total_chunks": 193}}, {"id": 402, "text": "Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc. Mutation: Introduce Mutation: Randomly alter some chromosomes in the offspring population to maintain diversity. For TSP, swapping cities in a route is a typical mutation. Evaluate Fitness: Calculate the fitness of each offspring. Replacement: Select individuals for the next generation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 82, "total_chunks": 193}}, {"id": 403, "text": "Replacement: Select individuals for the next generation. This could involve elitism (keeping the best solutions from the current generation) or replacing the entire population. Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 83, "total_chunks": 193}}, {"id": 404, "text": "Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations). Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 84, "total_chunks": 193}}, {"id": 405, "text": "Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation. Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 85, "total_chunks": 193}}, {"id": 406, "text": "Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation. Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 86, "total_chunks": 193}}, {"id": 407, "text": "Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP. The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 87, "total_chunks": 193}}, {"id": 408, "text": "The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city. Task Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 88, "total_chunks": 193}}, {"id": 409, "text": "Task Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment. The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 89, "total_chunks": 193}}, {"id": 410, "text": "The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point. The goal is to find the shortest route that minimizes fuel costs and travel time using a Genetic Algorithm (GA). List of Cities (Warehouses) in Pakistan.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 90, "total_chunks": 193}}, {"id": 411, "text": "List of Cities (Warehouses) in Pakistan. Consider 10 major cities with approximate road distances (in kilometers) between them: Formulation using Genetic Algorithm Chromosome Representation: Each chromosome represents a sequence of cities (e.g., [Karachi \u2192 Lahore \u2192 Islamabad \u2192 Quetta \u2192 ...]). A valid solution must be a permutation of all cities.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 91, "total_chunks": 193}}, {"id": 412, "text": "A valid solution must be a permutation of all cities. Fitness Function: The total distance of a given route is calculated using the table above. The goal is to minimize the total distance. Selection Mechanism: Use Tournament Selection or Roulette Wheel Selection to choose the best routes. Crossover Operator: Use Partially Mapped Crossover (PMX) or Ordered Crossover (OX) to create new routes.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 92, "total_chunks": 193}}, {"id": 413, "text": "Crossover Operator: Use Partially Mapped Crossover (PMX) or Ordered Crossover (OX) to create new routes. Mutation Operator: Apply Swap Mutation (swap two random cities) or Scramble Mutation (shuffle a subset of cities). Termination Condition: Stop when the algorithm reaches a fixed number of generations or when the shortest route does not improve further.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 93, "total_chunks": 193}}, {"id": 414, "text": "Termination Condition: Stop when the algorithm reaches a fixed number of generations or when the shortest route does not improve further.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 94, "total_chunks": 193}}, {"id": 415, "text": "Implementing Connect Four with the Minimax algorithm provides an excellent opportunity to delve into the field of artificial intelligence and game theory. The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 95, "total_chunks": 193}}, {"id": 416, "text": "The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision. Learning Objectives Understanding Adversarial Games: Gain insights into adversarial games and the challenges involved in creating AI agents to play them.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 96, "total_chunks": 193}}, {"id": 417, "text": "Learning Objectives Understanding Adversarial Games: Gain insights into adversarial games and the challenges involved in creating AI agents to play them. Understand the concept of turn-based games and the opposing objectives of players in such games. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 97, "total_chunks": 193}}, {"id": 418, "text": "2. Implementing Game Logic: Learn how to implement the rules and mechanics of Connect Four, including the game board representation, legal moves, and win conditions. Gain proficiency in programming fundamentals by translating game rules into code. Exploring the Minimax Algorithm: Understand the Minimax algorithm and its application in decision-making for adversarial games.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 98, "total_chunks": 193}}, {"id": 419, "text": "Exploring the Minimax Algorithm: Understand the Minimax algorithm and its application in decision-making for adversarial games. Learn how Minimax traverses the game tree, evaluates potential moves, and selects the optimal strategy while considering both player's objectives.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 99, "total_chunks": 193}}, {"id": 420, "text": "Learn how Minimax traverses the game tree, evaluates potential moves, and selects the optimal strategy while considering both player's objectives. Handling Game State and Tree Traversal: Develop skills in managing game state representation and traversing the game tree efficiently.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 100, "total_chunks": 193}}, {"id": 421, "text": "Handling Game State and Tree Traversal: Develop skills in managing game state representation and traversing the game tree efficiently. Learn how to generate successor states, evaluate game states, and backtrack through the tree during the Minimax search. Optimizing with Alpha-Beta Pruning: Explore optimization techniques like alpha-beta pruning to improve the efficiency of the Minimax algorithm.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 101, "total_chunks": 193}}, {"id": 422, "text": "Optimizing with Alpha-Beta Pruning: Explore optimization techniques like alpha-beta pruning to improve the efficiency of the Minimax algorithm. Understand how pruning eliminates unnecessary branches of the game tree, reducing the computational complexity of the search. Testing and Evaluation: Learn how to test and evaluate the effectiveness of the Minimax-based Connect Four AI agent.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 102, "total_chunks": 193}}, {"id": 423, "text": "Testing and Evaluation: Learn how to test and evaluate the effectiveness of the Minimax-based Connect Four AI agent. Assess the agent's performance against human players or other AI agents, analyze its decision-making process, and identify areas for improvement. Setup: The game board is positioned vertically, with six rows and seven columns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 103, "total_chunks": 193}}, {"id": 424, "text": "Setup: The game board is positioned vertically, with six rows and seven columns. Each player is assigned a color, typically red and yellow. But this time we choose Green and Yellow instead. The game begins with an empty board. Gameplay: Players take turns dropping one of their colored discs into any column of the board. The disc falls to the lowest available empty cell in the selected column.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 104, "total_chunks": 193}}, {"id": 425, "text": "The disc falls to the lowest available empty cell in the selected column. Players alternate turns until one player achieves a winning four-in-a-row line or the board is completely filled without a winner (resulting in a draw). Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 105, "total_chunks": 193}}, {"id": 426, "text": "Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally. The game ends immediately once a winning condition is met. Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 106, "total_chunks": 193}}, {"id": 427, "text": "Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four). The choice of colors for Player 1 and Player 2 (e.g., \"Green\" and \"Yellow\"). The option to choose between two human players or one human player and one AI player. Game must include both options. Output: Display the game board after each move.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 107, "total_chunks": 193}}, {"id": 428, "text": "Output: Display the game board after each move. Inform the players when a player wins, loses, or when the game ends in a draw. Prompt the players for their moves (column number to drop their disc into). 3. INITIALIZATION: Create a 2D array to represent the game board with the specified number of rows and columns. Initialize the game board with empty cells. Assign colors to Player 1 and Player 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 108, "total_chunks": 193}}, {"id": 429, "text": "Assign colors to Player 1 and Player 2. 4. MAIN LOOP: 1. Display the initial empty game board. 2. Repeat the following steps until the game ends: - Prompt the current player for their move (column number to drop their disc into). - Update the game board with the player's move. - Check for a winning condition (four connected discs in a row).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 109, "total_chunks": 193}}, {"id": 430, "text": "- Check for a winning condition (four connected discs in a row). - If a winning condition is met, declare the current player as the winner and end the game. - Check for a draw condition (all cells on the board are filled without a winner). - If a draw condition is met, end the game with a draw. - Switch to the next player. 5. TERMINATION: Display the final game board.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 110, "total_chunks": 193}}, {"id": 431, "text": "TERMINATION: Display the final game board. If a player wins, announce the winner. If the game ends in a draw, announce the draw. End the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 111, "total_chunks": 193}}, {"id": 432, "text": "End the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 112, "total_chunks": 193}}, {"id": 433, "text": "It can be implemented in various programming languages, adapting the syntax and specific functionalities accordingly. Task Implement the above algorithm in Python for the following problem the Connect -Four Game for a grid of 12X12. Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 113, "total_chunks": 193}}, {"id": 434, "text": "Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color. Code Solution Below code sets up a Connect Four game board using Python\u2019s tkinter library, allowing play against an AI opponent. The game initializes a 12x12 board with players represented by different colors. Note: kinter is Python\u2019s standard library for creating graphical user interfaces (GUIs).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 114, "total_chunks": 193}}, {"id": 435, "text": "Note: kinter is Python\u2019s standard library for creating graphical user interfaces (GUIs). It allows you to build windows, buttons, labels, and other elements for desktop applications easily. In this Connect Four game, tkinter is used to create the game window and buttons for the board.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 115, "total_chunks": 193}}, {"id": 436, "text": "In this Connect Four game, tkinter is used to create the game window and buttons for the board. This function creates the game interface widgets (buttons and cells) for a grid-based game, likely Connect Four, where buttons are placed at the top of each column and cells form the playing grid below.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 116, "total_chunks": 193}}, {"id": 437, "text": "This function creates the game interface widgets (buttons and cells) for a grid-based game, likely Connect Four, where buttons are placed at the top of each column and cells form the playing grid below. This function handles a player's move in the game, checks for a win/draw, switches turns, and triggers the AI move if playing against the computer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 117, "total_chunks": 193}}, {"id": 438, "text": "This function handles a player's move in the game, checks for a win/draw, switches turns, and triggers the AI move if playing against the computer. This function executes the AI's move using the minimax algorithm with alpha-beta pruning, updates the game state, checks for a win/draw, and switches turns if the game continues.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 118, "total_chunks": 193}}, {"id": 439, "text": "This function executes the AI's move using the minimax algorithm with alpha-beta pruning, updates the game state, checks for a win/draw, and switches turns if the game continues. Attempts to place a player's piece in the lowest empty row of the specified column, updates the board, and returns True if successful; otherwise returns False.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 119, "total_chunks": 193}}, {"id": 440, "text": "Attempts to place a player's piece in the lowest empty row of the specified column, updates the board, and returns True if successful; otherwise returns False. Visually updates a game cell with a colored disc (green for PLAYER_A, yellow for PLAYER_B) to reflect the current move. Switches the current player's turn between PLAYER_A and PLAYER_B.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 120, "total_chunks": 193}}, {"id": 441, "text": "Switches the current player's turn between PLAYER_A and PLAYER_B. This function checks if the specified player has won by connecting four pieces in a row horizontally, vertically, or diagonally on the game board, returning True if a winning line is found. Checks if the game is a draw by verifying if the top row of the board is completely filled (no valid moves left).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 121, "total_chunks": 193}}, {"id": 442, "text": "Checks if the game is a draw by verifying if the top row of the board is completely filled (no valid moves left). Displays a \"Game Over\" message box with the given message and closes the game window. Returns a list of columns where a piece can still be placed (columns with at least one empty space in the top row).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 122, "total_chunks": 193}}, {"id": 443, "text": "Returns a list of columns where a piece can still be placed (columns with at least one empty space in the top row). Implements the minimax algorithm with alpha-beta pruning to determine the AI's optimal move, evaluating possible future board states recursively. Initializes and launches a 12x12 Connect Four game window in either Player vs Player or Player vs AI mode, based on the user's choice.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 123, "total_chunks": 193}}, {"id": 444, "text": "Initializes and launches a 12x12 Connect Four game window in either Player vs Player or Player vs AI mode, based on the user's choice. The game mode is selected via a console prompt. Mode Selection Prompt Displays a menu to choose between Player vs Player (1) or Player vs AI (2), then starts the game with the selected mode or reports an invalid input.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 124, "total_chunks": 193}}, {"id": 445, "text": "Mode Selection Prompt Displays a menu to choose between Player vs Player (1) or Player vs AI (2), then starts the game with the selected mode or reports an invalid input. Output We can select any of the two options: Lets say we go with option 2 to play with AI Agent. Tkinter GUI for the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 125, "total_chunks": 193}}, {"id": 446, "text": "Tkinter GUI for the game. Lab Week # 08 Artificial Intelligence Computer Science, Semester 6 th , Spring 2025 LAB 08: Implement the Class Scheduling using Constraint Satisfaction Problem Introduction In real-world scenarios, e.g. class scheduling, we often face constraints that make manual planning difficult.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 126, "total_chunks": 193}}, {"id": 447, "text": "class scheduling, we often face constraints that make manual planning difficult. Constraint Satisfaction Problems (CSPs) offer a structured way to model such problems using variables, domains, and constraints. In this lab, you will solve a simplified class scheduling problem using Python. Learning Objectives 1. Understand how to model real-world problems as CSPs. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 127, "total_chunks": 193}}, {"id": 448, "text": "2. Define variables, domains, and constraints in a CSP context. 3. Implement a CSP solver using either custom backtracking or a CSP library. 4. Generate and validate a schedule that satisfies all given constraints. Setup: 1. Python 3.x 2. Library: python-constraint (pip install python-constraint) 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 128, "total_chunks": 193}}, {"id": 449, "text": "Library: python-constraint (pip install python-constraint) 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 129, "total_chunks": 193}}, {"id": 450, "text": "Schedule 3 courses (C1, C2, C3) in 3 time slots (T1, T2, T3) and 2 rooms (R1, R2) while satisfying the following: Constraints: 1. No two courses should occupy the same room at the same time. 2. C1 and C2 should not occur at the same time (they share students). 3. C3 must be in Room R2 only. 4. Each course should have exactly one time slot and one room.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 130, "total_chunks": 193}}, {"id": 451, "text": "Each course should have exactly one time slot and one room.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 131, "total_chunks": 193}}, {"id": 452, "text": "Algorithm (General CSP Solver for Class Scheduling) Input: \uf0b7 Courses = {C1, C2, C3} \uf0b7 Time Slots = {T1, T2, T3} \uf0b7 Rooms = {R1, R2} \uf0b7 Constraints as defined above Output: \uf0b7 A valid assignment of (Time, Room) for each Course satisfying all constraints Code Task A This Python code defines a constraint satisfaction problem using the `python-constraint` library.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 132, "total_chunks": 193}}, {"id": 453, "text": "It schedules 3 courses (`C1`, `C2`, `C3`) into available time slots (`T1`, `T2`, `T3`) and rooms (`R1`, `R2`) such that no two courses overlap in the same room at the same time. The `no_overlap` function ensures each course gets a unique (time, room) pair. It continues the course scheduling problem by adding additional constraints.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 133, "total_chunks": 193}}, {"id": 454, "text": "It continues the course scheduling problem by adding additional constraints. It ensures that: Courses C1 and C2 cannot be scheduled at the same time, even in different rooms. Course C3 must be scheduled in Room R2 only. Output Task A Task B Add a 4th course, and include a new constraint: No teacher should be assigned to more than one course at the same time.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 134, "total_chunks": 193}}, {"id": 455, "text": "Output Task A Task B Add a 4th course, and include a new constraint: No teacher should be assigned to more than one course at the same time. (Assume teachers are T1, T2, T3.) Code Task B It solves a course scheduling problem using constraint satisfaction.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 135, "total_chunks": 193}}, {"id": 456, "text": "(Assume teachers are T1, T2, T3.) Code Task B It solves a course scheduling problem using constraint satisfaction. It assigns time slots and rooms to courses while ensuring: No overlapping room/time assignments (Constraint 1), Specific course constraints (e.g., C3 in R2, teacher T1's courses not overlapping). The solution is printed if valid, otherwise, it reports no valid schedule.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 136, "total_chunks": 193}}, {"id": 457, "text": "The solution is printed if valid, otherwise, it reports no valid schedule. Output Task B Lab Week # 09 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 09: Implement the real world problem with Bayesian Network Introduction In real-world scenarios, e.g.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 137, "total_chunks": 193}}, {"id": 458, "text": "Output Task B Lab Week # 09 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 09: Implement the real world problem with Bayesian Network Introduction In real-world scenarios, e.g.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 138, "total_chunks": 193}}, {"id": 459, "text": "class scheduling, we often face constraints that make manual planning Bayesian Networks (BNs) are powerful probabilistic models that represent dependencies among variables using directed acyclic graphs (DAGs). They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 139, "total_chunks": 193}}, {"id": 460, "text": "They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence. In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 140, "total_chunks": 193}}, {"id": 461, "text": "In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 141, "total_chunks": 193}}, {"id": 462, "text": "At the heart of these networks lies a crucial component known as the activation function. Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 142, "total_chunks": 193}}, {"id": 463, "text": "Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships. An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 143, "total_chunks": 193}}, {"id": 464, "text": "An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer. The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 144, "total_chunks": 193}}, {"id": 465, "text": "The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer. However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 145, "total_chunks": 193}}, {"id": 466, "text": "However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems. Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 146, "total_chunks": 193}}, {"id": 467, "text": "Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns. They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 147, "total_chunks": 193}}, {"id": 468, "text": "They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics. By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 148, "total_chunks": 193}}, {"id": 469, "text": "By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance. There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 149, "total_chunks": 193}}, {"id": 470, "text": "There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 150, "total_chunks": 193}}, {"id": 471, "text": "Choosing the appropriate activation function is critical, as it affects the network's convergence speed, stability, and overall performance. The selection often depends on the specific problem being addressed and the characteristics of the data.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 151, "total_chunks": 193}}, {"id": 472, "text": "The selection often depends on the specific problem being addressed and the characteristics of the data. Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 152, "total_chunks": 193}}, {"id": 473, "text": "Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications. Algorithm: Activation functions Sigmoid Activation Function Definition: The Sigmoid function, also known as the logistic function, maps any input to a value between 0 and 1. It is defined as: 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 153, "total_chunks": 193}}, {"id": 474, "text": "It is defined as: 2. ReLU (Rectified Linear Unit) Activation Function Definition: The ReLU function is defined as: 3. Tanh (Hyperbolic Tangent) Activation Function Definition: The Tanh function maps the input to a value between -1 and 1. It is defined as: These activation functions are foundational to neural network design, each with its specific strengths and trade-offs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 154, "total_chunks": 193}}, {"id": 475, "text": "It is defined as: These activation functions are foundational to neural network design, each with its specific strengths and trade-offs. Understanding their characteristics helps in choosing the right activation function for a given task and architecture.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 155, "total_chunks": 193}}, {"id": 476, "text": "Understanding their characteristics helps in choosing the right activation function for a given task and architecture. Code Solution OUPUT: Task 2 Bias Detection in Activation Functions Hypothesis: \"Activation functions introduce bias by favoring certain output ranges, which may skew predictions.\" Steps: 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 156, "total_chunks": 193}}, {"id": 477, "text": "Code Solution OUPUT: Task 2 Bias Detection in Activation Functions Hypothesis: \"Activation functions introduce bias by favoring certain output ranges, which may skew predictions.\" Steps: 1. Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 157, "total_chunks": 193}}, {"id": 478, "text": "Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2. Train a single-neuron ANN (no hidden layers) using each activation function. 3. Analyze bias by comparing: - Output distribution (histogram of predictions). - Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 158, "total_chunks": 193}}, {"id": 479, "text": "- Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 159, "total_chunks": 193}}, {"id": 480, "text": "Which activation function amplified bias the most? Why? ReLU amplified bias the most. It outputs zero for all negative inputs, causing Class B (centered around -2) to collapse to near-zero outputs, while Class A remains distinct. This harsh threshold leads to amplified separation between the classes. 2. How did the bias term affect ReLU vs. Sigmoid?", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 160, "total_chunks": 193}}, {"id": 481, "text": "Sigmoid? ReLU: The bias term shifted the output range slightly but didn't eliminate the hard zero cutoff, so bias remained strong. Sigmoid: The bias term helped center the input distribution better within the sigmoid\u2019s responsive region, reducing extreme output differences between Class A and B more than ReLU. 3. Can activation functions themselves be a source of algorithmic bias? Yes.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 161, "total_chunks": 193}}, {"id": 482, "text": "Yes. Activation functions like ReLU inherently suppress negative inputs, which may skew predictions if one class predominantly has such values. This can lead to algorithmic bias, even when the model is simple and unbiased in design.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 162, "total_chunks": 193}}, {"id": 483, "text": "This can lead to algorithmic bias, even when the model is simple and unbiased in design.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 163, "total_chunks": 193}}, {"id": 484, "text": "Lab Week # 11 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 11: Building an NLP Pipeline \u2013 From Text to Intelligence using python Introduction Natural Language Processing (NLP) is a core area of Artificial Intelligence that enables machines to understand, interpret, and generate human language.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 164, "total_chunks": 193}}, {"id": 485, "text": "In this hands-on lab, you will walk through the complete NLP pipeline\u2014from raw text to classification\u2014using Python. You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 165, "total_chunks": 193}}, {"id": 486, "text": "You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing. By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 166, "total_chunks": 193}}, {"id": 487, "text": "By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language. Algorithm Steps: 1. Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 167, "total_chunks": 193}}, {"id": 488, "text": "Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels. Example: data = [ (&quot;I loved the movie, it was fantastic!&quot;, &quot;Positive&quot;), (&quot;The film was boring and slow&quot;, &quot;Negative&quot;), # Add more samples... ] 2. Preprocessing Pipeline a. Tokenization Split each review into individual words. b.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 168, "total_chunks": 193}}, {"id": 489, "text": "b. Stopword Removal Remove common words like \u201cthe\u201d, \u201cis\u201d, \u201cand\u201d, using NLTK or spaCy. c. Lemmatization Convert words to their base forms (e.g., running\u2192 run). Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 169, "total_chunks": 193}}, {"id": 490, "text": "Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer 3. Vectorization Convert cleaned text into numerical format using: CountVectorizer or TF-IDF Vectorizer from sklearn.feature_extraction.text import CountVectorizer 4. Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 170, "total_chunks": 193}}, {"id": 491, "text": "Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment. from sklearn.naive_bayes import MultinomialNB from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score Evaluate Check accuracy on test data. Print 2\u20133 predictions for new reviews. Expected Output Cleaned and lemmatized reviews.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 171, "total_chunks": 193}}, {"id": 492, "text": "Expected Output Cleaned and lemmatized reviews. A table showing transformed text vectors. Model accuracy score (e.g., 85%). Example predictions: Review: \u201cAbsolutely amazing film\u201d \u2192 Positive Review: \u201cTerrible and dull\u201d \u2192 Negative Code Solution First of all we imported all the important libraries. NLTK stands for Natural Language Toolkit which is used for NLP (Natural Language processing) Tasks.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 172, "total_chunks": 193}}, {"id": 493, "text": "NLTK stands for Natural Language Toolkit which is used for NLP (Natural Language processing) Tasks. NLTK helps the program to understand, process, and analyze human language (Text or speech).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 173, "total_chunks": 193}}, {"id": 494, "text": "NLTK helps the program to understand, process, and analyze human language (Text or speech). We then took some dummy data to train our model, as we are just practicing so this is a very small dataset which is just for learning purpose so may be our model is not completely or very accurately train as we have very small dataset.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 174, "total_chunks": 193}}, {"id": 495, "text": "We then took some dummy data to train our model, as we are just practicing so this is a very small dataset which is just for learning purpose so may be our model is not completely or very accurately train as we have very small dataset. The data set contains both positive and negative reviews to train our model for future predictions on new unseen data. It reduces the words to root form.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 175, "total_chunks": 193}}, {"id": 496, "text": "It reduces the words to root form. Converts the words back to base. Removes stopwords and punctuations. Vectorization converts the words into numeric form so that our model can understand it. We then split the dataset, some for training and remaining for testing so we can use it for future predictions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 176, "total_chunks": 193}}, {"id": 497, "text": "We then split the dataset, some for training and remaining for testing so we can use it for future predictions. Evaluate the model by checking its prediction accuracy rate, in our taken dataset the accuracy for this model is 45.45%. Then we added some data to predict it by the model. Output We can see the model has predicted the reviews accuractely.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 177, "total_chunks": 193}}, {"id": 498, "text": "Output We can see the model has predicted the reviews accuractely. Note: Earlier I took a very smaller dataset even smaller than the current one, I observed that their result comes out to be wrong, that predicted the sentiment about the reviews wrong, this was because of our smaller dataset. The larger will be the dataset, the more accurate will be model predictions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 178, "total_chunks": 193}}, {"id": 499, "text": "The larger will be the dataset, the more accurate will be model predictions. Moreover, Other better NLP algorithms like Logistic Regression can be used to avoid such situations as LR is better than the current model. Lab Week # 12 Artificial Intelligence Computer Science, Semester 6th, Spring 2025 LAB 12: Image Classification Using Artificial Neural Networks (ANN).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 179, "total_chunks": 193}}, {"id": 500, "text": "Lab Week # 12 Artificial Intelligence Computer Science, Semester 6th, Spring 2025 LAB 12: Image Classification Using Artificial Neural Networks (ANN). Introduction In this lab, students will build an Artificial Neural Network (ANN) to classify handwritten digits (0\u20139) using the MNIST dataset. Students will train the model, evaluate its accuracy, and test it with their own handwritten digit.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 180, "total_chunks": 193}}, {"id": 501, "text": "Students will train the model, evaluate its accuracy, and test it with their own handwritten digit. Setup: Dataset MNIST Dataset: (given in separate file. 70,000 grayscale images (28\u00d728 pixels). 60,000 training + 10,000 test samples. Each pixel value: 0 (black) to 255 (white).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 181, "total_chunks": 193}}, {"id": 502, "text": "Each pixel value: 0 (black) to 255 (white). Library: TensorFlow/Keras, Matplotlib Editor: Any Python-supported IDE or Jupyter Notebook, Google Colab Steps:Algorithm: Step 1. Data Loading & Preprocessing: Load MNIST dataset (60,000 training + 10,000 test images). Normalize pixel values (0\u2013255 \u2192 0\u20131). Reshape images for ANN input (flatten 28x28 \u2192 784 pixels).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 182, "total_chunks": 193}}, {"id": 503, "text": "Reshape images for ANN input (flatten 28x28 \u2192 784 pixels). One-hot encode labels (e.g., \"3\" \u2192 [0,0,0,1,0,0,0,0,0,0]). Step 2. Model Architecture (ANN): Input Layer: 784 neurons (1 per pixel). Hidden Layer(s): 1\u20132 dense layers with ReLU activation. Output Layer: 10 neurons (Softmax activation for probability distribution). Step 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 183, "total_chunks": 193}}, {"id": 504, "text": "Step 3. Training & Evaluation: Compile model with `adam` optimizer and `categorical_crossentropy` loss. Train for 5\u201310 epochs and validate on test data. Evaluate accuracy and confusion matrix. Step 4. Custom Digit Testing: Draw a digit (using `matplotlib` or external image). Preprocess and predict using the trained model.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 184, "total_chunks": 193}}, {"id": 505, "text": "Preprocess and predict using the trained model. Code Solution Imported Important Libraries It imports essential libraries for data manipulation (pandas, numpy), visualization (matplotlib), and building neural networks using TensorFlow/Keras (Sequential, Dense, to_categorical, and SGD). These imports set the foundation for a machine learning project.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 185, "total_chunks": 193}}, {"id": 506, "text": "These imports set the foundation for a machine learning project. load_data() function This function loads and preprocesses the training and test data from CSV files, separating features and labels, and normalizing pixel values to the range [0, 1].", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 186, "total_chunks": 193}}, {"id": 507, "text": "load_data() function This function loads and preprocesses the training and test data from CSV files, separating features and labels, and normalizing pixel values to the range [0, 1].", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 187, "total_chunks": 193}}, {"id": 508, "text": "build_model(input_shape) function: This function builds and compiles a deep neural network with three hidden layers using ReLU activation and an output layer with softmax for multi-class classification of digits (0\u20139). display_sample_predictions The function visualizes grayscale image predictions using matplotlib.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 188, "total_chunks": 193}}, {"id": 509, "text": "display_sample_predictions The function visualizes grayscale image predictions using matplotlib. main() Function This main function loads data, trains a model, and plots training vs validation accuracy over epochs. Calling the main function Output Predictions Lab Evaluation Summary Student Name | Syed Hasnain Ali Shah Rehistration | 22 PWBCS 0919 Department | CS & IT Instructor | Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 189, "total_chunks": 193}}, {"id": 510, "text": "Calling the main function Output Predictions Lab Evaluation Summary Student Name | Syed Hasnain Ali Shah Rehistration | 22 PWBCS 0919 Department | CS & IT Instructor | Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 190, "total_chunks": 193}}, {"id": 511, "text": "| Image Classification Using Artificial Neural Networks (ANN). | 26 May, 2025 13 | Mini Project-RAG System | Mini Project-RAG System 14 | Mini Project-RAG System | Mini Project-RAG System", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 191, "total_chunks": 193}}, {"id": 512, "text": "| 26 May, 2025 13 | Mini Project-RAG System | Mini Project-RAG System 14 | Mini Project-RAG System | Mini Project-RAG System", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 192, "total_chunks": 193}}, {"id": 513, "text": "DEPARTMENT OF COMPUTER SCIENCE & INFORMATION TECHNOLOGY UNIVERSITY OF ENGINEERING & TECHNOLOGY, PESHAWAR Lab Manual BS(CS) Spring 2025 Artificial Intelligence Subject: Artificial Intelligence (Lab) Code: CS- 401 (L) Instructor: Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 0, "total_chunks": 193}}, {"id": 514, "text": "Wajeeha Khalil Session: 2025 Semester (S/F): 6th (Spring) Lab Week # 01 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 01: Implement Breadth-First Search BFS using Python Introduction Breadth-First Search (BFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 1, "total_chunks": 193}}, {"id": 515, "text": "It operates by visiting all nodes in a graph level by level, starting from a designated source node.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 2, "total_chunks": 193}}, {"id": 516, "text": "Learn how to represent problem domains and states for BFS-based intelligent agents. Gain proficiency in implementing BFS algorithm to explore state spaces efficiently. Develop problem-solving skills by applying BFS to various scenarios and domains in AI.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 3, "total_chunks": 193}}, {"id": 517, "text": "Develop problem-solving skills by applying BFS to various scenarios and domains in AI. Appreciate the importance of search algorithms in building intelligent agents capable of navigating complex environments and achieving desired goals.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 4, "total_chunks": 193}}, {"id": 518, "text": "Appreciate the importance of search algorithms in building intelligent agents capable of navigating complex environments and achieving desired goals. Steps: Algorithm: Breadth-First Search (BFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 5, "total_chunks": 193}}, {"id": 519, "text": "Steps: Algorithm: Breadth-First Search (BFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 6, "total_chunks": 193}}, {"id": 520, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Dequeue a state current_state from the frontier. If current_state is the goal state, return the path to current_state. Add current_state to the explored set.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 7, "total_chunks": 193}}, {"id": 521, "text": "Add current_state to the explored set. For each action a in the set of legal actions applicable to current_state: Calculate the successor state next_state by applying action a to current_state. If next_state is not in frontier or explored: Enqueue next_state onto the frontier. Set the parent of next_state to current_state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 8, "total_chunks": 193}}, {"id": 522, "text": "Set the parent of next_state to current_state. Termination: If the frontier becomes empty without finding the goal state, return failure. Explanation: The algorithm starts by initializing a queue (frontier) to store states to be explored and a set (explored) to keep track of visited states. It continues to dequeue states from the frontier and explores their successors by applying legal actions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 9, "total_chunks": 193}}, {"id": 523, "text": "It continues to dequeue states from the frontier and explores their successors by applying legal actions. If a successor state has not been visited before, it is enqueued onto the frontier. The algorithm terminates either when the goal state is found or when the frontier becomes empty.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 10, "total_chunks": 193}}, {"id": 524, "text": "The algorithm terminates either when the goal state is found or when the frontier becomes empty. If the goal state is found, the algorithm backtracks from the goal state to the initial state using parent pointers to construct the solution path. Note: Refer to the generalized Algorithm studied in theory class for more understanding.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 11, "total_chunks": 193}}, {"id": 525, "text": "Note: Refer to the generalized Algorithm studied in theory class for more understanding. Task Implement the above algorithm in Python for the following problem where 12 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 12, "total_chunks": 193}}, {"id": 526, "text": "Task Implement the above algorithm in Python for the following problem where 12 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 13, "total_chunks": 193}}, {"id": 527, "text": "Solution: Importing Required Libraries: Networkx: Library used for the graph creation Matplotlib: Library used for plotting the graph dequeue: A queue from collection library for visiting the nodes Breadth First Search Implementation Part: The BFS algorithm is implemented using a queue (FIFO structure). It explores the graph level by level before moving deeper.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 14, "total_chunks": 193}}, {"id": 528, "text": "It explores the graph level by level before moving deeper.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 15, "total_chunks": 193}}, {"id": 529, "text": "Unlike BFS, which explores nodes level by level, DFS explores as far as possible along each branch before backtracking.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 16, "total_chunks": 193}}, {"id": 530, "text": "DFS is widely employed in AI applications such as: Pathfinding State space exploration Solving Puzzle and Mazes By traversing the graph depth-wise, DFS is particularly useful for exploring all possible paths in a graph, making it ideal for problems like cycle detection, topological sorting, and solving constraint satisfaction problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 17, "total_chunks": 193}}, {"id": 531, "text": "Learning Objectives Understand the steps involved in Depth-First Search for solving AI problems. Learn how to represent problem domains and states for DFS-based intelligent agents. Gain proficiency in implementing the DFS algorithm to explore state spaces efficiently. Develop problem-solving skills by applying DFS to various AI scenarios.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 18, "total_chunks": 193}}, {"id": 532, "text": "Develop problem-solving skills by applying DFS to various AI scenarios. Appreciate the importance of search algorithms in building intelligent agents. Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 19, "total_chunks": 193}}, {"id": 533, "text": "Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 20, "total_chunks": 193}}, {"id": 534, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Pop a node (current_node) from the frontier. If current_node is the goal node, return the path to current_node. Add current_node to the explored set.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 21, "total_chunks": 193}}, {"id": 535, "text": "Add current_node to the explored set. For each neighbor of current_node: If the neighbor is not in frontier or explored: Push the neighbor onto the frontier. Set the parent of the neighbor to current_node. Termination: If the frontier becomes empty without finding the goal node, return failure.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 22, "total_chunks": 193}}, {"id": 536, "text": "Termination: If the frontier becomes empty without finding the goal node, return failure. Explanation: break down the provided Breadth-First Search (BFS) algorithm for intelligent agents step by step: Initialization: We start by initializing a queue named frontier to keep track of states to be explored. We enqueue the initial state onto the frontier.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 23, "total_chunks": 193}}, {"id": 537, "text": "We enqueue the initial state onto the frontier. An empty set explored is created to store visited states. Main Loop: We enter a loop that continues until the frontier is not empty. Within each iteration of the loop: We dequeue a state current_state from the frontier. We check if current_state is the goal state by calling the Problem.goal_test(current_state) function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 24, "total_chunks": 193}}, {"id": 538, "text": "We check if current_state is the goal state by calling the Problem.goal_test(current_state) function. If it is, we return the path to this state. If current_state is not the goal state, we mark it as explored by adding it to the explored set. We iterate over all applicable actions for the current_state by calling Problem.actions(current_state).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 25, "total_chunks": 193}}, {"id": 539, "text": "We iterate over all applicable actions for the current_state by calling Problem.actions(current_state). For each action: We calculate the successor state next_state by applying the action to the current_state using the Problem.result(current_state, action) function. If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 26, "total_chunks": 193}}, {"id": 540, "text": "If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier. We set the parent of next_state to current_state. This step is crucial for reconstructing the path once the goal state is found.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 27, "total_chunks": 193}}, {"id": 541, "text": "This step is crucial for reconstructing the path once the goal state is found. Termination: If the frontier becomes empty without finding the goal state, we return failure, indicating that the goal state is unreachable from the initial state. Output: If the goal state is found during the search, we return the path from the initial state to the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 28, "total_chunks": 193}}, {"id": 542, "text": "Output: If the goal state is found during the search, we return the path from the initial state to the goal state. This path can be constructed by following the parent pointers from the goal state back to the initial state. Note: Refer to the generalized Algorithm studied in theory class for more understanding.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 29, "total_chunks": 193}}, {"id": 543, "text": "Note: Refer to the generalized Algorithm studied in theory class for more understanding. Task Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 30, "total_chunks": 193}}, {"id": 544, "text": "Task Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 31, "total_chunks": 193}}, {"id": 545, "text": "In this puzzle: A man wants to cross a river with three items: a wolf, a chicken, and a corn. The boat can carry a maximum of two entities (the man plus one item). Constraints: If the wolf and chicken are left alone without the man, the wolf will eat the chicken. If the chicken and corn are left alone without the man, the chicken will eat the corn.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 32, "total_chunks": 193}}, {"id": 546, "text": "If the chicken and corn are left alone without the man, the chicken will eat the corn. Your task is to help the man safely transport all items to the other side of the river without violating the constraints. Learning Objectives Understand the concept of state-space search in AI. Apply logical reasoning to solve constraint-based problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 33, "total_chunks": 193}}, {"id": 547, "text": "Apply logical reasoning to solve constraint-based problems. Implement a search algorithm (e.g., BFS or DFS) to find a valid sequence of moves. Develop problem-solving skills by exploring possible states and transitions. Problem Setup Entities: Man, Wolf, Chicken, Corn. Boat Capacity: Maximum of 2 (Man + 1 item). Constraints: Wolf cannot be left alone with Chicken.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 34, "total_chunks": 193}}, {"id": 548, "text": "Constraints: Wolf cannot be left alone with Chicken. Chicken cannot be left alone with Corn. State Representation Each state can be represented as a tuple: (Man, Wolf, Chicken, Corn) Man: Left or Right (side of the river). Wolf, Chicken, Corn: Left or Right (side of the river).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 35, "total_chunks": 193}}, {"id": 549, "text": "Wolf, Chicken, Corn: Left or Right (side of the river). Example: Initial State: ('Left', 'Left', 'Left', 'Left') Goal State: ('Right', 'Right', 'Right', 'Right') Task State-Space Search: Represent the problem as a state-space graph. Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 36, "total_chunks": 193}}, {"id": 550, "text": "Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions. Find a Valid Sequence: Find a sequence of moves that transports all items to the right side of the river without violating the constraints. Implement the Solution: Write a Python program to solve the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 37, "total_chunks": 193}}, {"id": 551, "text": "Implement the Solution: Write a Python program to solve the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 38, "total_chunks": 193}}, {"id": 552, "text": "In this implementation, we will focus on the 8-puzzle variant, where the puzzle is divided into a 3x3 grid with eight numbered tiles and one empty space. We'll use the A* search algorithm to efficiently find the shortest path from the initial state to the goal state. Learning Objectives Understand the N-Puzzle problem and its rules. Implement the A* search algorithm in Python.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 39, "total_chunks": 193}}, {"id": 553, "text": "Implement the A* search algorithm in Python. Learn how to represent states, actions, and transitions in the N-Puzzle problem. Gain experience in solving optimization problems using heuristic search techniques. Steps: Algorithm: A* search Input: Receive the initial and goal configurations of the puzzle. Output: Display the steps required to reach the goal state from the initial state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 40, "total_chunks": 193}}, {"id": 554, "text": "Output: Display the steps required to reach the goal state from the initial state. Initialization: Initialize the A* algorithm with the initial state, priority queue, and heuristic function. Main Loop: Iteratively expand nodes based on their estimated cost until the goal state is reached or no more nodes are left to explore.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 41, "total_chunks": 193}}, {"id": 555, "text": "Main Loop: Iteratively expand nodes based on their estimated cost until the goal state is reached or no more nodes are left to explore. Termination: Terminate the algorithm when the goal state is reached or when no solution is found. Explanation: 1. INPUT: Define the problem domain including the initial state and the goal state of the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 42, "total_chunks": 193}}, {"id": 556, "text": "INPUT: Define the problem domain including the initial state and the goal state of the puzzle. Define the actions applicable to each state, the transition model, the goal test, and the cost function. 2. OUTPUT: Return the sequence of actions that lead from the initial state to the goal state. 3. INITIALIZATION: Initialize an empty priority queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 43, "total_chunks": 193}}, {"id": 557, "text": "INITIALIZATION: Initialize an empty priority queue frontier to store states to be explored. Enqueue the initial state onto the frontier with a priority of 0. Initialize an empty set explored to store visited states. 4. MAIN LOOP: While the frontier is not empty: Dequeue a state from the frontier. If the dequeued state is the goal state, return the sequence of actions leading to it.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 44, "total_chunks": 193}}, {"id": 558, "text": "If the dequeued state is the goal state, return the sequence of actions leading to it. Add the dequeued state to the explored set For each action applicable to the current state: Calculate the successor state by applying the action. If the successor state has not been explored or enqueued: Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 45, "total_chunks": 193}}, {"id": 559, "text": "If the successor state has not been explored or enqueued: Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic. Set the parent of the successor state to the current state. 5. TERMINATION: If the frontier becomes empty without finding the goal state, return failure.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 46, "total_chunks": 193}}, {"id": 560, "text": "TERMINATION: If the frontier becomes empty without finding the goal state, return failure. Explanation N-Puzzle or sliding puzzle is a popular puzzle that consists of N tiles where N can be 8, 15, 24 and so on. In our example N = 8. The puzzle is divided into sqrt(N+1) rows and sqrt(N+1) columns. Eg. 15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 47, "total_chunks": 193}}, {"id": 561, "text": "15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns. The puzzle consists of N tiles and one empty space where the tiles can be moved. Start and Goal configurations (also called state) of the puzzle are provided. The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 48, "total_chunks": 193}}, {"id": 562, "text": "The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration. Rules for solving the puzzle. Instead of moving the tiles in the empty space we can visualize moving the empty space in place of the tile, basically swapping the tile with the empty space. The empty space can only move in four directions viz., 1. Up 2.Down 3. Right or 4.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 49, "total_chunks": 193}}, {"id": 563, "text": "Right or 4. Left The empty space cannot move diagonally and can take only one step at a time (i.e. move the empty space one position at a time). The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 50, "total_chunks": 193}}, {"id": 564, "text": "The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state. The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 51, "total_chunks": 193}}, {"id": 565, "text": "The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution. It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 52, "total_chunks": 193}}, {"id": 566, "text": "It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems. A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 53, "total_chunks": 193}}, {"id": 567, "text": "A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search. It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 54, "total_chunks": 193}}, {"id": 568, "text": "It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node. Heuristic Cost (h): An estimated cost from the current node to the goal node (often called the heuristic function). The key to A*'s efficiency lies in its selection of nodes to explore.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 55, "total_chunks": 193}}, {"id": 569, "text": "The key to A*'s efficiency lies in its selection of nodes to explore. At each step, it chooses the node that minimizes the sum of the path cost g and the estimated remaining cost to the goal h (often represented as f = g + h). This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 56, "total_chunks": 193}}, {"id": 570, "text": "This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function. Task Implement the above algorithm in Python for the following problem the N-Puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 57, "total_chunks": 193}}, {"id": 571, "text": "Task Implement the above algorithm in Python for the following problem the N-Puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 58, "total_chunks": 193}}, {"id": 572, "text": "This lab explores solving TSP using the Simulated Annealing (SA) algorithm and analyzing its performance. Learning Objectives: Understand the concept of TSP and heuristic optimization. Implement Simulated Annealing (SA) for solving TSP. Analyze performance metrics such as path length and execution time. Compare SA with other optimization techniques. Algorithm: 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 59, "total_chunks": 193}}, {"id": 573, "text": "Algorithm: 1. Input: A set of cities with random (x, y) coordinates. Distance function (e.g., Euclidean distance) to evaluate the path cost. 2. Output: Optimized path with the shortest distance. Graphical representation of the final tour. 3. Initialization: Generate an initial random tour. Set initial temperature and cooling rate for Simulated Annealing. Define an acceptance probability function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 60, "total_chunks": 193}}, {"id": 574, "text": "Define an acceptance probability function. 4. Main Loop: Iteratively swap cities in the tour to generate a new solution. Evaluate the cost difference between current and new solutions. Accept the new solution based on the probability function. Gradually reduce the temperature until termination conditions are met. 5. Termination: Stop when the temperature reaches a predefined threshold.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 61, "total_chunks": 193}}, {"id": 575, "text": "Termination: Stop when the temperature reaches a predefined threshold. Return the best solution found. Explanation: 1. INPUT: Number of cities (e.g., 20 for initial experiments, extendable to 100). Coordinate values for cities. Initial temperature, cooling rate, and maximum iterations. 2. OUTPUT: Optimized tour with minimal travel cost. Graphical visualization of the tour.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 62, "total_chunks": 193}}, {"id": 576, "text": "Graphical visualization of the tour. Execution time and convergence analysis. 3. INITIALIZATION: Generate a random initial tour. Define temperature and cooling schedule. Set an initial best cost value. 4. MAIN LOOP: Randomly select two cities and swap them. Calculate the new tour\u2019s total distance. Use Simulated Annealing acceptance criteria to decide whether to accept the new solution.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 63, "total_chunks": 193}}, {"id": 577, "text": "Use Simulated Annealing acceptance criteria to decide whether to accept the new solution. Decrease temperature iteratively. 5. TERMINATION: Stop when the temperature reaches near zero or after a fixed number of iterations. Return the best-found solution. Task Implement Simulated Annealing (SA) to solve TSP. Visualize the computed shortest tour.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 64, "total_chunks": 193}}, {"id": 578, "text": "Visualize the computed shortest tour. Analyze performance based on: Path length Execution time Number of iterations Extend the problem to 100 cities and compare results. Implement Tabu Search and evaluate its effectiveness against SA.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 65, "total_chunks": 193}}, {"id": 579, "text": "Implement Tabu Search and evaluate its effectiveness against SA. Code Solution Imported important Libraries Distance Calculation for TSP Total Distance Algorithm for Simulated Annealing Visualization Function Output SA for STP Tabu Search Implementation Visualization Output Comparison Simulated Annealing VS Tabu Search Comparison Table: Simulated Annealing vs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 66, "total_chunks": 193}}, {"id": 580, "text": "Code Solution Imported important Libraries Distance Calculation for TSP Total Distance Algorithm for Simulated Annealing Visualization Function Output SA for STP Tabu Search Implementation Visualization Output Comparison Simulated Annealing VS Tabu Search Comparison Table: Simulated Annealing vs. Tabu Search Short Report: Simulated Annealing vs. Tabu Search 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 67, "total_chunks": 193}}, {"id": 581, "text": "Tabu Search 1. Algorithm Explanation Simulated Annealing (SA): Simulated Annealing is a probabilistic optimization technique inspired by the annealing process in metallurgy. The algorithm starts with a high temperature, which gradually decreases. At each iteration, it explores a new solution by swapping two cities.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 68, "total_chunks": 193}}, {"id": 582, "text": "At each iteration, it explores a new solution by swapping two cities. If the new solution is better, it is accepted; otherwise, it may still be accepted with a probability that decreases over time. This helps avoid local optima and allows exploration of the solution space.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 69, "total_chunks": 193}}, {"id": 583, "text": "This helps avoid local optima and allows exploration of the solution space. Tabu Search (TS): Tabu Search is a local search method that enhances hill-climbing by maintaining a list of recently visited solutions (tabu list) to prevent cycling back to previous solutions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 70, "total_chunks": 193}}, {"id": 584, "text": "Tabu Search (TS): Tabu Search is a local search method that enhances hill-climbing by maintaining a list of recently visited solutions (tabu list) to prevent cycling back to previous solutions. It systematically explores the solution space by swapping cities and tracking the best solutions while avoiding short-term revisits. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 71, "total_chunks": 193}}, {"id": 585, "text": "2. Performance Analysis From the comparison table, we can analyze: Path Length: Simulated Annealing found a shorter path (643.42) compared to Tabu Search (382.94), indicating its better exploration capability. Execution Time: Simulated Annealing took 0.62 seconds, which is shorter than Tabu Search\u2019s 19.27 seconds due to more iterations and its probabilistic nature.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 72, "total_chunks": 193}}, {"id": 586, "text": "Execution Time: Simulated Annealing took 0.62 seconds, which is shorter than Tabu Search\u2019s 19.27 seconds due to more iterations and its probabilistic nature. Number of Iterations: SA runs significantly more iterations than TS, but this helps it avoid local optima and explore more of the solution space. 3. SA vs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 73, "total_chunks": 193}}, {"id": 587, "text": "SA vs. Tabu Search Comparison Lab Week # 06 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 06: Implementation of Genetic Algorithm Introduction The Traveling Salesman Problem (TSP) is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 74, "total_chunks": 193}}, {"id": 588, "text": "Tabu Search Comparison Lab Week # 06 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 06: Implementation of Genetic Algorithm Introduction The Traveling Salesman Problem (TSP) is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 75, "total_chunks": 193}}, {"id": 589, "text": "Genetic Algorithms (GAs) are evolutionary algorithms inspired by natural selection and genetics, commonly used to solve optimization and search problems. Learning Objectives Understand the application of Genetic Algorithms in solving optimization problems like the Traveling Salesman Problem. Learn about Roulette Wheel Selection Method for parent selection in Genetic Algorithms.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 76, "total_chunks": 193}}, {"id": 590, "text": "Learn about Roulette Wheel Selection Method for parent selection in Genetic Algorithms. Implement a basic Genetic Algorithm solution for the Traveling Salesman Problem in Python. Algorithm: Genetic Algorithm Input: A set of cities with their coordinates. Population size. Crossover rate. Mutation rate. Termination condition (e.g., maximum number of generations, convergence criteria).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 77, "total_chunks": 193}}, {"id": 591, "text": "Termination condition (e.g., maximum number of generations, convergence criteria). Output: The best route found (shortest tour) that visits each city exactly once and returns to the original city. Initialization: Create Initial Population: Generate an initial population of candidate solutions (chromosomes).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 78, "total_chunks": 193}}, {"id": 592, "text": "Initialization: Create Initial Population: Generate an initial population of candidate solutions (chromosomes). Each chromosome represents a possible route for the salesman, typically represented as a permutation of city indices. Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 79, "total_chunks": 193}}, {"id": 593, "text": "Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route. Main Loop: Repeat until Termination Condition is met: Selection: Perform Roulette Wheel Selection: Select parents for mating based on their fitness. The probability of selection is proportional to the fitness of each chromosome.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 80, "total_chunks": 193}}, {"id": 594, "text": "The probability of selection is proportional to the fitness of each chromosome. Crossover: Apply Crossover Operation: Generate offspring by combining genetic material (routes) from selected parents. Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 81, "total_chunks": 193}}, {"id": 595, "text": "Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc. Mutation: Introduce Mutation: Randomly alter some chromosomes in the offspring population to maintain diversity. For TSP, swapping cities in a route is a typical mutation. Evaluate Fitness: Calculate the fitness of each offspring. Replacement: Select individuals for the next generation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 82, "total_chunks": 193}}, {"id": 596, "text": "Replacement: Select individuals for the next generation. This could involve elitism (keeping the best solutions from the current generation) or replacing the entire population. Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 83, "total_chunks": 193}}, {"id": 597, "text": "Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations). Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 84, "total_chunks": 193}}, {"id": 598, "text": "Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation. Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 85, "total_chunks": 193}}, {"id": 599, "text": "Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation. Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 86, "total_chunks": 193}}, {"id": 600, "text": "Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP. The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 87, "total_chunks": 193}}, {"id": 601, "text": "The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city. Task Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 88, "total_chunks": 193}}, {"id": 602, "text": "Task Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment. The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 89, "total_chunks": 193}}, {"id": 603, "text": "The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point. The goal is to find the shortest route that minimizes fuel costs and travel time using a Genetic Algorithm (GA). List of Cities (Warehouses) in Pakistan.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 90, "total_chunks": 193}}, {"id": 604, "text": "List of Cities (Warehouses) in Pakistan. Consider 10 major cities with approximate road distances (in kilometers) between them: Formulation using Genetic Algorithm Chromosome Representation: Each chromosome represents a sequence of cities (e.g., [Karachi \u2192 Lahore \u2192 Islamabad \u2192 Quetta \u2192 ...]). A valid solution must be a permutation of all cities.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 91, "total_chunks": 193}}, {"id": 605, "text": "A valid solution must be a permutation of all cities. Fitness Function: The total distance of a given route is calculated using the table above. The goal is to minimize the total distance. Selection Mechanism: Use Tournament Selection or Roulette Wheel Selection to choose the best routes. Crossover Operator: Use Partially Mapped Crossover (PMX) or Ordered Crossover (OX) to create new routes.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 92, "total_chunks": 193}}, {"id": 606, "text": "Crossover Operator: Use Partially Mapped Crossover (PMX) or Ordered Crossover (OX) to create new routes. Mutation Operator: Apply Swap Mutation (swap two random cities) or Scramble Mutation (shuffle a subset of cities). Termination Condition: Stop when the algorithm reaches a fixed number of generations or when the shortest route does not improve further.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 93, "total_chunks": 193}}, {"id": 607, "text": "Termination Condition: Stop when the algorithm reaches a fixed number of generations or when the shortest route does not improve further.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 94, "total_chunks": 193}}, {"id": 608, "text": "Implementing Connect Four with the Minimax algorithm provides an excellent opportunity to delve into the field of artificial intelligence and game theory. The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 95, "total_chunks": 193}}, {"id": 609, "text": "The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision. Learning Objectives Understanding Adversarial Games: Gain insights into adversarial games and the challenges involved in creating AI agents to play them.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 96, "total_chunks": 193}}, {"id": 610, "text": "Learning Objectives Understanding Adversarial Games: Gain insights into adversarial games and the challenges involved in creating AI agents to play them. Understand the concept of turn-based games and the opposing objectives of players in such games. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 97, "total_chunks": 193}}, {"id": 611, "text": "2. Implementing Game Logic: Learn how to implement the rules and mechanics of Connect Four, including the game board representation, legal moves, and win conditions. Gain proficiency in programming fundamentals by translating game rules into code. Exploring the Minimax Algorithm: Understand the Minimax algorithm and its application in decision-making for adversarial games.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 98, "total_chunks": 193}}, {"id": 612, "text": "Exploring the Minimax Algorithm: Understand the Minimax algorithm and its application in decision-making for adversarial games. Learn how Minimax traverses the game tree, evaluates potential moves, and selects the optimal strategy while considering both player's objectives.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 99, "total_chunks": 193}}, {"id": 613, "text": "Learn how Minimax traverses the game tree, evaluates potential moves, and selects the optimal strategy while considering both player's objectives. Handling Game State and Tree Traversal: Develop skills in managing game state representation and traversing the game tree efficiently.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 100, "total_chunks": 193}}, {"id": 614, "text": "Handling Game State and Tree Traversal: Develop skills in managing game state representation and traversing the game tree efficiently. Learn how to generate successor states, evaluate game states, and backtrack through the tree during the Minimax search. Optimizing with Alpha-Beta Pruning: Explore optimization techniques like alpha-beta pruning to improve the efficiency of the Minimax algorithm.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 101, "total_chunks": 193}}, {"id": 615, "text": "Optimizing with Alpha-Beta Pruning: Explore optimization techniques like alpha-beta pruning to improve the efficiency of the Minimax algorithm. Understand how pruning eliminates unnecessary branches of the game tree, reducing the computational complexity of the search. Testing and Evaluation: Learn how to test and evaluate the effectiveness of the Minimax-based Connect Four AI agent.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 102, "total_chunks": 193}}, {"id": 616, "text": "Testing and Evaluation: Learn how to test and evaluate the effectiveness of the Minimax-based Connect Four AI agent. Assess the agent's performance against human players or other AI agents, analyze its decision-making process, and identify areas for improvement. Setup: The game board is positioned vertically, with six rows and seven columns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 103, "total_chunks": 193}}, {"id": 617, "text": "Setup: The game board is positioned vertically, with six rows and seven columns. Each player is assigned a color, typically red and yellow. But this time we choose Green and Yellow instead. The game begins with an empty board. Gameplay: Players take turns dropping one of their colored discs into any column of the board. The disc falls to the lowest available empty cell in the selected column.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 104, "total_chunks": 193}}, {"id": 618, "text": "The disc falls to the lowest available empty cell in the selected column. Players alternate turns until one player achieves a winning four-in-a-row line or the board is completely filled without a winner (resulting in a draw). Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 105, "total_chunks": 193}}, {"id": 619, "text": "Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally. The game ends immediately once a winning condition is met. Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 106, "total_chunks": 193}}, {"id": 620, "text": "Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four). The choice of colors for Player 1 and Player 2 (e.g., \"Green\" and \"Yellow\"). The option to choose between two human players or one human player and one AI player. Game must include both options. Output: Display the game board after each move.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 107, "total_chunks": 193}}, {"id": 621, "text": "Output: Display the game board after each move. Inform the players when a player wins, loses, or when the game ends in a draw. Prompt the players for their moves (column number to drop their disc into). 3. INITIALIZATION: Create a 2D array to represent the game board with the specified number of rows and columns. Initialize the game board with empty cells. Assign colors to Player 1 and Player 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 108, "total_chunks": 193}}, {"id": 622, "text": "Assign colors to Player 1 and Player 2. 4. MAIN LOOP: 1. Display the initial empty game board. 2. Repeat the following steps until the game ends: - Prompt the current player for their move (column number to drop their disc into). - Update the game board with the player's move. - Check for a winning condition (four connected discs in a row).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 109, "total_chunks": 193}}, {"id": 623, "text": "- Check for a winning condition (four connected discs in a row). - If a winning condition is met, declare the current player as the winner and end the game. - Check for a draw condition (all cells on the board are filled without a winner). - If a draw condition is met, end the game with a draw. - Switch to the next player. 5. TERMINATION: Display the final game board.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 110, "total_chunks": 193}}, {"id": 624, "text": "TERMINATION: Display the final game board. If a player wins, announce the winner. If the game ends in a draw, announce the draw. End the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 111, "total_chunks": 193}}, {"id": 625, "text": "End the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 112, "total_chunks": 193}}, {"id": 626, "text": "It can be implemented in various programming languages, adapting the syntax and specific functionalities accordingly. Task Implement the above algorithm in Python for the following problem the Connect -Four Game for a grid of 12X12. Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 113, "total_chunks": 193}}, {"id": 627, "text": "Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color. Code Solution Below code sets up a Connect Four game board using Python\u2019s tkinter library, allowing play against an AI opponent. The game initializes a 12x12 board with players represented by different colors. Note: kinter is Python\u2019s standard library for creating graphical user interfaces (GUIs).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 114, "total_chunks": 193}}, {"id": 628, "text": "Note: kinter is Python\u2019s standard library for creating graphical user interfaces (GUIs). It allows you to build windows, buttons, labels, and other elements for desktop applications easily. In this Connect Four game, tkinter is used to create the game window and buttons for the board.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 115, "total_chunks": 193}}, {"id": 629, "text": "In this Connect Four game, tkinter is used to create the game window and buttons for the board. This function creates the game interface widgets (buttons and cells) for a grid-based game, likely Connect Four, where buttons are placed at the top of each column and cells form the playing grid below.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 116, "total_chunks": 193}}, {"id": 630, "text": "This function creates the game interface widgets (buttons and cells) for a grid-based game, likely Connect Four, where buttons are placed at the top of each column and cells form the playing grid below. This function handles a player's move in the game, checks for a win/draw, switches turns, and triggers the AI move if playing against the computer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 117, "total_chunks": 193}}, {"id": 631, "text": "This function handles a player's move in the game, checks for a win/draw, switches turns, and triggers the AI move if playing against the computer. This function executes the AI's move using the minimax algorithm with alpha-beta pruning, updates the game state, checks for a win/draw, and switches turns if the game continues.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 118, "total_chunks": 193}}, {"id": 632, "text": "This function executes the AI's move using the minimax algorithm with alpha-beta pruning, updates the game state, checks for a win/draw, and switches turns if the game continues. Attempts to place a player's piece in the lowest empty row of the specified column, updates the board, and returns True if successful; otherwise returns False.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 119, "total_chunks": 193}}, {"id": 633, "text": "Attempts to place a player's piece in the lowest empty row of the specified column, updates the board, and returns True if successful; otherwise returns False. Visually updates a game cell with a colored disc (green for PLAYER_A, yellow for PLAYER_B) to reflect the current move. Switches the current player's turn between PLAYER_A and PLAYER_B.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 120, "total_chunks": 193}}, {"id": 634, "text": "Switches the current player's turn between PLAYER_A and PLAYER_B. This function checks if the specified player has won by connecting four pieces in a row horizontally, vertically, or diagonally on the game board, returning True if a winning line is found. Checks if the game is a draw by verifying if the top row of the board is completely filled (no valid moves left).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 121, "total_chunks": 193}}, {"id": 635, "text": "Checks if the game is a draw by verifying if the top row of the board is completely filled (no valid moves left). Displays a \"Game Over\" message box with the given message and closes the game window. Returns a list of columns where a piece can still be placed (columns with at least one empty space in the top row).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 122, "total_chunks": 193}}, {"id": 636, "text": "Returns a list of columns where a piece can still be placed (columns with at least one empty space in the top row). Implements the minimax algorithm with alpha-beta pruning to determine the AI's optimal move, evaluating possible future board states recursively. Initializes and launches a 12x12 Connect Four game window in either Player vs Player or Player vs AI mode, based on the user's choice.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 123, "total_chunks": 193}}, {"id": 637, "text": "Initializes and launches a 12x12 Connect Four game window in either Player vs Player or Player vs AI mode, based on the user's choice. The game mode is selected via a console prompt. Mode Selection Prompt Displays a menu to choose between Player vs Player (1) or Player vs AI (2), then starts the game with the selected mode or reports an invalid input.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 124, "total_chunks": 193}}, {"id": 638, "text": "Mode Selection Prompt Displays a menu to choose between Player vs Player (1) or Player vs AI (2), then starts the game with the selected mode or reports an invalid input. Output We can select any of the two options: Lets say we go with option 2 to play with AI Agent. Tkinter GUI for the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 125, "total_chunks": 193}}, {"id": 639, "text": "Tkinter GUI for the game. Lab Week # 08 Artificial Intelligence Computer Science, Semester 6 th , Spring 2025 LAB 08: Implement the Class Scheduling using Constraint Satisfaction Problem Introduction In real-world scenarios, e.g. class scheduling, we often face constraints that make manual planning difficult.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 126, "total_chunks": 193}}, {"id": 640, "text": "class scheduling, we often face constraints that make manual planning difficult. Constraint Satisfaction Problems (CSPs) offer a structured way to model such problems using variables, domains, and constraints. In this lab, you will solve a simplified class scheduling problem using Python. Learning Objectives 1. Understand how to model real-world problems as CSPs. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 127, "total_chunks": 193}}, {"id": 641, "text": "2. Define variables, domains, and constraints in a CSP context. 3. Implement a CSP solver using either custom backtracking or a CSP library. 4. Generate and validate a schedule that satisfies all given constraints. Setup: 1. Python 3.x 2. Library: python-constraint (pip install python-constraint) 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 128, "total_chunks": 193}}, {"id": 642, "text": "Library: python-constraint (pip install python-constraint) 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 129, "total_chunks": 193}}, {"id": 643, "text": "Schedule 3 courses (C1, C2, C3) in 3 time slots (T1, T2, T3) and 2 rooms (R1, R2) while satisfying the following: Constraints: 1. No two courses should occupy the same room at the same time. 2. C1 and C2 should not occur at the same time (they share students). 3. C3 must be in Room R2 only. 4. Each course should have exactly one time slot and one room.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 130, "total_chunks": 193}}, {"id": 644, "text": "Each course should have exactly one time slot and one room.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 131, "total_chunks": 193}}, {"id": 645, "text": "Algorithm (General CSP Solver for Class Scheduling) Input: \uf0b7 Courses = {C1, C2, C3} \uf0b7 Time Slots = {T1, T2, T3} \uf0b7 Rooms = {R1, R2} \uf0b7 Constraints as defined above Output: \uf0b7 A valid assignment of (Time, Room) for each Course satisfying all constraints Code Task A This Python code defines a constraint satisfaction problem using the `python-constraint` library.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 132, "total_chunks": 193}}, {"id": 646, "text": "It schedules 3 courses (`C1`, `C2`, `C3`) into available time slots (`T1`, `T2`, `T3`) and rooms (`R1`, `R2`) such that no two courses overlap in the same room at the same time. The `no_overlap` function ensures each course gets a unique (time, room) pair. It continues the course scheduling problem by adding additional constraints.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 133, "total_chunks": 193}}, {"id": 647, "text": "It continues the course scheduling problem by adding additional constraints. It ensures that: Courses C1 and C2 cannot be scheduled at the same time, even in different rooms. Course C3 must be scheduled in Room R2 only. Output Task A Task B Add a 4th course, and include a new constraint: No teacher should be assigned to more than one course at the same time.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 134, "total_chunks": 193}}, {"id": 648, "text": "Output Task A Task B Add a 4th course, and include a new constraint: No teacher should be assigned to more than one course at the same time. (Assume teachers are T1, T2, T3.) Code Task B It solves a course scheduling problem using constraint satisfaction.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 135, "total_chunks": 193}}, {"id": 649, "text": "(Assume teachers are T1, T2, T3.) Code Task B It solves a course scheduling problem using constraint satisfaction. It assigns time slots and rooms to courses while ensuring: No overlapping room/time assignments (Constraint 1), Specific course constraints (e.g., C3 in R2, teacher T1's courses not overlapping). The solution is printed if valid, otherwise, it reports no valid schedule.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 136, "total_chunks": 193}}, {"id": 650, "text": "The solution is printed if valid, otherwise, it reports no valid schedule. Output Task B Lab Week # 09 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 09: Implement the real world problem with Bayesian Network Introduction In real-world scenarios, e.g.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 137, "total_chunks": 193}}, {"id": 651, "text": "Output Task B Lab Week # 09 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 09: Implement the real world problem with Bayesian Network Introduction In real-world scenarios, e.g.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 138, "total_chunks": 193}}, {"id": 652, "text": "class scheduling, we often face constraints that make manual planning Bayesian Networks (BNs) are powerful probabilistic models that represent dependencies among variables using directed acyclic graphs (DAGs). They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 139, "total_chunks": 193}}, {"id": 653, "text": "They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence. In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 140, "total_chunks": 193}}, {"id": 654, "text": "In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 141, "total_chunks": 193}}, {"id": 655, "text": "At the heart of these networks lies a crucial component known as the activation function. Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 142, "total_chunks": 193}}, {"id": 656, "text": "Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships. An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 143, "total_chunks": 193}}, {"id": 657, "text": "An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer. The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 144, "total_chunks": 193}}, {"id": 658, "text": "The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer. However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 145, "total_chunks": 193}}, {"id": 659, "text": "However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems. Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 146, "total_chunks": 193}}, {"id": 660, "text": "Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns. They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 147, "total_chunks": 193}}, {"id": 661, "text": "They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics. By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 148, "total_chunks": 193}}, {"id": 662, "text": "By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance. There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 149, "total_chunks": 193}}, {"id": 663, "text": "There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 150, "total_chunks": 193}}, {"id": 664, "text": "Choosing the appropriate activation function is critical, as it affects the network's convergence speed, stability, and overall performance. The selection often depends on the specific problem being addressed and the characteristics of the data.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 151, "total_chunks": 193}}, {"id": 665, "text": "The selection often depends on the specific problem being addressed and the characteristics of the data. Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 152, "total_chunks": 193}}, {"id": 666, "text": "Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications. Algorithm: Activation functions Sigmoid Activation Function Definition: The Sigmoid function, also known as the logistic function, maps any input to a value between 0 and 1. It is defined as: 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 153, "total_chunks": 193}}, {"id": 667, "text": "It is defined as: 2. ReLU (Rectified Linear Unit) Activation Function Definition: The ReLU function is defined as: 3. Tanh (Hyperbolic Tangent) Activation Function Definition: The Tanh function maps the input to a value between -1 and 1. It is defined as: These activation functions are foundational to neural network design, each with its specific strengths and trade-offs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 154, "total_chunks": 193}}, {"id": 668, "text": "It is defined as: These activation functions are foundational to neural network design, each with its specific strengths and trade-offs. Understanding their characteristics helps in choosing the right activation function for a given task and architecture.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 155, "total_chunks": 193}}, {"id": 669, "text": "Understanding their characteristics helps in choosing the right activation function for a given task and architecture. Code Solution OUPUT: Task 2 Bias Detection in Activation Functions Hypothesis: \"Activation functions introduce bias by favoring certain output ranges, which may skew predictions.\" Steps: 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 156, "total_chunks": 193}}, {"id": 670, "text": "Code Solution OUPUT: Task 2 Bias Detection in Activation Functions Hypothesis: \"Activation functions introduce bias by favoring certain output ranges, which may skew predictions.\" Steps: 1. Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 157, "total_chunks": 193}}, {"id": 671, "text": "Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2. Train a single-neuron ANN (no hidden layers) using each activation function. 3. Analyze bias by comparing: - Output distribution (histogram of predictions). - Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 158, "total_chunks": 193}}, {"id": 672, "text": "- Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 159, "total_chunks": 193}}, {"id": 673, "text": "Which activation function amplified bias the most? Why? ReLU amplified bias the most. It outputs zero for all negative inputs, causing Class B (centered around -2) to collapse to near-zero outputs, while Class A remains distinct. This harsh threshold leads to amplified separation between the classes. 2. How did the bias term affect ReLU vs. Sigmoid?", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 160, "total_chunks": 193}}, {"id": 674, "text": "Sigmoid? ReLU: The bias term shifted the output range slightly but didn't eliminate the hard zero cutoff, so bias remained strong. Sigmoid: The bias term helped center the input distribution better within the sigmoid\u2019s responsive region, reducing extreme output differences between Class A and B more than ReLU. 3. Can activation functions themselves be a source of algorithmic bias? Yes.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 161, "total_chunks": 193}}, {"id": 675, "text": "Yes. Activation functions like ReLU inherently suppress negative inputs, which may skew predictions if one class predominantly has such values. This can lead to algorithmic bias, even when the model is simple and unbiased in design.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 162, "total_chunks": 193}}, {"id": 676, "text": "This can lead to algorithmic bias, even when the model is simple and unbiased in design.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 163, "total_chunks": 193}}, {"id": 677, "text": "Lab Week # 11 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 11: Building an NLP Pipeline \u2013 From Text to Intelligence using python Introduction Natural Language Processing (NLP) is a core area of Artificial Intelligence that enables machines to understand, interpret, and generate human language.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 164, "total_chunks": 193}}, {"id": 678, "text": "In this hands-on lab, you will walk through the complete NLP pipeline\u2014from raw text to classification\u2014using Python. You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 165, "total_chunks": 193}}, {"id": 679, "text": "You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing. By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 166, "total_chunks": 193}}, {"id": 680, "text": "By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language. Algorithm Steps: 1. Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 167, "total_chunks": 193}}, {"id": 681, "text": "Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels. Example: data = [ (&quot;I loved the movie, it was fantastic!&quot;, &quot;Positive&quot;), (&quot;The film was boring and slow&quot;, &quot;Negative&quot;), # Add more samples... ] 2. Preprocessing Pipeline a. Tokenization Split each review into individual words. b.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 168, "total_chunks": 193}}, {"id": 682, "text": "b. Stopword Removal Remove common words like \u201cthe\u201d, \u201cis\u201d, \u201cand\u201d, using NLTK or spaCy. c. Lemmatization Convert words to their base forms (e.g., running\u2192 run). Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 169, "total_chunks": 193}}, {"id": 683, "text": "Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer 3. Vectorization Convert cleaned text into numerical format using: CountVectorizer or TF-IDF Vectorizer from sklearn.feature_extraction.text import CountVectorizer 4. Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 170, "total_chunks": 193}}, {"id": 684, "text": "Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment. from sklearn.naive_bayes import MultinomialNB from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score Evaluate Check accuracy on test data. Print 2\u20133 predictions for new reviews. Expected Output Cleaned and lemmatized reviews.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 171, "total_chunks": 193}}, {"id": 685, "text": "Expected Output Cleaned and lemmatized reviews. A table showing transformed text vectors. Model accuracy score (e.g., 85%). Example predictions: Review: \u201cAbsolutely amazing film\u201d \u2192 Positive Review: \u201cTerrible and dull\u201d \u2192 Negative Code Solution First of all we imported all the important libraries. NLTK stands for Natural Language Toolkit which is used for NLP (Natural Language processing) Tasks.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 172, "total_chunks": 193}}, {"id": 686, "text": "NLTK stands for Natural Language Toolkit which is used for NLP (Natural Language processing) Tasks. NLTK helps the program to understand, process, and analyze human language (Text or speech).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 173, "total_chunks": 193}}, {"id": 687, "text": "NLTK helps the program to understand, process, and analyze human language (Text or speech). We then took some dummy data to train our model, as we are just practicing so this is a very small dataset which is just for learning purpose so may be our model is not completely or very accurately train as we have very small dataset.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 174, "total_chunks": 193}}, {"id": 688, "text": "We then took some dummy data to train our model, as we are just practicing so this is a very small dataset which is just for learning purpose so may be our model is not completely or very accurately train as we have very small dataset. The data set contains both positive and negative reviews to train our model for future predictions on new unseen data. It reduces the words to root form.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 175, "total_chunks": 193}}, {"id": 689, "text": "It reduces the words to root form. Converts the words back to base. Removes stopwords and punctuations. Vectorization converts the words into numeric form so that our model can understand it. We then split the dataset, some for training and remaining for testing so we can use it for future predictions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 176, "total_chunks": 193}}, {"id": 690, "text": "We then split the dataset, some for training and remaining for testing so we can use it for future predictions. Evaluate the model by checking its prediction accuracy rate, in our taken dataset the accuracy for this model is 45.45%. Then we added some data to predict it by the model. Output We can see the model has predicted the reviews accuractely.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 177, "total_chunks": 193}}, {"id": 691, "text": "Output We can see the model has predicted the reviews accuractely. Note: Earlier I took a very smaller dataset even smaller than the current one, I observed that their result comes out to be wrong, that predicted the sentiment about the reviews wrong, this was because of our smaller dataset. The larger will be the dataset, the more accurate will be model predictions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 178, "total_chunks": 193}}, {"id": 692, "text": "The larger will be the dataset, the more accurate will be model predictions. Moreover, Other better NLP algorithms like Logistic Regression can be used to avoid such situations as LR is better than the current model. Lab Week # 12 Artificial Intelligence Computer Science, Semester 6th, Spring 2025 LAB 12: Image Classification Using Artificial Neural Networks (ANN).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 179, "total_chunks": 193}}, {"id": 693, "text": "Lab Week # 12 Artificial Intelligence Computer Science, Semester 6th, Spring 2025 LAB 12: Image Classification Using Artificial Neural Networks (ANN). Introduction In this lab, students will build an Artificial Neural Network (ANN) to classify handwritten digits (0\u20139) using the MNIST dataset. Students will train the model, evaluate its accuracy, and test it with their own handwritten digit.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 180, "total_chunks": 193}}, {"id": 694, "text": "Students will train the model, evaluate its accuracy, and test it with their own handwritten digit. Setup: Dataset MNIST Dataset: (given in separate file. 70,000 grayscale images (28\u00d728 pixels). 60,000 training + 10,000 test samples. Each pixel value: 0 (black) to 255 (white).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 181, "total_chunks": 193}}, {"id": 695, "text": "Each pixel value: 0 (black) to 255 (white). Library: TensorFlow/Keras, Matplotlib Editor: Any Python-supported IDE or Jupyter Notebook, Google Colab Steps:Algorithm: Step 1. Data Loading & Preprocessing: Load MNIST dataset (60,000 training + 10,000 test images). Normalize pixel values (0\u2013255 \u2192 0\u20131). Reshape images for ANN input (flatten 28x28 \u2192 784 pixels).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 182, "total_chunks": 193}}, {"id": 696, "text": "Reshape images for ANN input (flatten 28x28 \u2192 784 pixels). One-hot encode labels (e.g., \"3\" \u2192 [0,0,0,1,0,0,0,0,0,0]). Step 2. Model Architecture (ANN): Input Layer: 784 neurons (1 per pixel). Hidden Layer(s): 1\u20132 dense layers with ReLU activation. Output Layer: 10 neurons (Softmax activation for probability distribution). Step 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 183, "total_chunks": 193}}, {"id": 697, "text": "Step 3. Training & Evaluation: Compile model with `adam` optimizer and `categorical_crossentropy` loss. Train for 5\u201310 epochs and validate on test data. Evaluate accuracy and confusion matrix. Step 4. Custom Digit Testing: Draw a digit (using `matplotlib` or external image). Preprocess and predict using the trained model.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 184, "total_chunks": 193}}, {"id": 698, "text": "Preprocess and predict using the trained model. Code Solution Imported Important Libraries It imports essential libraries for data manipulation (pandas, numpy), visualization (matplotlib), and building neural networks using TensorFlow/Keras (Sequential, Dense, to_categorical, and SGD). These imports set the foundation for a machine learning project.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 185, "total_chunks": 193}}, {"id": 699, "text": "These imports set the foundation for a machine learning project. load_data() function This function loads and preprocesses the training and test data from CSV files, separating features and labels, and normalizing pixel values to the range [0, 1].", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 186, "total_chunks": 193}}, {"id": 700, "text": "load_data() function This function loads and preprocesses the training and test data from CSV files, separating features and labels, and normalizing pixel values to the range [0, 1].", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 187, "total_chunks": 193}}, {"id": 701, "text": "build_model(input_shape) function: This function builds and compiles a deep neural network with three hidden layers using ReLU activation and an output layer with softmax for multi-class classification of digits (0\u20139). display_sample_predictions The function visualizes grayscale image predictions using matplotlib.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 188, "total_chunks": 193}}, {"id": 702, "text": "display_sample_predictions The function visualizes grayscale image predictions using matplotlib. main() Function This main function loads data, trains a model, and plots training vs validation accuracy over epochs. Calling the main function Output Predictions Lab Evaluation Summary Student Name | Syed Hasnain Ali Shah Rehistration | 22 PWBCS 0919 Department | CS & IT Instructor | Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 189, "total_chunks": 193}}, {"id": 703, "text": "Calling the main function Output Predictions Lab Evaluation Summary Student Name | Syed Hasnain Ali Shah Rehistration | 22 PWBCS 0919 Department | CS & IT Instructor | Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 190, "total_chunks": 193}}, {"id": 704, "text": "| Image Classification Using Artificial Neural Networks (ANN). | 26 May, 2025 13 | Mini Project-RAG System | Mini Project-RAG System 14 | Mini Project-RAG System | Mini Project-RAG System", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 191, "total_chunks": 193}}, {"id": 705, "text": "| 26 May, 2025 13 | Mini Project-RAG System | Mini Project-RAG System 14 | Mini Project-RAG System | Mini Project-RAG System", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 192, "total_chunks": 193}}, {"id": 706, "text": "DEPARTMENT OF COMPUTER SCIENCE & INFORMATION TECHNOLOGY UNIVERSITY OF ENGINEERING & TECHNOLOGY, PESHAWAR Lab Manual BS(CS) Spring 2025 Artificial Intelligence Subject: Artificial Intelligence (Lab) Code: CS- 401 (L) Instructor: Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 0, "total_chunks": 193}}, {"id": 707, "text": "Wajeeha Khalil Session: 2025 Semester (S/F): 6th (Spring) Lab Week # 01 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 01: Implement Breadth-First Search BFS using Python Introduction Breadth-First Search (BFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 1, "total_chunks": 193}}, {"id": 708, "text": "It operates by visiting all nodes in a graph level by level, starting from a designated source node.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 2, "total_chunks": 193}}, {"id": 709, "text": "Learn how to represent problem domains and states for BFS-based intelligent agents. Gain proficiency in implementing BFS algorithm to explore state spaces efficiently. Develop problem-solving skills by applying BFS to various scenarios and domains in AI.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 3, "total_chunks": 193}}, {"id": 710, "text": "Develop problem-solving skills by applying BFS to various scenarios and domains in AI. Appreciate the importance of search algorithms in building intelligent agents capable of navigating complex environments and achieving desired goals.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 4, "total_chunks": 193}}, {"id": 711, "text": "Appreciate the importance of search algorithms in building intelligent agents capable of navigating complex environments and achieving desired goals. Steps: Algorithm: Breadth-First Search (BFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 5, "total_chunks": 193}}, {"id": 712, "text": "Steps: Algorithm: Breadth-First Search (BFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 6, "total_chunks": 193}}, {"id": 713, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Dequeue a state current_state from the frontier. If current_state is the goal state, return the path to current_state. Add current_state to the explored set.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 7, "total_chunks": 193}}, {"id": 714, "text": "Add current_state to the explored set. For each action a in the set of legal actions applicable to current_state: Calculate the successor state next_state by applying action a to current_state. If next_state is not in frontier or explored: Enqueue next_state onto the frontier. Set the parent of next_state to current_state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 8, "total_chunks": 193}}, {"id": 715, "text": "Set the parent of next_state to current_state. Termination: If the frontier becomes empty without finding the goal state, return failure. Explanation: The algorithm starts by initializing a queue (frontier) to store states to be explored and a set (explored) to keep track of visited states. It continues to dequeue states from the frontier and explores their successors by applying legal actions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 9, "total_chunks": 193}}, {"id": 716, "text": "It continues to dequeue states from the frontier and explores their successors by applying legal actions. If a successor state has not been visited before, it is enqueued onto the frontier. The algorithm terminates either when the goal state is found or when the frontier becomes empty.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 10, "total_chunks": 193}}, {"id": 717, "text": "The algorithm terminates either when the goal state is found or when the frontier becomes empty. If the goal state is found, the algorithm backtracks from the goal state to the initial state using parent pointers to construct the solution path. Note: Refer to the generalized Algorithm studied in theory class for more understanding.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 11, "total_chunks": 193}}, {"id": 718, "text": "Note: Refer to the generalized Algorithm studied in theory class for more understanding. Task Implement the above algorithm in Python for the following problem where 12 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 12, "total_chunks": 193}}, {"id": 719, "text": "Task Implement the above algorithm in Python for the following problem where 12 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 13, "total_chunks": 193}}, {"id": 720, "text": "Solution: Importing Required Libraries: Networkx: Library used for the graph creation Matplotlib: Library used for plotting the graph dequeue: A queue from collection library for visiting the nodes Breadth First Search Implementation Part: The BFS algorithm is implemented using a queue (FIFO structure). It explores the graph level by level before moving deeper.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 14, "total_chunks": 193}}, {"id": 721, "text": "It explores the graph level by level before moving deeper.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 15, "total_chunks": 193}}, {"id": 722, "text": "Unlike BFS, which explores nodes level by level, DFS explores as far as possible along each branch before backtracking.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 16, "total_chunks": 193}}, {"id": 723, "text": "DFS is widely employed in AI applications such as: Pathfinding State space exploration Solving Puzzle and Mazes By traversing the graph depth-wise, DFS is particularly useful for exploring all possible paths in a graph, making it ideal for problems like cycle detection, topological sorting, and solving constraint satisfaction problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 17, "total_chunks": 193}}, {"id": 724, "text": "Learning Objectives Understand the steps involved in Depth-First Search for solving AI problems. Learn how to represent problem domains and states for DFS-based intelligent agents. Gain proficiency in implementing the DFS algorithm to explore state spaces efficiently. Develop problem-solving skills by applying DFS to various AI scenarios.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 18, "total_chunks": 193}}, {"id": 725, "text": "Develop problem-solving skills by applying DFS to various AI scenarios. Appreciate the importance of search algorithms in building intelligent agents. Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 19, "total_chunks": 193}}, {"id": 726, "text": "Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 20, "total_chunks": 193}}, {"id": 727, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Pop a node (current_node) from the frontier. If current_node is the goal node, return the path to current_node. Add current_node to the explored set.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 21, "total_chunks": 193}}, {"id": 728, "text": "Add current_node to the explored set. For each neighbor of current_node: If the neighbor is not in frontier or explored: Push the neighbor onto the frontier. Set the parent of the neighbor to current_node. Termination: If the frontier becomes empty without finding the goal node, return failure.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 22, "total_chunks": 193}}, {"id": 729, "text": "Termination: If the frontier becomes empty without finding the goal node, return failure. Explanation: break down the provided Breadth-First Search (BFS) algorithm for intelligent agents step by step: Initialization: We start by initializing a queue named frontier to keep track of states to be explored. We enqueue the initial state onto the frontier.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 23, "total_chunks": 193}}, {"id": 730, "text": "We enqueue the initial state onto the frontier. An empty set explored is created to store visited states. Main Loop: We enter a loop that continues until the frontier is not empty. Within each iteration of the loop: We dequeue a state current_state from the frontier. We check if current_state is the goal state by calling the Problem.goal_test(current_state) function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 24, "total_chunks": 193}}, {"id": 731, "text": "We check if current_state is the goal state by calling the Problem.goal_test(current_state) function. If it is, we return the path to this state. If current_state is not the goal state, we mark it as explored by adding it to the explored set. We iterate over all applicable actions for the current_state by calling Problem.actions(current_state).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 25, "total_chunks": 193}}, {"id": 732, "text": "We iterate over all applicable actions for the current_state by calling Problem.actions(current_state). For each action: We calculate the successor state next_state by applying the action to the current_state using the Problem.result(current_state, action) function. If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 26, "total_chunks": 193}}, {"id": 733, "text": "If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier. We set the parent of next_state to current_state. This step is crucial for reconstructing the path once the goal state is found.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 27, "total_chunks": 193}}, {"id": 734, "text": "This step is crucial for reconstructing the path once the goal state is found. Termination: If the frontier becomes empty without finding the goal state, we return failure, indicating that the goal state is unreachable from the initial state. Output: If the goal state is found during the search, we return the path from the initial state to the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 28, "total_chunks": 193}}, {"id": 735, "text": "Output: If the goal state is found during the search, we return the path from the initial state to the goal state. This path can be constructed by following the parent pointers from the goal state back to the initial state. Note: Refer to the generalized Algorithm studied in theory class for more understanding.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 29, "total_chunks": 193}}, {"id": 736, "text": "Note: Refer to the generalized Algorithm studied in theory class for more understanding. Task Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 30, "total_chunks": 193}}, {"id": 737, "text": "Task Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 31, "total_chunks": 193}}, {"id": 738, "text": "In this puzzle: A man wants to cross a river with three items: a wolf, a chicken, and a corn. The boat can carry a maximum of two entities (the man plus one item). Constraints: If the wolf and chicken are left alone without the man, the wolf will eat the chicken. If the chicken and corn are left alone without the man, the chicken will eat the corn.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 32, "total_chunks": 193}}, {"id": 739, "text": "If the chicken and corn are left alone without the man, the chicken will eat the corn. Your task is to help the man safely transport all items to the other side of the river without violating the constraints. Learning Objectives Understand the concept of state-space search in AI. Apply logical reasoning to solve constraint-based problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 33, "total_chunks": 193}}, {"id": 740, "text": "Apply logical reasoning to solve constraint-based problems. Implement a search algorithm (e.g., BFS or DFS) to find a valid sequence of moves. Develop problem-solving skills by exploring possible states and transitions. Problem Setup Entities: Man, Wolf, Chicken, Corn. Boat Capacity: Maximum of 2 (Man + 1 item). Constraints: Wolf cannot be left alone with Chicken.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 34, "total_chunks": 193}}, {"id": 741, "text": "Constraints: Wolf cannot be left alone with Chicken. Chicken cannot be left alone with Corn. State Representation Each state can be represented as a tuple: (Man, Wolf, Chicken, Corn) Man: Left or Right (side of the river). Wolf, Chicken, Corn: Left or Right (side of the river).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 35, "total_chunks": 193}}, {"id": 742, "text": "Wolf, Chicken, Corn: Left or Right (side of the river). Example: Initial State: ('Left', 'Left', 'Left', 'Left') Goal State: ('Right', 'Right', 'Right', 'Right') Task State-Space Search: Represent the problem as a state-space graph. Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 36, "total_chunks": 193}}, {"id": 743, "text": "Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions. Find a Valid Sequence: Find a sequence of moves that transports all items to the right side of the river without violating the constraints. Implement the Solution: Write a Python program to solve the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 37, "total_chunks": 193}}, {"id": 744, "text": "Implement the Solution: Write a Python program to solve the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 38, "total_chunks": 193}}, {"id": 745, "text": "In this implementation, we will focus on the 8-puzzle variant, where the puzzle is divided into a 3x3 grid with eight numbered tiles and one empty space. We'll use the A* search algorithm to efficiently find the shortest path from the initial state to the goal state. Learning Objectives Understand the N-Puzzle problem and its rules. Implement the A* search algorithm in Python.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 39, "total_chunks": 193}}, {"id": 746, "text": "Implement the A* search algorithm in Python. Learn how to represent states, actions, and transitions in the N-Puzzle problem. Gain experience in solving optimization problems using heuristic search techniques. Steps: Algorithm: A* search Input: Receive the initial and goal configurations of the puzzle. Output: Display the steps required to reach the goal state from the initial state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 40, "total_chunks": 193}}, {"id": 747, "text": "Output: Display the steps required to reach the goal state from the initial state. Initialization: Initialize the A* algorithm with the initial state, priority queue, and heuristic function. Main Loop: Iteratively expand nodes based on their estimated cost until the goal state is reached or no more nodes are left to explore.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 41, "total_chunks": 193}}, {"id": 748, "text": "Main Loop: Iteratively expand nodes based on their estimated cost until the goal state is reached or no more nodes are left to explore. Termination: Terminate the algorithm when the goal state is reached or when no solution is found. Explanation: 1. INPUT: Define the problem domain including the initial state and the goal state of the puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 42, "total_chunks": 193}}, {"id": 749, "text": "INPUT: Define the problem domain including the initial state and the goal state of the puzzle. Define the actions applicable to each state, the transition model, the goal test, and the cost function. 2. OUTPUT: Return the sequence of actions that lead from the initial state to the goal state. 3. INITIALIZATION: Initialize an empty priority queue frontier to store states to be explored.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 43, "total_chunks": 193}}, {"id": 750, "text": "INITIALIZATION: Initialize an empty priority queue frontier to store states to be explored. Enqueue the initial state onto the frontier with a priority of 0. Initialize an empty set explored to store visited states. 4. MAIN LOOP: While the frontier is not empty: Dequeue a state from the frontier. If the dequeued state is the goal state, return the sequence of actions leading to it.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 44, "total_chunks": 193}}, {"id": 751, "text": "If the dequeued state is the goal state, return the sequence of actions leading to it. Add the dequeued state to the explored set For each action applicable to the current state: Calculate the successor state by applying the action. If the successor state has not been explored or enqueued: Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 45, "total_chunks": 193}}, {"id": 752, "text": "If the successor state has not been explored or enqueued: Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic. Set the parent of the successor state to the current state. 5. TERMINATION: If the frontier becomes empty without finding the goal state, return failure.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 46, "total_chunks": 193}}, {"id": 753, "text": "TERMINATION: If the frontier becomes empty without finding the goal state, return failure. Explanation N-Puzzle or sliding puzzle is a popular puzzle that consists of N tiles where N can be 8, 15, 24 and so on. In our example N = 8. The puzzle is divided into sqrt(N+1) rows and sqrt(N+1) columns. Eg. 15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 47, "total_chunks": 193}}, {"id": 754, "text": "15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns. The puzzle consists of N tiles and one empty space where the tiles can be moved. Start and Goal configurations (also called state) of the puzzle are provided. The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 48, "total_chunks": 193}}, {"id": 755, "text": "The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration. Rules for solving the puzzle. Instead of moving the tiles in the empty space we can visualize moving the empty space in place of the tile, basically swapping the tile with the empty space. The empty space can only move in four directions viz., 1. Up 2.Down 3. Right or 4.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 49, "total_chunks": 193}}, {"id": 756, "text": "Right or 4. Left The empty space cannot move diagonally and can take only one step at a time (i.e. move the empty space one position at a time). The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 50, "total_chunks": 193}}, {"id": 757, "text": "The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state. The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 51, "total_chunks": 193}}, {"id": 758, "text": "The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution. It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 52, "total_chunks": 193}}, {"id": 759, "text": "It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems. A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 53, "total_chunks": 193}}, {"id": 760, "text": "A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search. It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 54, "total_chunks": 193}}, {"id": 761, "text": "It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node. Heuristic Cost (h): An estimated cost from the current node to the goal node (often called the heuristic function). The key to A*'s efficiency lies in its selection of nodes to explore.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 55, "total_chunks": 193}}, {"id": 762, "text": "The key to A*'s efficiency lies in its selection of nodes to explore. At each step, it chooses the node that minimizes the sum of the path cost g and the estimated remaining cost to the goal h (often represented as f = g + h). This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 56, "total_chunks": 193}}, {"id": 763, "text": "This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function. Task Implement the above algorithm in Python for the following problem the N-Puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 57, "total_chunks": 193}}, {"id": 764, "text": "Task Implement the above algorithm in Python for the following problem the N-Puzzle.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 58, "total_chunks": 193}}, {"id": 765, "text": "This lab explores solving TSP using the Simulated Annealing (SA) algorithm and analyzing its performance. Learning Objectives: Understand the concept of TSP and heuristic optimization. Implement Simulated Annealing (SA) for solving TSP. Analyze performance metrics such as path length and execution time. Compare SA with other optimization techniques. Algorithm: 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 59, "total_chunks": 193}}, {"id": 766, "text": "Algorithm: 1. Input: A set of cities with random (x, y) coordinates. Distance function (e.g., Euclidean distance) to evaluate the path cost. 2. Output: Optimized path with the shortest distance. Graphical representation of the final tour. 3. Initialization: Generate an initial random tour. Set initial temperature and cooling rate for Simulated Annealing. Define an acceptance probability function.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 60, "total_chunks": 193}}, {"id": 767, "text": "Define an acceptance probability function. 4. Main Loop: Iteratively swap cities in the tour to generate a new solution. Evaluate the cost difference between current and new solutions. Accept the new solution based on the probability function. Gradually reduce the temperature until termination conditions are met. 5. Termination: Stop when the temperature reaches a predefined threshold.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 61, "total_chunks": 193}}, {"id": 768, "text": "Termination: Stop when the temperature reaches a predefined threshold. Return the best solution found. Explanation: 1. INPUT: Number of cities (e.g., 20 for initial experiments, extendable to 100). Coordinate values for cities. Initial temperature, cooling rate, and maximum iterations. 2. OUTPUT: Optimized tour with minimal travel cost. Graphical visualization of the tour.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 62, "total_chunks": 193}}, {"id": 769, "text": "Graphical visualization of the tour. Execution time and convergence analysis. 3. INITIALIZATION: Generate a random initial tour. Define temperature and cooling schedule. Set an initial best cost value. 4. MAIN LOOP: Randomly select two cities and swap them. Calculate the new tour\u2019s total distance. Use Simulated Annealing acceptance criteria to decide whether to accept the new solution.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 63, "total_chunks": 193}}, {"id": 770, "text": "Use Simulated Annealing acceptance criteria to decide whether to accept the new solution. Decrease temperature iteratively. 5. TERMINATION: Stop when the temperature reaches near zero or after a fixed number of iterations. Return the best-found solution. Task Implement Simulated Annealing (SA) to solve TSP. Visualize the computed shortest tour.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 64, "total_chunks": 193}}, {"id": 771, "text": "Visualize the computed shortest tour. Analyze performance based on: Path length Execution time Number of iterations Extend the problem to 100 cities and compare results. Implement Tabu Search and evaluate its effectiveness against SA.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 65, "total_chunks": 193}}, {"id": 772, "text": "Implement Tabu Search and evaluate its effectiveness against SA. Code Solution Imported important Libraries Distance Calculation for TSP Total Distance Algorithm for Simulated Annealing Visualization Function Output SA for STP Tabu Search Implementation Visualization Output Comparison Simulated Annealing VS Tabu Search Comparison Table: Simulated Annealing vs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 66, "total_chunks": 193}}, {"id": 773, "text": "Code Solution Imported important Libraries Distance Calculation for TSP Total Distance Algorithm for Simulated Annealing Visualization Function Output SA for STP Tabu Search Implementation Visualization Output Comparison Simulated Annealing VS Tabu Search Comparison Table: Simulated Annealing vs. Tabu Search Short Report: Simulated Annealing vs. Tabu Search 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 67, "total_chunks": 193}}, {"id": 774, "text": "Tabu Search 1. Algorithm Explanation Simulated Annealing (SA): Simulated Annealing is a probabilistic optimization technique inspired by the annealing process in metallurgy. The algorithm starts with a high temperature, which gradually decreases. At each iteration, it explores a new solution by swapping two cities.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 68, "total_chunks": 193}}, {"id": 775, "text": "At each iteration, it explores a new solution by swapping two cities. If the new solution is better, it is accepted; otherwise, it may still be accepted with a probability that decreases over time. This helps avoid local optima and allows exploration of the solution space.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 69, "total_chunks": 193}}, {"id": 776, "text": "This helps avoid local optima and allows exploration of the solution space. Tabu Search (TS): Tabu Search is a local search method that enhances hill-climbing by maintaining a list of recently visited solutions (tabu list) to prevent cycling back to previous solutions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 70, "total_chunks": 193}}, {"id": 777, "text": "Tabu Search (TS): Tabu Search is a local search method that enhances hill-climbing by maintaining a list of recently visited solutions (tabu list) to prevent cycling back to previous solutions. It systematically explores the solution space by swapping cities and tracking the best solutions while avoiding short-term revisits. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 71, "total_chunks": 193}}, {"id": 778, "text": "2. Performance Analysis From the comparison table, we can analyze: Path Length: Simulated Annealing found a shorter path (643.42) compared to Tabu Search (382.94), indicating its better exploration capability. Execution Time: Simulated Annealing took 0.62 seconds, which is shorter than Tabu Search\u2019s 19.27 seconds due to more iterations and its probabilistic nature.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 72, "total_chunks": 193}}, {"id": 779, "text": "Execution Time: Simulated Annealing took 0.62 seconds, which is shorter than Tabu Search\u2019s 19.27 seconds due to more iterations and its probabilistic nature. Number of Iterations: SA runs significantly more iterations than TS, but this helps it avoid local optima and explore more of the solution space. 3. SA vs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 73, "total_chunks": 193}}, {"id": 780, "text": "SA vs. Tabu Search Comparison Lab Week # 06 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 06: Implementation of Genetic Algorithm Introduction The Traveling Salesman Problem (TSP) is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 74, "total_chunks": 193}}, {"id": 781, "text": "Tabu Search Comparison Lab Week # 06 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 06: Implementation of Genetic Algorithm Introduction The Traveling Salesman Problem (TSP) is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 75, "total_chunks": 193}}, {"id": 782, "text": "Genetic Algorithms (GAs) are evolutionary algorithms inspired by natural selection and genetics, commonly used to solve optimization and search problems. Learning Objectives Understand the application of Genetic Algorithms in solving optimization problems like the Traveling Salesman Problem. Learn about Roulette Wheel Selection Method for parent selection in Genetic Algorithms.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 76, "total_chunks": 193}}, {"id": 783, "text": "Learn about Roulette Wheel Selection Method for parent selection in Genetic Algorithms. Implement a basic Genetic Algorithm solution for the Traveling Salesman Problem in Python. Algorithm: Genetic Algorithm Input: A set of cities with their coordinates. Population size. Crossover rate. Mutation rate. Termination condition (e.g., maximum number of generations, convergence criteria).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 77, "total_chunks": 193}}, {"id": 784, "text": "Termination condition (e.g., maximum number of generations, convergence criteria). Output: The best route found (shortest tour) that visits each city exactly once and returns to the original city. Initialization: Create Initial Population: Generate an initial population of candidate solutions (chromosomes).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 78, "total_chunks": 193}}, {"id": 785, "text": "Initialization: Create Initial Population: Generate an initial population of candidate solutions (chromosomes). Each chromosome represents a possible route for the salesman, typically represented as a permutation of city indices. Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 79, "total_chunks": 193}}, {"id": 786, "text": "Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route. Main Loop: Repeat until Termination Condition is met: Selection: Perform Roulette Wheel Selection: Select parents for mating based on their fitness. The probability of selection is proportional to the fitness of each chromosome.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 80, "total_chunks": 193}}, {"id": 787, "text": "The probability of selection is proportional to the fitness of each chromosome. Crossover: Apply Crossover Operation: Generate offspring by combining genetic material (routes) from selected parents. Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 81, "total_chunks": 193}}, {"id": 788, "text": "Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc. Mutation: Introduce Mutation: Randomly alter some chromosomes in the offspring population to maintain diversity. For TSP, swapping cities in a route is a typical mutation. Evaluate Fitness: Calculate the fitness of each offspring. Replacement: Select individuals for the next generation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 82, "total_chunks": 193}}, {"id": 789, "text": "Replacement: Select individuals for the next generation. This could involve elitism (keeping the best solutions from the current generation) or replacing the entire population. Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 83, "total_chunks": 193}}, {"id": 790, "text": "Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations). Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 84, "total_chunks": 193}}, {"id": 791, "text": "Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation. Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 85, "total_chunks": 193}}, {"id": 792, "text": "Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation. Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 86, "total_chunks": 193}}, {"id": 793, "text": "Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP. The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 87, "total_chunks": 193}}, {"id": 794, "text": "The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city. Task Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 88, "total_chunks": 193}}, {"id": 795, "text": "Task Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment. The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 89, "total_chunks": 193}}, {"id": 796, "text": "The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point. The goal is to find the shortest route that minimizes fuel costs and travel time using a Genetic Algorithm (GA). List of Cities (Warehouses) in Pakistan.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 90, "total_chunks": 193}}, {"id": 797, "text": "List of Cities (Warehouses) in Pakistan. Consider 10 major cities with approximate road distances (in kilometers) between them: Formulation using Genetic Algorithm Chromosome Representation: Each chromosome represents a sequence of cities (e.g., [Karachi \u2192 Lahore \u2192 Islamabad \u2192 Quetta \u2192 ...]). A valid solution must be a permutation of all cities.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 91, "total_chunks": 193}}, {"id": 798, "text": "A valid solution must be a permutation of all cities. Fitness Function: The total distance of a given route is calculated using the table above. The goal is to minimize the total distance. Selection Mechanism: Use Tournament Selection or Roulette Wheel Selection to choose the best routes. Crossover Operator: Use Partially Mapped Crossover (PMX) or Ordered Crossover (OX) to create new routes.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 92, "total_chunks": 193}}, {"id": 799, "text": "Crossover Operator: Use Partially Mapped Crossover (PMX) or Ordered Crossover (OX) to create new routes. Mutation Operator: Apply Swap Mutation (swap two random cities) or Scramble Mutation (shuffle a subset of cities). Termination Condition: Stop when the algorithm reaches a fixed number of generations or when the shortest route does not improve further.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 93, "total_chunks": 193}}, {"id": 800, "text": "Termination Condition: Stop when the algorithm reaches a fixed number of generations or when the shortest route does not improve further.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 94, "total_chunks": 193}}, {"id": 801, "text": "Implementing Connect Four with the Minimax algorithm provides an excellent opportunity to delve into the field of artificial intelligence and game theory. The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 95, "total_chunks": 193}}, {"id": 802, "text": "The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision. Learning Objectives Understanding Adversarial Games: Gain insights into adversarial games and the challenges involved in creating AI agents to play them.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 96, "total_chunks": 193}}, {"id": 803, "text": "Learning Objectives Understanding Adversarial Games: Gain insights into adversarial games and the challenges involved in creating AI agents to play them. Understand the concept of turn-based games and the opposing objectives of players in such games. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 97, "total_chunks": 193}}, {"id": 804, "text": "2. Implementing Game Logic: Learn how to implement the rules and mechanics of Connect Four, including the game board representation, legal moves, and win conditions. Gain proficiency in programming fundamentals by translating game rules into code. Exploring the Minimax Algorithm: Understand the Minimax algorithm and its application in decision-making for adversarial games.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 98, "total_chunks": 193}}, {"id": 805, "text": "Exploring the Minimax Algorithm: Understand the Minimax algorithm and its application in decision-making for adversarial games. Learn how Minimax traverses the game tree, evaluates potential moves, and selects the optimal strategy while considering both player's objectives.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 99, "total_chunks": 193}}, {"id": 806, "text": "Learn how Minimax traverses the game tree, evaluates potential moves, and selects the optimal strategy while considering both player's objectives. Handling Game State and Tree Traversal: Develop skills in managing game state representation and traversing the game tree efficiently.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 100, "total_chunks": 193}}, {"id": 807, "text": "Handling Game State and Tree Traversal: Develop skills in managing game state representation and traversing the game tree efficiently. Learn how to generate successor states, evaluate game states, and backtrack through the tree during the Minimax search. Optimizing with Alpha-Beta Pruning: Explore optimization techniques like alpha-beta pruning to improve the efficiency of the Minimax algorithm.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 101, "total_chunks": 193}}, {"id": 808, "text": "Optimizing with Alpha-Beta Pruning: Explore optimization techniques like alpha-beta pruning to improve the efficiency of the Minimax algorithm. Understand how pruning eliminates unnecessary branches of the game tree, reducing the computational complexity of the search. Testing and Evaluation: Learn how to test and evaluate the effectiveness of the Minimax-based Connect Four AI agent.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 102, "total_chunks": 193}}, {"id": 809, "text": "Testing and Evaluation: Learn how to test and evaluate the effectiveness of the Minimax-based Connect Four AI agent. Assess the agent's performance against human players or other AI agents, analyze its decision-making process, and identify areas for improvement. Setup: The game board is positioned vertically, with six rows and seven columns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 103, "total_chunks": 193}}, {"id": 810, "text": "Setup: The game board is positioned vertically, with six rows and seven columns. Each player is assigned a color, typically red and yellow. But this time we choose Green and Yellow instead. The game begins with an empty board. Gameplay: Players take turns dropping one of their colored discs into any column of the board. The disc falls to the lowest available empty cell in the selected column.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 104, "total_chunks": 193}}, {"id": 811, "text": "The disc falls to the lowest available empty cell in the selected column. Players alternate turns until one player achieves a winning four-in-a-row line or the board is completely filled without a winner (resulting in a draw). Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 105, "total_chunks": 193}}, {"id": 812, "text": "Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally. The game ends immediately once a winning condition is met. Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 106, "total_chunks": 193}}, {"id": 813, "text": "Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four). The choice of colors for Player 1 and Player 2 (e.g., \"Green\" and \"Yellow\"). The option to choose between two human players or one human player and one AI player. Game must include both options. Output: Display the game board after each move.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 107, "total_chunks": 193}}, {"id": 814, "text": "Output: Display the game board after each move. Inform the players when a player wins, loses, or when the game ends in a draw. Prompt the players for their moves (column number to drop their disc into). 3. INITIALIZATION: Create a 2D array to represent the game board with the specified number of rows and columns. Initialize the game board with empty cells. Assign colors to Player 1 and Player 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 108, "total_chunks": 193}}, {"id": 815, "text": "Assign colors to Player 1 and Player 2. 4. MAIN LOOP: 1. Display the initial empty game board. 2. Repeat the following steps until the game ends: - Prompt the current player for their move (column number to drop their disc into). - Update the game board with the player's move. - Check for a winning condition (four connected discs in a row).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 109, "total_chunks": 193}}, {"id": 816, "text": "- Check for a winning condition (four connected discs in a row). - If a winning condition is met, declare the current player as the winner and end the game. - Check for a draw condition (all cells on the board are filled without a winner). - If a draw condition is met, end the game with a draw. - Switch to the next player. 5. TERMINATION: Display the final game board.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 110, "total_chunks": 193}}, {"id": 817, "text": "TERMINATION: Display the final game board. If a player wins, announce the winner. If the game ends in a draw, announce the draw. End the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 111, "total_chunks": 193}}, {"id": 818, "text": "End the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 112, "total_chunks": 193}}, {"id": 819, "text": "It can be implemented in various programming languages, adapting the syntax and specific functionalities accordingly. Task Implement the above algorithm in Python for the following problem the Connect -Four Game for a grid of 12X12. Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 113, "total_chunks": 193}}, {"id": 820, "text": "Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color. Code Solution Below code sets up a Connect Four game board using Python\u2019s tkinter library, allowing play against an AI opponent. The game initializes a 12x12 board with players represented by different colors. Note: kinter is Python\u2019s standard library for creating graphical user interfaces (GUIs).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 114, "total_chunks": 193}}, {"id": 821, "text": "Note: kinter is Python\u2019s standard library for creating graphical user interfaces (GUIs). It allows you to build windows, buttons, labels, and other elements for desktop applications easily. In this Connect Four game, tkinter is used to create the game window and buttons for the board.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 115, "total_chunks": 193}}, {"id": 822, "text": "In this Connect Four game, tkinter is used to create the game window and buttons for the board. This function creates the game interface widgets (buttons and cells) for a grid-based game, likely Connect Four, where buttons are placed at the top of each column and cells form the playing grid below.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 116, "total_chunks": 193}}, {"id": 823, "text": "This function creates the game interface widgets (buttons and cells) for a grid-based game, likely Connect Four, where buttons are placed at the top of each column and cells form the playing grid below. This function handles a player's move in the game, checks for a win/draw, switches turns, and triggers the AI move if playing against the computer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 117, "total_chunks": 193}}, {"id": 824, "text": "This function handles a player's move in the game, checks for a win/draw, switches turns, and triggers the AI move if playing against the computer. This function executes the AI's move using the minimax algorithm with alpha-beta pruning, updates the game state, checks for a win/draw, and switches turns if the game continues.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 118, "total_chunks": 193}}, {"id": 825, "text": "This function executes the AI's move using the minimax algorithm with alpha-beta pruning, updates the game state, checks for a win/draw, and switches turns if the game continues. Attempts to place a player's piece in the lowest empty row of the specified column, updates the board, and returns True if successful; otherwise returns False.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 119, "total_chunks": 193}}, {"id": 826, "text": "Attempts to place a player's piece in the lowest empty row of the specified column, updates the board, and returns True if successful; otherwise returns False. Visually updates a game cell with a colored disc (green for PLAYER_A, yellow for PLAYER_B) to reflect the current move. Switches the current player's turn between PLAYER_A and PLAYER_B.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 120, "total_chunks": 193}}, {"id": 827, "text": "Switches the current player's turn between PLAYER_A and PLAYER_B. This function checks if the specified player has won by connecting four pieces in a row horizontally, vertically, or diagonally on the game board, returning True if a winning line is found. Checks if the game is a draw by verifying if the top row of the board is completely filled (no valid moves left).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 121, "total_chunks": 193}}, {"id": 828, "text": "Checks if the game is a draw by verifying if the top row of the board is completely filled (no valid moves left). Displays a \"Game Over\" message box with the given message and closes the game window. Returns a list of columns where a piece can still be placed (columns with at least one empty space in the top row).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 122, "total_chunks": 193}}, {"id": 829, "text": "Returns a list of columns where a piece can still be placed (columns with at least one empty space in the top row). Implements the minimax algorithm with alpha-beta pruning to determine the AI's optimal move, evaluating possible future board states recursively. Initializes and launches a 12x12 Connect Four game window in either Player vs Player or Player vs AI mode, based on the user's choice.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 123, "total_chunks": 193}}, {"id": 830, "text": "Initializes and launches a 12x12 Connect Four game window in either Player vs Player or Player vs AI mode, based on the user's choice. The game mode is selected via a console prompt. Mode Selection Prompt Displays a menu to choose between Player vs Player (1) or Player vs AI (2), then starts the game with the selected mode or reports an invalid input.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 124, "total_chunks": 193}}, {"id": 831, "text": "Mode Selection Prompt Displays a menu to choose between Player vs Player (1) or Player vs AI (2), then starts the game with the selected mode or reports an invalid input. Output We can select any of the two options: Lets say we go with option 2 to play with AI Agent. Tkinter GUI for the game.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 125, "total_chunks": 193}}, {"id": 832, "text": "Tkinter GUI for the game. Lab Week # 08 Artificial Intelligence Computer Science, Semester 6 th , Spring 2025 LAB 08: Implement the Class Scheduling using Constraint Satisfaction Problem Introduction In real-world scenarios, e.g. class scheduling, we often face constraints that make manual planning difficult.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 126, "total_chunks": 193}}, {"id": 833, "text": "class scheduling, we often face constraints that make manual planning difficult. Constraint Satisfaction Problems (CSPs) offer a structured way to model such problems using variables, domains, and constraints. In this lab, you will solve a simplified class scheduling problem using Python. Learning Objectives 1. Understand how to model real-world problems as CSPs. 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 127, "total_chunks": 193}}, {"id": 834, "text": "2. Define variables, domains, and constraints in a CSP context. 3. Implement a CSP solver using either custom backtracking or a CSP library. 4. Generate and validate a schedule that satisfies all given constraints. Setup: 1. Python 3.x 2. Library: python-constraint (pip install python-constraint) 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 128, "total_chunks": 193}}, {"id": 835, "text": "Library: python-constraint (pip install python-constraint) 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 129, "total_chunks": 193}}, {"id": 836, "text": "Schedule 3 courses (C1, C2, C3) in 3 time slots (T1, T2, T3) and 2 rooms (R1, R2) while satisfying the following: Constraints: 1. No two courses should occupy the same room at the same time. 2. C1 and C2 should not occur at the same time (they share students). 3. C3 must be in Room R2 only. 4. Each course should have exactly one time slot and one room.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 130, "total_chunks": 193}}, {"id": 837, "text": "Each course should have exactly one time slot and one room.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 131, "total_chunks": 193}}, {"id": 838, "text": "Algorithm (General CSP Solver for Class Scheduling) Input: \uf0b7 Courses = {C1, C2, C3} \uf0b7 Time Slots = {T1, T2, T3} \uf0b7 Rooms = {R1, R2} \uf0b7 Constraints as defined above Output: \uf0b7 A valid assignment of (Time, Room) for each Course satisfying all constraints Code Task A This Python code defines a constraint satisfaction problem using the `python-constraint` library.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 132, "total_chunks": 193}}, {"id": 839, "text": "It schedules 3 courses (`C1`, `C2`, `C3`) into available time slots (`T1`, `T2`, `T3`) and rooms (`R1`, `R2`) such that no two courses overlap in the same room at the same time. The `no_overlap` function ensures each course gets a unique (time, room) pair. It continues the course scheduling problem by adding additional constraints.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 133, "total_chunks": 193}}, {"id": 840, "text": "It continues the course scheduling problem by adding additional constraints. It ensures that: Courses C1 and C2 cannot be scheduled at the same time, even in different rooms. Course C3 must be scheduled in Room R2 only. Output Task A Task B Add a 4th course, and include a new constraint: No teacher should be assigned to more than one course at the same time.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 134, "total_chunks": 193}}, {"id": 841, "text": "Output Task A Task B Add a 4th course, and include a new constraint: No teacher should be assigned to more than one course at the same time. (Assume teachers are T1, T2, T3.) Code Task B It solves a course scheduling problem using constraint satisfaction.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 135, "total_chunks": 193}}, {"id": 842, "text": "(Assume teachers are T1, T2, T3.) Code Task B It solves a course scheduling problem using constraint satisfaction. It assigns time slots and rooms to courses while ensuring: No overlapping room/time assignments (Constraint 1), Specific course constraints (e.g., C3 in R2, teacher T1's courses not overlapping). The solution is printed if valid, otherwise, it reports no valid schedule.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 136, "total_chunks": 193}}, {"id": 843, "text": "The solution is printed if valid, otherwise, it reports no valid schedule. Output Task B Lab Week # 09 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 09: Implement the real world problem with Bayesian Network Introduction In real-world scenarios, e.g.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 137, "total_chunks": 193}}, {"id": 844, "text": "Output Task B Lab Week # 09 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 09: Implement the real world problem with Bayesian Network Introduction In real-world scenarios, e.g.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 138, "total_chunks": 193}}, {"id": 845, "text": "class scheduling, we often face constraints that make manual planning Bayesian Networks (BNs) are powerful probabilistic models that represent dependencies among variables using directed acyclic graphs (DAGs). They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 139, "total_chunks": 193}}, {"id": 846, "text": "They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence. In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 140, "total_chunks": 193}}, {"id": 847, "text": "In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 141, "total_chunks": 193}}, {"id": 848, "text": "At the heart of these networks lies a crucial component known as the activation function. Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 142, "total_chunks": 193}}, {"id": 849, "text": "Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships. An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 143, "total_chunks": 193}}, {"id": 850, "text": "An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer. The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 144, "total_chunks": 193}}, {"id": 851, "text": "The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer. However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 145, "total_chunks": 193}}, {"id": 852, "text": "However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems. Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 146, "total_chunks": 193}}, {"id": 853, "text": "Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns. They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 147, "total_chunks": 193}}, {"id": 854, "text": "They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics. By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 148, "total_chunks": 193}}, {"id": 855, "text": "By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance. There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 149, "total_chunks": 193}}, {"id": 856, "text": "There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 150, "total_chunks": 193}}, {"id": 857, "text": "Choosing the appropriate activation function is critical, as it affects the network's convergence speed, stability, and overall performance. The selection often depends on the specific problem being addressed and the characteristics of the data.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 151, "total_chunks": 193}}, {"id": 858, "text": "The selection often depends on the specific problem being addressed and the characteristics of the data. Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 152, "total_chunks": 193}}, {"id": 859, "text": "Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications. Algorithm: Activation functions Sigmoid Activation Function Definition: The Sigmoid function, also known as the logistic function, maps any input to a value between 0 and 1. It is defined as: 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 153, "total_chunks": 193}}, {"id": 860, "text": "It is defined as: 2. ReLU (Rectified Linear Unit) Activation Function Definition: The ReLU function is defined as: 3. Tanh (Hyperbolic Tangent) Activation Function Definition: The Tanh function maps the input to a value between -1 and 1. It is defined as: These activation functions are foundational to neural network design, each with its specific strengths and trade-offs.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 154, "total_chunks": 193}}, {"id": 861, "text": "It is defined as: These activation functions are foundational to neural network design, each with its specific strengths and trade-offs. Understanding their characteristics helps in choosing the right activation function for a given task and architecture.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 155, "total_chunks": 193}}, {"id": 862, "text": "Understanding their characteristics helps in choosing the right activation function for a given task and architecture. Code Solution OUPUT: Task 2 Bias Detection in Activation Functions Hypothesis: \"Activation functions introduce bias by favoring certain output ranges, which may skew predictions.\" Steps: 1.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 156, "total_chunks": 193}}, {"id": 863, "text": "Code Solution OUPUT: Task 2 Bias Detection in Activation Functions Hypothesis: \"Activation functions introduce bias by favoring certain output ranges, which may skew predictions.\" Steps: 1. Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 157, "total_chunks": 193}}, {"id": 864, "text": "Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2. Train a single-neuron ANN (no hidden layers) using each activation function. 3. Analyze bias by comparing: - Output distribution (histogram of predictions). - Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 158, "total_chunks": 193}}, {"id": 865, "text": "- Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 159, "total_chunks": 193}}, {"id": 866, "text": "Which activation function amplified bias the most? Why? ReLU amplified bias the most. It outputs zero for all negative inputs, causing Class B (centered around -2) to collapse to near-zero outputs, while Class A remains distinct. This harsh threshold leads to amplified separation between the classes. 2. How did the bias term affect ReLU vs. Sigmoid?", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 160, "total_chunks": 193}}, {"id": 867, "text": "Sigmoid? ReLU: The bias term shifted the output range slightly but didn't eliminate the hard zero cutoff, so bias remained strong. Sigmoid: The bias term helped center the input distribution better within the sigmoid\u2019s responsive region, reducing extreme output differences between Class A and B more than ReLU. 3. Can activation functions themselves be a source of algorithmic bias? Yes.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 161, "total_chunks": 193}}, {"id": 868, "text": "Yes. Activation functions like ReLU inherently suppress negative inputs, which may skew predictions if one class predominantly has such values. This can lead to algorithmic bias, even when the model is simple and unbiased in design.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 162, "total_chunks": 193}}, {"id": 869, "text": "This can lead to algorithmic bias, even when the model is simple and unbiased in design.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 163, "total_chunks": 193}}, {"id": 870, "text": "Lab Week # 11 Artificial Intelligence Computer Science, Semester 6th , Spring 2025 LAB 11: Building an NLP Pipeline \u2013 From Text to Intelligence using python Introduction Natural Language Processing (NLP) is a core area of Artificial Intelligence that enables machines to understand, interpret, and generate human language.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 164, "total_chunks": 193}}, {"id": 871, "text": "In this hands-on lab, you will walk through the complete NLP pipeline\u2014from raw text to classification\u2014using Python. You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 165, "total_chunks": 193}}, {"id": 872, "text": "You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing. By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 166, "total_chunks": 193}}, {"id": 873, "text": "By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language. Algorithm Steps: 1. Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 167, "total_chunks": 193}}, {"id": 874, "text": "Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels. Example: data = [ (&quot;I loved the movie, it was fantastic!&quot;, &quot;Positive&quot;), (&quot;The film was boring and slow&quot;, &quot;Negative&quot;), # Add more samples... ] 2. Preprocessing Pipeline a. Tokenization Split each review into individual words. b.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 168, "total_chunks": 193}}, {"id": 875, "text": "b. Stopword Removal Remove common words like \u201cthe\u201d, \u201cis\u201d, \u201cand\u201d, using NLTK or spaCy. c. Lemmatization Convert words to their base forms (e.g., running\u2192 run). Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 169, "total_chunks": 193}}, {"id": 876, "text": "Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer 3. Vectorization Convert cleaned text into numerical format using: CountVectorizer or TF-IDF Vectorizer from sklearn.feature_extraction.text import CountVectorizer 4. Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 170, "total_chunks": 193}}, {"id": 877, "text": "Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment. from sklearn.naive_bayes import MultinomialNB from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score Evaluate Check accuracy on test data. Print 2\u20133 predictions for new reviews. Expected Output Cleaned and lemmatized reviews.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 171, "total_chunks": 193}}, {"id": 878, "text": "Expected Output Cleaned and lemmatized reviews. A table showing transformed text vectors. Model accuracy score (e.g., 85%). Example predictions: Review: \u201cAbsolutely amazing film\u201d \u2192 Positive Review: \u201cTerrible and dull\u201d \u2192 Negative Code Solution First of all we imported all the important libraries. NLTK stands for Natural Language Toolkit which is used for NLP (Natural Language processing) Tasks.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 172, "total_chunks": 193}}, {"id": 879, "text": "NLTK stands for Natural Language Toolkit which is used for NLP (Natural Language processing) Tasks. NLTK helps the program to understand, process, and analyze human language (Text or speech).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 173, "total_chunks": 193}}, {"id": 880, "text": "NLTK helps the program to understand, process, and analyze human language (Text or speech). We then took some dummy data to train our model, as we are just practicing so this is a very small dataset which is just for learning purpose so may be our model is not completely or very accurately train as we have very small dataset.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 174, "total_chunks": 193}}, {"id": 881, "text": "We then took some dummy data to train our model, as we are just practicing so this is a very small dataset which is just for learning purpose so may be our model is not completely or very accurately train as we have very small dataset. The data set contains both positive and negative reviews to train our model for future predictions on new unseen data. It reduces the words to root form.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 175, "total_chunks": 193}}, {"id": 882, "text": "It reduces the words to root form. Converts the words back to base. Removes stopwords and punctuations. Vectorization converts the words into numeric form so that our model can understand it. We then split the dataset, some for training and remaining for testing so we can use it for future predictions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 176, "total_chunks": 193}}, {"id": 883, "text": "We then split the dataset, some for training and remaining for testing so we can use it for future predictions. Evaluate the model by checking its prediction accuracy rate, in our taken dataset the accuracy for this model is 45.45%. Then we added some data to predict it by the model. Output We can see the model has predicted the reviews accuractely.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 177, "total_chunks": 193}}, {"id": 884, "text": "Output We can see the model has predicted the reviews accuractely. Note: Earlier I took a very smaller dataset even smaller than the current one, I observed that their result comes out to be wrong, that predicted the sentiment about the reviews wrong, this was because of our smaller dataset. The larger will be the dataset, the more accurate will be model predictions.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 178, "total_chunks": 193}}, {"id": 885, "text": "The larger will be the dataset, the more accurate will be model predictions. Moreover, Other better NLP algorithms like Logistic Regression can be used to avoid such situations as LR is better than the current model. Lab Week # 12 Artificial Intelligence Computer Science, Semester 6th, Spring 2025 LAB 12: Image Classification Using Artificial Neural Networks (ANN).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 179, "total_chunks": 193}}, {"id": 886, "text": "Lab Week # 12 Artificial Intelligence Computer Science, Semester 6th, Spring 2025 LAB 12: Image Classification Using Artificial Neural Networks (ANN). Introduction In this lab, students will build an Artificial Neural Network (ANN) to classify handwritten digits (0\u20139) using the MNIST dataset. Students will train the model, evaluate its accuracy, and test it with their own handwritten digit.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 180, "total_chunks": 193}}, {"id": 887, "text": "Students will train the model, evaluate its accuracy, and test it with their own handwritten digit. Setup: Dataset MNIST Dataset: (given in separate file. 70,000 grayscale images (28\u00d728 pixels). 60,000 training + 10,000 test samples. Each pixel value: 0 (black) to 255 (white).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 181, "total_chunks": 193}}, {"id": 888, "text": "Each pixel value: 0 (black) to 255 (white). Library: TensorFlow/Keras, Matplotlib Editor: Any Python-supported IDE or Jupyter Notebook, Google Colab Steps:Algorithm: Step 1. Data Loading & Preprocessing: Load MNIST dataset (60,000 training + 10,000 test images). Normalize pixel values (0\u2013255 \u2192 0\u20131). Reshape images for ANN input (flatten 28x28 \u2192 784 pixels).", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 182, "total_chunks": 193}}, {"id": 889, "text": "Reshape images for ANN input (flatten 28x28 \u2192 784 pixels). One-hot encode labels (e.g., \"3\" \u2192 [0,0,0,1,0,0,0,0,0,0]). Step 2. Model Architecture (ANN): Input Layer: 784 neurons (1 per pixel). Hidden Layer(s): 1\u20132 dense layers with ReLU activation. Output Layer: 10 neurons (Softmax activation for probability distribution). Step 3.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 183, "total_chunks": 193}}, {"id": 890, "text": "Step 3. Training & Evaluation: Compile model with `adam` optimizer and `categorical_crossentropy` loss. Train for 5\u201310 epochs and validate on test data. Evaluate accuracy and confusion matrix. Step 4. Custom Digit Testing: Draw a digit (using `matplotlib` or external image). Preprocess and predict using the trained model.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 184, "total_chunks": 193}}, {"id": 891, "text": "Preprocess and predict using the trained model. Code Solution Imported Important Libraries It imports essential libraries for data manipulation (pandas, numpy), visualization (matplotlib), and building neural networks using TensorFlow/Keras (Sequential, Dense, to_categorical, and SGD). These imports set the foundation for a machine learning project.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 185, "total_chunks": 193}}, {"id": 892, "text": "These imports set the foundation for a machine learning project. load_data() function This function loads and preprocesses the training and test data from CSV files, separating features and labels, and normalizing pixel values to the range [0, 1].", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 186, "total_chunks": 193}}, {"id": 893, "text": "load_data() function This function loads and preprocesses the training and test data from CSV files, separating features and labels, and normalizing pixel values to the range [0, 1].", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 187, "total_chunks": 193}}, {"id": 894, "text": "build_model(input_shape) function: This function builds and compiles a deep neural network with three hidden layers using ReLU activation and an output layer with softmax for multi-class classification of digits (0\u20139). display_sample_predictions The function visualizes grayscale image predictions using matplotlib.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 188, "total_chunks": 193}}, {"id": 895, "text": "display_sample_predictions The function visualizes grayscale image predictions using matplotlib. main() Function This main function loads data, trains a model, and plots training vs validation accuracy over epochs. Calling the main function Output Predictions Lab Evaluation Summary Student Name | Syed Hasnain Ali Shah Rehistration | 22 PWBCS 0919 Department | CS & IT Instructor | Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 189, "total_chunks": 193}}, {"id": 896, "text": "Calling the main function Output Predictions Lab Evaluation Summary Student Name | Syed Hasnain Ali Shah Rehistration | 22 PWBCS 0919 Department | CS & IT Instructor | Dr.", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 190, "total_chunks": 193}}, {"id": 897, "text": "| Image Classification Using Artificial Neural Networks (ANN). | 26 May, 2025 13 | Mini Project-RAG System | Mini Project-RAG System 14 | Mini Project-RAG System | Mini Project-RAG System", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 191, "total_chunks": 193}}, {"id": 898, "text": "| 26 May, 2025 13 | Mini Project-RAG System | Mini Project-RAG System 14 | Mini Project-RAG System | Mini Project-RAG System", "metadata": {"filename": "Lab_Manual(22pwbcs0919).docx", "chunk_index": 192, "total_chunks": 193}}, {"id": 899, "text": "DEPARTMENT OF COMPUTER SCIENCE & INFORMATION TECHNOLOGY UNIVERSITY OF ENGINEERING & TECHNOLOGY, PESHAWAR Lab Manual BS(CS) Spring 2025 Artificial Intelligence Table of Contents LAB 01 Implement Breadth-First Search (BFS) using Python ................................. 4 LAB 02 Implement Depth-First Search (DFS) using Python ....................................", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 0, "total_chunks": 184}}, {"id": 900, "text": "4 LAB 02 Implement Depth-First Search (DFS) using Python .................................... 9 LAB 03 Implementation of River Crossing Puzzle ................................................... 13 LAB 04 Implement N-Puzzle Problem with Admissible Search (A*) ..................... 17 LAB 05 Solve the Traveling Salesman Problem (TSP) using Simulated Annealing ....", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 1, "total_chunks": 184}}, {"id": 901, "text": "17 LAB 05 Solve the Traveling Salesman Problem (TSP) using Simulated Annealing .... 22 LAB 06 Implementation of Genetic Algorithm ............................................................ 26 LAB 07 Implement the Connect-Four Game using Minimax Algorithm .................. 30 LAB 08 Implement Class Scheduling using Constraint Satisfaction Problem ..........", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 2, "total_chunks": 184}}, {"id": 902, "text": "30 LAB 08 Implement Class Scheduling using Constraint Satisfaction Problem .......... 35 LAB 09 Image Classification Using Artificial Neural Networks (ANN). Lab Evaluation Summary ..................................................................................................", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 3, "total_chunks": 184}}, {"id": 903, "text": "Lab Evaluation Summary .................................................................................................. 4 Lab Week # 01 LAB 01: Implement Breadth-First Search BFS using Python Introduction Breadth-First Search (BFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 4, "total_chunks": 184}}, {"id": 904, "text": "4 Lab Week # 01 LAB 01: Implement Breadth-First Search BFS using Python Introduction Breadth-First Search (BFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically. It operates by visiting all nodes in a graph level by level, starting from a designated source node.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 5, "total_chunks": 184}}, {"id": 905, "text": "It operates by visiting all nodes in a graph level by level, starting from a designated source node.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 6, "total_chunks": 184}}, {"id": 906, "text": "Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Dequeue a state current_state from the frontier.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 7, "total_chunks": 184}}, {"id": 907, "text": "Main Loop: While the frontier is not empty: Dequeue a state current_state from the frontier. If current_state is the goal state, return the path to current_state. Add current_state to the explored set. For each action a in the set of legal actions applicable to current_state: Calculate the successor state next_state by applying action a to current_state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 8, "total_chunks": 184}}, {"id": 908, "text": "For each action a in the set of legal actions applicable to current_state: Calculate the successor state next_state by applying action a to current_state. If next_state is not in frontier or explored: Enqueue next_state onto the frontier. Set the parent of next_state to current_state. Termination: If the frontier becomes empty without finding the goal state, return failure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 9, "total_chunks": 184}}, {"id": 909, "text": "Termination: If the frontier becomes empty without finding the goal state, return failure. Task : Implement the above algorithm in Python for the following problem where 12 is the goal state. Solution: Step 1: Importing Required Libraries We import deque from collections to implement the queue structure. We use networkx for graph creation. We use matplotlib.pyplot for visualizing the graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 10, "total_chunks": 184}}, {"id": 910, "text": "We use matplotlib.pyplot for visualizing the graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 11, "total_chunks": 184}}, {"id": 911, "text": "A visited set keeps track of explored nodes. The function iterates until the queue is empty, exploring nodes level by level. If the goal is found, the shortest path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 12, "total_chunks": 184}}, {"id": 912, "text": "If the goal is found, the shortest path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 13, "total_chunks": 184}}, {"id": 913, "text": "start_node = 1 goal_node = 12 bfs_with_visualization(graph, start_node, goal_node) Output: Lab Week # 02 LAB 02: Implement Depth First Search using Python Introduction Depth-First Search (DFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 14, "total_chunks": 184}}, {"id": 914, "text": "Unlike BFS, which explores nodes level by level, DFS explores as far as possible along each branch before backtracking.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 15, "total_chunks": 184}}, {"id": 915, "text": "DFS is widely employed in AI applications such as: Pathfinding State space exploration Solving Puzzle and Mazes By traversing the graph depth-wise, DFS is particularly useful for exploring all possible paths in a graph, making it ideal for problems like cycle detection, topological sorting, and solving constraint satisfaction problems.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 16, "total_chunks": 184}}, {"id": 916, "text": "Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 17, "total_chunks": 184}}, {"id": 917, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Pop a node (current_node) from the frontier. o If current_node is the goal node, return the path to current_node. o Add current_node to the explored set.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 18, "total_chunks": 184}}, {"id": 918, "text": "o Add current_node to the explored set. For each neighbor of current_node: If the neighbor is not in frontier or explored: Push the neighbor onto the frontier. Set the parent of the neighbor to current_node. Termination: \uf0b7 If the frontier becomes empty without finding the goal node, return failure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 19, "total_chunks": 184}}, {"id": 919, "text": "Termination: \uf0b7 If the frontier becomes empty without finding the goal node, return failure. Explanation: break down the provided Breadth-First Search (BFS) algorithm for intelligent agents step by step: Initialization: We start by initializing a queue named frontier to keep track of states to be explored. We enqueue the initial state onto the frontier.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 20, "total_chunks": 184}}, {"id": 920, "text": "We enqueue the initial state onto the frontier. An empty set explored is created to store visited states. Main Loop: We enter a loop that continues until the frontier is not empty. \uf0b7 Within each iteration of the loop: We dequeue a state current_state from the frontier. We check if current_state is the goal state by calling the Problem.goal_test(current_state) function.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 21, "total_chunks": 184}}, {"id": 921, "text": "We check if current_state is the goal state by calling the Problem.goal_test(current_state) function. If it is, we return the path to this state. If current_state is not the goal state, we mark it as explored by adding it to the explored set. We iterate over all applicable actions for the current_state by calling Problem.actions(current_state).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 22, "total_chunks": 184}}, {"id": 922, "text": "We iterate over all applicable actions for the current_state by calling Problem.actions(current_state). \uf0b7 For each action: We calculate the successor state next_state by applying the action to the current_state using the Problem.result(current_state, action) function. If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 23, "total_chunks": 184}}, {"id": 923, "text": "If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier. We set the parent of next_state to current_state. This step is crucial for reconstructing the path once the goal state is found.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 24, "total_chunks": 184}}, {"id": 924, "text": "This step is crucial for reconstructing the path once the goal state is found. Termination: If the frontier becomes empty without finding the goal state, we return failure, indicating that the goal state is unreachable from the initial state. Output: If the goal state is found during the search, we return the path from the initial state to the goal state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 25, "total_chunks": 184}}, {"id": 925, "text": "Output: If the goal state is found during the search, we return the path from the initial state to the goal state. This path can be constructed by following the parent pointers from the goal state back to the initial state. Task : Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 26, "total_chunks": 184}}, {"id": 926, "text": "Task : Implement the above algorithm in Python for the following problem where 10 is the goal state. Solution: Step 1: Importing Required Libraries We import networkx for graph creation. We use matplotlib.pyplot for visualizing the graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 27, "total_chunks": 184}}, {"id": 927, "text": "We use matplotlib.pyplot for visualizing the graph. import networkx as nx import matplotlib.pyplot as plt Step 2: Define the Graph as an Adjacency List The graph is represented as a dictionary where keys are node numbers, and values are lists of connected nodes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 28, "total_chunks": 184}}, {"id": 928, "text": "import networkx as nx import matplotlib.pyplot as plt Step 2: Define the Graph as an Adjacency List The graph is represented as a dictionary where keys are node numbers, and values are lists of connected nodes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 29, "total_chunks": 184}}, {"id": 929, "text": "graph = { 1: [2, 7, 8], 2: [3, 6], 3: [4, 5], 7: [], 8: [9, 12], 9: [10, 11], 12: [], 4: [], 5: [], 6: [], 10: [], 11: [] } Step 3: Define the DFS Function A stack is initialized with the start node. A visited set keeps track of explored nodes. The function iterates until the stack is empty, exploring nodes deep first. If the goal is found, the path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 30, "total_chunks": 184}}, {"id": 930, "text": "If the goal is found, the path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 31, "total_chunks": 184}}, {"id": 931, "text": "start_node = 1 goal_node = 10 dfs_with_visualization(graph, start_node, goal_node) Output: Task 2: Modify the given tree or create a custom tree and test the DFS implementation. Step 1: Define the Initial Tree The tree is represented as an adjacency list where each node has children.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 32, "total_chunks": 184}}, {"id": 932, "text": "Step 1: Define the Initial Tree The tree is represented as an adjacency list where each node has children. initial_tree = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': [], 'F': [] } Step 2: Mo Modify the Tree Adding new nodes and edges to expand the tree structure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 33, "total_chunks": 184}}, {"id": 933, "text": "initial_tree = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': [], 'F': [] } Step 2: Mo Modify the Tree Adding new nodes and edges to expand the tree structure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 34, "total_chunks": 184}}, {"id": 934, "text": "modified_tree = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F', 'G'], 'D': ['H'], 'E': [], 'F': [], 'G': ['I'], 'H': [], 'I': [] } Step 3: Define the DFS Function for the Modified Tree The DFS algorithm searches for the goal node in the expanded tree.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 35, "total_chunks": 184}}, {"id": 935, "text": "start_node = 'A' goal_node = 'I' dfs_for_tree(modified_tree, start_node, goal_node) Step 5: Visualizing the Modified Tree \uf0b7Use networkx and matplotlib to visualize the updated tree.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 36, "total_chunks": 184}}, {"id": 936, "text": "In this puzzle: A man wants to cross a river with three items: a wolf, a chicken, and a corn. The boat can carry a maximum of two entities (the man plus one item). Constraints: If the wolf and chicken are left alone without the man, the wolf will eat the chicken. If the chicken and corn are left alone without the man, the chicken will eat the corn.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 37, "total_chunks": 184}}, {"id": 937, "text": "If the chicken and corn are left alone without the man, the chicken will eat the corn. Your task is to help the man safely transport all items to the other side of the river without violating the constraints. Problem Setup Entities: Man, Wolf, Chicken, Corn. Boat Capacity: Maximum of 2 (Man + 1 item). Constraints: Wolf cannot be left alone with Chicken. Chicken cannot be left alone with Corn.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 38, "total_chunks": 184}}, {"id": 938, "text": "Chicken cannot be left alone with Corn. State Representation Each state can be represented as a tuple: (Man, Wolf, Chicken, Corn) Man: Left or Right (side of the river). Wolf, Chicken, Corn: Left or Right (side of the river).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 39, "total_chunks": 184}}, {"id": 939, "text": "Wolf, Chicken, Corn: Left or Right (side of the river). Example: Initial State: ('Left', 'Left', 'Left', 'Left') Goal State: ('Right', 'Right', 'Right', 'Right') Task State-Space Search: Represent the problem as a state-space graph. Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 40, "total_chunks": 184}}, {"id": 940, "text": "Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions. Find a Valid Sequence: Find a sequence of moves that transports all items to the right side of the river without violating the constraints. Implement the Solution: Write a Python program to solve the puzzle. Solution: Step 1: Import Required Libraries deque from collections is used for BFS queue management.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 41, "total_chunks": 184}}, {"id": 941, "text": "Solution: Step 1: Import Required Libraries deque from collections is used for BFS queue management. from collections import deque Step 2: Define the Initial and Goal States The initial state has all items on the left side. The goal state has all items on the right side.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 42, "total_chunks": 184}}, {"id": 942, "text": "The goal state has all items on the right side. initial_state = ({'F', 'W', 'G', 'C'}, set(), 'left') goal_state = (set(), {'F', 'W', 'G', 'C'}, 'right') Step 3: Define a Function to Check State Validity This function ensures that no constraints are violated in a given state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 43, "total_chunks": 184}}, {"id": 943, "text": "initial_state = ({'F', 'W', 'G', 'C'}, set(), 'left') goal_state = (set(), {'F', 'W', 'G', 'C'}, 'right') Step 3: Define a Function to Check State Validity This function ensures that no constraints are violated in a given state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 44, "total_chunks": 184}}, {"id": 944, "text": "_state = ({'F', 'W', 'G', 'C'}, set(), 'left') goal_state = (set(), {'F', 'W', 'G', 'C'}, 'right') Step 3: Define a Function to Check State Validity \uf0b7This function ensures that no constraints are violated in a given state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 45, "total_chunks": 184}}, {"id": 945, "text": "solution = bfs(initial_state, goal_state) Step 7: Print the Solution Display the sequence of valid moves. if solution: print(\"Solution Found!\") for step, state in enumerate(solution): print(f\"Step {step}: {state}\") else: print(\"No solution found.\") Explanation How the Algorithm Works: The algorithm starts from the initial state and generates all possible next states.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 46, "total_chunks": 184}}, {"id": 946, "text": "if solution: print(\"Solution Found!\") for step, state in enumerate(solution): print(f\"Step {step}: {state}\") else: print(\"No solution found.\") Explanation How the Algorithm Works: The algorithm starts from the initial state and generates all possible next states. It checks each new state for validity to ensure no constraints are violated.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 47, "total_chunks": 184}}, {"id": 947, "text": "It checks each new state for validity to ensure no constraints are violated. Breadth-First Search (BFS) ensures that the shortest sequence of moves is found. Why the Solution is Valid: The algorithm ensures that: The wolf and goat are never left alone. The goat and cabbage are never left alone. The farmer is always controlling interactions between animals and items.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 48, "total_chunks": 184}}, {"id": 948, "text": "The farmer is always controlling interactions between animals and items.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 49, "total_chunks": 184}}, {"id": 949, "text": "In this implementation, we will focus on the 8-puzzle variant, where the puzzle is divided into a 3x3 grid with eight numbered tiles and one empty space. We'll use the A* search algorithm to efficiently find the shortest path from the initial state to the goal state. Learning Objectives Understand the N-Puzzle problem and its rules. Implement the A* search algorithm in Python.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 50, "total_chunks": 184}}, {"id": 950, "text": "Implement the A* search algorithm in Python. Learn how to represent states, actions, and transitions in the N-Puzzle problem. Gain experience in solving optimization problems using heuristic search techniques. Steps: Algorithm: A* search Input: Receive the initial and goal configurations of the puzzle. Output: Display the steps required to reach the goal state from the initial state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 51, "total_chunks": 184}}, {"id": 951, "text": "Output: Display the steps required to reach the goal state from the initial state. Explanation: 1. INPUT: - Define the problem domain including the initial state and the goal state of the puzzle. - Define the actions applicable to each state, the transition model, the goal test, and the cost function. 2. OUTPUT: - Return the sequence of actions that lead from the initial state to the goal state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 52, "total_chunks": 184}}, {"id": 952, "text": "OUTPUT: - Return the sequence of actions that lead from the initial state to the goal state. 3. INITIALIZATION: - Initialize an empty priority queue frontier to store states to be explored. - Enqueue the initial state onto the frontier with a priority of 0. - Initialize an empty set explored to store visited states. 4.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 53, "total_chunks": 184}}, {"id": 953, "text": "4. MAIN LOOP: - While the frontier is not empty: - Dequeue a state from the frontier. - If the dequeued state is the goal state, return the sequence of actions leading to it. - Add the dequeued state to the explored set. - For each action applicable to the current state: - Calculate the successor state by applying the action.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 54, "total_chunks": 184}}, {"id": 954, "text": "- For each action applicable to the current state: - Calculate the successor state by applying the action. - If the successor state has not been explored or enqueued: - Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic. - Set the parent of the successor state to the current state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 55, "total_chunks": 184}}, {"id": 955, "text": "- Set the parent of the successor state to the current state. TERMINATION: - If the frontier becomes empty without finding the goal state, return failure. Algorithm studied in theory class for more understanding. Explanation Explanation: N-Puzzle or sliding puzzle is a popular puzzle that consists of N tiles where N can be 8, 15, 24 and so on. In our example N = 8.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 56, "total_chunks": 184}}, {"id": 956, "text": "In our example N = 8. The puzzle is divided into sqrt(N+1) rows and sqrt(N+1) columns. Eg. 15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns. The puzzle consists of N tiles and one empty space where the tiles can be moved. Start and Goal configurations (also called state) of the puzzle are provided.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 57, "total_chunks": 184}}, {"id": 957, "text": "Start and Goal configurations (also called state) of the puzzle are provided. The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration. Rules for solving the puzzle. Instead of moving the tiles in the empty space we can visualize moving the empty space in place of the tile, basically swapping the tile with the empty space.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 58, "total_chunks": 184}}, {"id": 958, "text": "Instead of moving the tiles in the empty space we can visualize moving the empty space in place of the tile, basically swapping the tile with the empty space. The empty space can only move in four directions viz., 1. Up 2.Down 3. Right or 4. Left The empty space cannot move diagonally and can take only one step at a time (i.e. move the empty space one position at a time).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 59, "total_chunks": 184}}, {"id": 959, "text": "move the empty space one position at a time). The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state. The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 60, "total_chunks": 184}}, {"id": 960, "text": "The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution. It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 61, "total_chunks": 184}}, {"id": 961, "text": "It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems. A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 62, "total_chunks": 184}}, {"id": 962, "text": "A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search. It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 63, "total_chunks": 184}}, {"id": 963, "text": "It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node. Heuristic Cost (h): An estimated cost from the current node to the goal node (often called the heuristic function). The key to A*'s efficiency lies in its selection of nodes to explore.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 64, "total_chunks": 184}}, {"id": 964, "text": "The key to A*'s efficiency lies in its selection of nodes to explore. At each step, it chooses the node that minimizes the sum of the path cost g and the estimated remaining cost to the goal h (often represented as f = g + h). This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 65, "total_chunks": 184}}, {"id": 965, "text": "This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function. Task : Implement the above algorithm in Python for the following problem the N-Puzzle. Where Code Implementation Step 1: Define the Problem Representation The puzzle is represented as a 3x3 matrix.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 66, "total_chunks": 184}}, {"id": 966, "text": "Where Code Implementation Step 1: Define the Problem Representation The puzzle is represented as a 3x3 matrix. The Manhattan Distance heuristic measures how far tiles are from their goal positions.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 67, "total_chunks": 184}}, {"id": 967, "text": "The Manhattan Distance heuristic measures how far tiles are from their goal positions.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 68, "total_chunks": 184}}, {"id": 968, "text": "copy def manhattan_distance(state): distance = 0 for i in range(3): for j in range(3): if state[i][j] != 0: goal_row, goal_col = divmod(state[i][j] - 1, 3) distance += abs(i - goal_row) + abs(j - goal_col) return distance Step 2: Generate Neighboring States The function finds valid moves for the empty tile (0) and returns possible next states.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 69, "total_chunks": 184}}, {"id": 969, "text": "This lab explores solving TSP using the Simulated Annealing (SA) algorithm and analyzing its performance. Algorithm: Input: A set of cities with random (x, y) coordinates. Distance function (e.g., Euclidean distance) to evaluate the path cost. Output: Optimized path with the shortest distance. Graphical representation of the final tour. Initialization: Generate an initial random tour.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 70, "total_chunks": 184}}, {"id": 970, "text": "Initialization: Generate an initial random tour. Set initial temperature and cooling rate for Simulated Annealing. Define an acceptance probability function. Main Loop: Iteratively swap cities in the tour to generate a new solution. Evaluate the cost difference between current and new solutions. Accept the new solution based on the probability function.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 71, "total_chunks": 184}}, {"id": 971, "text": "Accept the new solution based on the probability function. Gradually reduce the temperature until termination conditions are met Termination: Stop when the temperature reaches a predefined threshold. Return the best solution found. Task Implement Simulated Annealing (SA) to solve TSP. Visualize the computed shortest tour.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 72, "total_chunks": 184}}, {"id": 972, "text": "Visualize the computed shortest tour. Analyze performance based on: Path length Execution time Number of iterations Extend the problem to 100 cities and compare results. Implement Tabu Search and evaluate its effectiveness against SA. Solution of Task: Import Necessary Libraries: These libraries are used for numerical operations, plotting, randomness, and time measurement.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 73, "total_chunks": 184}}, {"id": 973, "text": "Solution of Task: Import Necessary Libraries: These libraries are used for numerical operations, plotting, randomness, and time measurement. Generate Random Cities: His function creates n random cities represented as (x, y) coordinates. Compute Distance Between Two Cities: Calculates the Euclidean distance between two given cities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 74, "total_chunks": 184}}, {"id": 974, "text": "Compute Distance Between Two Cities: Calculates the Euclidean distance between two given cities. Compute Total Distance of a Tour: Finds the total distance of a given tour by summing up distances between consecutive cities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 75, "total_chunks": 184}}, {"id": 975, "text": "Compute Total Distance of a Tour: Finds the total distance of a given tour by summing up distances between consecutive cities. Simulated Annealing Algorithm: Uses Simulated Annealing to find an optimal TSP tour by gradually lowering the temperature and allowing occasional worse solutions to escape local optima.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 76, "total_chunks": 184}}, {"id": 976, "text": "Simulated Annealing Algorithm: Uses Simulated Annealing to find an optimal TSP tour by gradually lowering the temperature and allowing occasional worse solutions to escape local optima.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 77, "total_chunks": 184}}, {"id": 977, "text": "Run Simulated Annealing for 20 and 100 Cities: Executes the SA algorithm for 20 and 100 cities and displays results.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 78, "total_chunks": 184}}, {"id": 978, "text": "Genetic Algorithms (GAs) are evolutionary algorithms inspired by natural selection and genetics, commonly used to solve optimization and search problems. Algorithm: Genetic Algorithm Input: A set of cities with their coordinates. Population size. Crossover rate Mutation rate. Termination condition (e.g., maximum number of generations, convergence criteria).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 79, "total_chunks": 184}}, {"id": 979, "text": "Termination condition (e.g., maximum number of generations, convergence criteria). Output: The best route found (shortest tour) that visits each city exactly once and returns to the original city. Initialization: 1. Create Initial Population: Generate an initial population of candidate solutions (chromosomes).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 80, "total_chunks": 184}}, {"id": 980, "text": "Create Initial Population: Generate an initial population of candidate solutions (chromosomes). Each chromosome represents a possible route for the salesman, typically represented as a permutation of city indices. 2.Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 81, "total_chunks": 184}}, {"id": 981, "text": "2.Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route. Main Loop: 1.Repeat until Termination Condition is met: 2.Selection: Perform Roulette Wheel Selection: Select parents for mating based on their fitness. The probability of selection is proportional to the fitness of each chromosome.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 82, "total_chunks": 184}}, {"id": 982, "text": "The probability of selection is proportional to the fitness of each chromosome. 3.Crossover: Apply Crossover Operation: Generate offspring by combining genetic material (routes) from selected parents. Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 83, "total_chunks": 184}}, {"id": 983, "text": "Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc. 4.Mutation: Introduce Mutation: Randomly alter some chromosomes in the offspring population to maintain diversity. For TSP, swapping cities in a route is a typical mutation. 5.Evaluate Fitness: Calculate the fitness of each offspring. 6.Replacement: Select individuals for the next generation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 84, "total_chunks": 184}}, {"id": 984, "text": "6.Replacement: Select individuals for the next generation. This could involve elitism (keeping the best solutions from the current generation) or replacing the entire population. 7.Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 85, "total_chunks": 184}}, {"id": 985, "text": "7.Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations). Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 86, "total_chunks": 184}}, {"id": 986, "text": "Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation. Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 87, "total_chunks": 184}}, {"id": 987, "text": "Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation. Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 88, "total_chunks": 184}}, {"id": 988, "text": "Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP. The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 89, "total_chunks": 184}}, {"id": 989, "text": "The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city. Task :Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 90, "total_chunks": 184}}, {"id": 990, "text": "Task :Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment. The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 91, "total_chunks": 184}}, {"id": 991, "text": "The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point. The goal is to find the shortest route that minimizes fuel costs and travel time using a Genetic Algorithm (GA). List of Cities (Warehouses) in Pakistan.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 92, "total_chunks": 184}}, {"id": 992, "text": "List of Cities (Warehouses) in Pakistan. Consider 10 major cities with approximate road distances (in kilometers) between them: Step 1: Load City Distance Data Loads city names and distance matrix from a CSV and JSON file for the Traveling Salesman Problem (TSP).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 93, "total_chunks": 184}}, {"id": 993, "text": "Consider 10 major cities with approximate road distances (in kilometers) between them: Step 1: Load City Distance Data Loads city names and distance matrix from a CSV and JSON file for the Traveling Salesman Problem (TSP).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 94, "total_chunks": 184}}, {"id": 994, "text": "def calculate_route_distance(route): \"\"\"Calculate total distance of a given route\"\"\" total_distance = sum(distance_matrix[route[i], route[i + 1]] for i in range(len(route) - 1)) total_distance += distance_matrix[route[-1], route[0]] # Return to starting city return total_distance Step 3: Selection Mechanism Uses Roulette Wheel Selection to probabilistically select the best routes for reproduction.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 95, "total_chunks": 184}}, {"id": 995, "text": "def swap_mutation(route): \"\"\"Perform swap mutation by randomly swapping two cities\"\"\" a, b = random.sample(range(len(route)), 2) route[a], route[b] = route[b], route[a] return route Step 6: Genetic Algorithm Execution Runs the Genetic Algorithm for multiple generations, selecting, crossing over, and mutating routes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 96, "total_chunks": 184}}, {"id": 996, "text": "# Run the algorithm best_route, best_distance = genetic_algorithm() # Display resultsprint(\"Optimized Route:\")print([city_names[i] for i in best_route])print(\"Total Distance:\", best_distance) Output: Step 8: Visualization Uses NetworkX and Matplotlib to display the optimized delivery route as a graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 97, "total_chunks": 184}}, {"id": 997, "text": "Comparison of Initial vs. Optimized Routes (route_comparison.png) \u2192 Visualizes the reduction in total distance. Performance Analysis (performance_report.txt) \u2192 Records execution time, final optimized distance, and areas for improvement. Limitations & Future Improvements \u2192 Suggests enhancements like better mutation strategies, additional crossover techniques, and parallel execution for efficiency.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 98, "total_chunks": 184}}, {"id": 998, "text": "Limitations & Future Improvements \u2192 Suggests enhancements like better mutation strategies, additional crossover techniques, and parallel execution for efficiency.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 99, "total_chunks": 184}}, {"id": 999, "text": "Optimized Route plt.figure(figsize=(10, 5)) plt.bar([\"Initial Route\", \"Optimized Route\"], [max(fitness_over_generations), best_distance], color=[\"red\", \"green\"]) plt.ylabel(\"Total Distance\") plt.title(\"Comparison of Initial vs.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 100, "total_chunks": 184}}, {"id": 1000, "text": "Advanced Crossover Techniques \u2192 Experiment with different methods for better convergence. Parallel Execution \u2192 Utilize multi-threading or GPU acceleration for faster computation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 101, "total_chunks": 184}}, {"id": 1001, "text": "Parallel Execution \u2192 Utilize multi-threading or GPU acceleration for faster computation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 102, "total_chunks": 184}}, {"id": 1002, "text": "Lab Week # 07 LAB 07: Implement the connect-four game using minmax algorithm with python language Introduction Connect Four is a classic two-player strategy game where players take turns dropping colored discs into a vertical grid with the goal of connecting four of their own discs in a row, either horizontally, vertically, or diagonally.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 103, "total_chunks": 184}}, {"id": 1003, "text": "Implementing Connect Four with the Minimax algorithm provides an excellent opportunity to delve into the field of artificial intelligence and game theory. The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 104, "total_chunks": 184}}, {"id": 1004, "text": "The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision. Setup: The game board is positioned vertically, with six rows and seven columns. Each player is assigned a color, typically red and yellow. But this time we choose Green and Yellow instead.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 105, "total_chunks": 184}}, {"id": 1005, "text": "But this time we choose Green and Yellow instead. The game begins with an empty board. Gameplay: Players take turns dropping one of their colored discs into any column of the board. The disc falls to the lowest available empty cell in the selected column.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 106, "total_chunks": 184}}, {"id": 1006, "text": "The disc falls to the lowest available empty cell in the selected column. Players alternate turns until one player achieves a winning four-in-a-row line or the board is completely filled without a winner (resulting in a draw). Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 107, "total_chunks": 184}}, {"id": 1007, "text": "Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally. The game ends immediately once a winning condition is met. Steps: Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 108, "total_chunks": 184}}, {"id": 1008, "text": "Steps: Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four). The choice of colors for Player 1 and Player 2 (e.g., \"Green\" and \"Yellow\"). The option to choose between two human players or one human player and one AI player. Game must include both options.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 109, "total_chunks": 184}}, {"id": 1009, "text": "Game must include both options. Output: Display the game board after each move. Inform the players when a player wins, loses, or when the game ends in a draw. Prompt the players for their moves (column number to drop their disc into). INITIALIZATION: Create a 2D array to represent the game board with the specified number of rows and columns. Initialize the game board with empty cells.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 110, "total_chunks": 184}}, {"id": 1010, "text": "Initialize the game board with empty cells. Assign colors to Player 1 and Player 2. MAIN LOOP: Display the initial empty game board. Repeat the following steps until the game ends: Prompt the current player for their move (column number to drop their disc into). Update the game board with the player's move. Check for a winning condition (four connected discs in a row).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 111, "total_chunks": 184}}, {"id": 1011, "text": "Check for a winning condition (four connected discs in a row). If a winning condition is met, declare the current player as the winner and end the game. - Check for a draw condition (all cells on the board are filled without a winner). If a draw condition is met, end the game with a draw. Switch to the next player. TERMINATION: Display the final game board. If a player wins, announce the winner.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 112, "total_chunks": 184}}, {"id": 1012, "text": "If a player wins, announce the winner. If the game ends in a draw, announce the draw. End the game.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 113, "total_chunks": 184}}, {"id": 1013, "text": "End the game.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 114, "total_chunks": 184}}, {"id": 1014, "text": "It can be implemented in various programming languages, adapting the syntax and specific functionalities accordingly. Task : Implement the above algorithm in Python for the following problem the Connect -Four Game for a grid of 12X12. Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 115, "total_chunks": 184}}, {"id": 1015, "text": "Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 116, "total_chunks": 184}}, {"id": 1016, "text": "class scheduling, we often face constraints that make manual planning Bayesian Networks (BNs) are powerful probabilistic models that represent dependencies among variables using directed acyclic graphs (DAGs). They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 117, "total_chunks": 184}}, {"id": 1017, "text": "They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence. In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 118, "total_chunks": 184}}, {"id": 1018, "text": "In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility. Learning Objectives By the end of this lab, students will be able to: Understand the structure and components of a Bayesian Network. Define conditional probability tables (CPTs) for given dependencies.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 119, "total_chunks": 184}}, {"id": 1019, "text": "Define conditional probability tables (CPTs) for given dependencies. Compute joint and marginal probabilities using the BN. (Optional) Implement the BN in Python using pgmpy.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 120, "total_chunks": 184}}, {"id": 1020, "text": "(Optional) Implement the BN in Python using pgmpy. Steps of Algorithm: Step 1: INITIALIZATION Initialization Define the random variables: D: Exam Difficulty (Hard, Easy) I: Intelligence (High, Low) P: Preparation (Good, Poor) S: Exam Score (Pass, Fail) R: Recommendation Letter (Yes, No) Establish dependencies: D, I, and P influence S. S influences R.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 121, "total_chunks": 184}}, {"id": 1021, "text": "S influences R. Step 2: MAIN LOOP (STEP-BY-STEP CONSTRUCTION) Step 1: Draw the Bayesian Network Structure (DAG) Represent nodes and add edges: add directed arrows as per dependencies.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 122, "total_chunks": 184}}, {"id": 1022, "text": "Step 2: MAIN LOOP (STEP-BY-STEP CONSTRUCTION) Step 1: Draw the Bayesian Network Structure (DAG) Represent nodes and add edges: add directed arrows as per dependencies.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 123, "total_chunks": 184}}, {"id": 1023, "text": "(Define other CPTs) model.add_cpds(cpd_d, ...) # Perform inference from pgmpy.inference import VariableElimination infer = VariableElimination(model) result = infer.query(variables=['R'], evidence={'I': 'High'}) print(result) 3. Termination Verify computed probabilities match expected reasoning. Ensure all CPTs are correctly defined.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 124, "total_chunks": 184}}, {"id": 1024, "text": "Ensure all CPTs are correctly defined. (If implemented) Confirm Python output aligns with manual calculations. Problem Statement Given the BN for student performance: Construct the DAG and CPTs. Compute P(R=Yes | I=High) manually. Implement the BN in Python and compare results. Deliverables Draw digital BN structure. Completed CPTs with assigned probabilities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 125, "total_chunks": 184}}, {"id": 1025, "text": "Completed CPTs with assigned probabilities. Step-by-step probability calculation for the query. Python code and output. Upload the solution 1.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 126, "total_chunks": 184}}, {"id": 1026, "text": "Upload the solution 1. Digital BN Structure (DAG) Here's the Bayesian Network structure: [D] [I] [P] \\ | / \\ | / [S] | [R] Nodes: D: Exam Difficulty (Hard, Easy) I: Intelligence (High, Low) P: Preparation (Good, Poor) S: Exam Score (Pass, Fail) R: Recommendation Letter (Yes, No) Edges: D \u2192 S I \u2192 S P \u2192 S S \u2192 R 2.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 127, "total_chunks": 184}}, {"id": 1027, "text": "Digital BN Structure (DAG) Here's the Bayesian Network structure: [D] [I] [P] \\ | / \\ | / [S] | [R] Nodes: D: Exam Difficulty (Hard, Easy) I: Intelligence (High, Low) P: Preparation (Good, Poor) S: Exam Score (Pass, Fail) R: Recommendation Letter (Yes, No) Edges: D \u2192 S I \u2192 S P \u2192 S S \u2192 R 2.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 128, "total_chunks": 184}}, {"id": 1028, "text": "Completed CPTs with Assigned Probabilities P(D): Exam Difficulty P(I): Intelligence P(P): Preparation P(S|D,I,P): Exam Score D I P P(S=Pass) P(S=Fail) P(R|S): Recommendation Letter 3.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 129, "total_chunks": 184}}, {"id": 1029, "text": "Step-by-Step Probability Calculation for P(R=Yes | I=High) To compute P(R=Yes | I=High), we need to marginalize over all other variables: Expand using chain rule: P(R=Yes | I=High) = \u03a3_D,P,S P(R=Yes|S) \u00d7 P(S|D,I=High,P) \u00d7 P(D) \u00d7 P(P) Calculate for all combinations: There are 2 (D) \u00d7 2 (P) \u00d7 2 (S) = 8 combinations to consider.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 130, "total_chunks": 184}}, {"id": 1030, "text": "Python Implementation and Output Jupyter File are Aploaded Python Output: 5.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 131, "total_chunks": 184}}, {"id": 1031, "text": "Comparison of Results Manual Calculation: P(R=Yes | I=High) = 0.604 Python Output: P(R=Yes | I=High) = 0.6040 Lab 10: Implementing ANN Activation Functions with Bias Detection Introduction Artificial Neural Networks (ANNs) have revolutionized the field of machine learning and artificial intelligence by enabling computers to perform tasks that previously required human intelligence.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 132, "total_chunks": 184}}, {"id": 1032, "text": "At the heart of these networks lies a crucial component known as the activation function. Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 133, "total_chunks": 184}}, {"id": 1033, "text": "Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships. An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 134, "total_chunks": 184}}, {"id": 1034, "text": "An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer. The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 135, "total_chunks": 184}}, {"id": 1035, "text": "The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer. However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 136, "total_chunks": 184}}, {"id": 1036, "text": "However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems. Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 137, "total_chunks": 184}}, {"id": 1037, "text": "Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns. They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 138, "total_chunks": 184}}, {"id": 1038, "text": "They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics. By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 139, "total_chunks": 184}}, {"id": 1039, "text": "By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance. There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 140, "total_chunks": 184}}, {"id": 1040, "text": "There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 141, "total_chunks": 184}}, {"id": 1041, "text": "Choosing the appropriate activation function is critical, as it affects the network's convergence speed, stability, and overall performance. The selection often depends on the specific problem being addressed and the characteristics of the data.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 142, "total_chunks": 184}}, {"id": 1042, "text": "The selection often depends on the specific problem being addressed and the characteristics of the data. Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 143, "total_chunks": 184}}, {"id": 1043, "text": "Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications. Algorithm: Activation functions Sigmoid Activation Function Definition: The Sigmoid function, also known as the logistic function, maps any input to a value between 0 and 1.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 144, "total_chunks": 184}}, {"id": 1044, "text": "Algorithm: Activation functions Sigmoid Activation Function Definition: The Sigmoid function, also known as the logistic function, maps any input to a value between 0 and 1. It is defined as: Characteristics: Range: (0, 1) Smooth gradient: The output is smooth and continuous, which helps gradient-based optimization methods.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 145, "total_chunks": 184}}, {"id": 1045, "text": "It is defined as: Characteristics: Range: (0, 1) Smooth gradient: The output is smooth and continuous, which helps gradient-based optimization methods. Output bounds: Outputs values in a limited range, which can be interpreted as probabilities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 146, "total_chunks": 184}}, {"id": 1046, "text": "Output bounds: Outputs values in a limited range, which can be interpreted as probabilities. Derivatives: The derivative is simple and computationally efficient, given by: Advantages: Useful for binary classification problems as it can output probabilities. Activations are bounded, making it stable during forward and backward propagation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 147, "total_chunks": 184}}, {"id": 1047, "text": "Activations are bounded, making it stable during forward and backward propagation. Disadvantages: Vanishing gradient problem: When the input is very large or very small, the gradient can be extremely small, making it hard for the network to learn. Output not zero-centered: This can slow down the convergence of the gradient descent optimization.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 148, "total_chunks": 184}}, {"id": 1048, "text": "Output not zero-centered: This can slow down the convergence of the gradient descent optimization. Usage: Typically used in the output layer of binary classification models. 2.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 149, "total_chunks": 184}}, {"id": 1049, "text": "2. ReLU (Rectified Linear Unit) Activation Function Definition: The ReLU function is defined as: Characteristics: Range: [0, \u221e) Non-linear: Despite being piecewise linear, ReLU introduces non-linearity, which is crucial for learning complex patterns. Sparsity: Activations are sparse, meaning many neurons output 0, which can lead to efficient computation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 150, "total_chunks": 184}}, {"id": 1050, "text": "Sparsity: Activations are sparse, meaning many neurons output 0, which can lead to efficient computation. Advantages: Efficient computation: Simple and fast to compute. Alleviates the vanishing gradient problem: Unlike sigmoid and tanh, ReLU does not saturate for positive values.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 151, "total_chunks": 184}}, {"id": 1051, "text": "Alleviates the vanishing gradient problem: Unlike sigmoid and tanh, ReLU does not saturate for positive values. Disadvantages: Dying ReLU problem: Neurons can get \"stuck\" during training, outputting 0 for all inputs, and thus stop learning. Unbounded output: Can produce very large values, which might lead to numerical instability.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 152, "total_chunks": 184}}, {"id": 1052, "text": "Unbounded output: Can produce very large values, which might lead to numerical instability. Usage: Commonly used in the hidden layers of neural networks, especially in deep learning models. 3. Tanh (Hyperbolic Tangent) Activation Function Definition: The Tanh function maps the input to a value between -1 and 1.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 153, "total_chunks": 184}}, {"id": 1053, "text": "Tanh (Hyperbolic Tangent) Activation Function Definition: The Tanh function maps the input to a value between -1 and 1. It is defined as: Characteristics: Range: (-1, 1) Zero-centered output: Unlike the sigmoid, the outputs of the tanh function are centered around 0, which can help with convergence.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 154, "total_chunks": 184}}, {"id": 1054, "text": "It is defined as: Characteristics: Range: (-1, 1) Zero-centered output: Unlike the sigmoid, the outputs of the tanh function are centered around 0, which can help with convergence. Advantages: Zero-centered: Helps with convergence during training by producing zero-centered outputs. Stronger gradients: Compared to sigmoid, tanh can provide stronger gradients for backpropagation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 155, "total_chunks": 184}}, {"id": 1055, "text": "Stronger gradients: Compared to sigmoid, tanh can provide stronger gradients for backpropagation. Disadvantages: Vanishing gradient problem: Similar to sigmoid, tanh can suffer from the vanishing gradient problem for very large or very small inputs. Computationally more expensive: Slightly more expensive to compute compared to ReLU.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 156, "total_chunks": 184}}, {"id": 1056, "text": "Computationally more expensive: Slightly more expensive to compute compared to ReLU. Usage: Often used in hidden layers, especially when zero-centered outputs are beneficial. These activation functions are foundational to neural network design, each with its specific strengths and trade-offs.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 157, "total_chunks": 184}}, {"id": 1057, "text": "These activation functions are foundational to neural network design, each with its specific strengths and trade-offs. Understanding their characteristics helps in choosing the right activation function for a given task and architecture.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 158, "total_chunks": 184}}, {"id": 1058, "text": "Understanding their characteristics helps in choosing the right activation function for a given task and architecture.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 159, "total_chunks": 184}}, {"id": 1059, "text": "Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2. Train a single-neuron ANN (no hidden layers) using each activation function. 3. Analyze bias by comparing: - Output distribution (histogram of predictions). - Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 160, "total_chunks": 184}}, {"id": 1060, "text": "- Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 161, "total_chunks": 184}}, {"id": 1061, "text": "Class B: Task 3: Mitigation Strategies Experiment: Add a trainable bias term (`b`) to the neuron: Python Code: def forward(x, w, b, activation): return activation(np.dot(x, w) + b) Retrain and observe if bias reduces.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 162, "total_chunks": 184}}, {"id": 1062, "text": "|\") print(\"|---|----------------------|------------------------|------------------------|----------------|\") for row in results_with_bias: print(f\"| {row[0]} | {row[1]:<20} | {row[2]:<22} | {row[3]:<22} | {row[4]} |\") Output: Questions: Which activation function amplified bias the most? Why?", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 163, "total_chunks": 184}}, {"id": 1063, "text": "Why? Answer: ReLU showed the most bias, especially for negative inputs (Class B), outputting zero for all negative values and failing to capture variation. This is due to its zero output for all inputs < 0. How did the bias term affect ReLU vs. Sigmoid? Answer: For ReLU, the bias term helped shift the inputs into the positive range, reducing the dying neuron issue.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 164, "total_chunks": 184}}, {"id": 1064, "text": "Answer: For ReLU, the bias term helped shift the inputs into the positive range, reducing the dying neuron issue. For Sigmoid, the bias term slightly shifted the output curve but did not significantly change the bias since the sigmoid already compresses values. Can activation functions themselves be a source of algorithmic bias? Answer: Yes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 165, "total_chunks": 184}}, {"id": 1065, "text": "Answer: Yes. Functions like ReLU inherently favor positive values and ignore negative ones, creating asymmetry in output behavior. This can lead to algorithmic bias especially if data is not balanced or preprocessed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 166, "total_chunks": 184}}, {"id": 1066, "text": "This can lead to algorithmic bias especially if data is not balanced or preprocessed. Lab Week # 11 LAB 11: Building an NLP Pipeline \u2013 From Text to Intelligence using python Introduction Natural Language Processing (NLP) is a core area of Artificial Intelligence that enables machines to understand, interpret, and generate human language.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 167, "total_chunks": 184}}, {"id": 1067, "text": "Lab Week # 11 LAB 11: Building an NLP Pipeline \u2013 From Text to Intelligence using python Introduction Natural Language Processing (NLP) is a core area of Artificial Intelligence that enables machines to understand, interpret, and generate human language. In this hands-on lab, you will walk through the complete NLP pipeline\u2014from raw text to classification\u2014using Python.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 168, "total_chunks": 184}}, {"id": 1068, "text": "In this hands-on lab, you will walk through the complete NLP pipeline\u2014from raw text to classification\u2014using Python. You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 169, "total_chunks": 184}}, {"id": 1069, "text": "You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing. By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 170, "total_chunks": 184}}, {"id": 1070, "text": "By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 171, "total_chunks": 184}}, {"id": 1071, "text": "This lab is designed to give you a practical grip on how the theoretical components of the NLP pipeline translate into functioning code used in AI applications. Steps: Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels. data = [ (\"I loved the movie, it was fantastic!\", \"Positive\"), (\"The film was boring and slow\", \"Negative\"), # Add more samples...", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 172, "total_chunks": 184}}, {"id": 1072, "text": "data = [ (\"I loved the movie, it was fantastic!\", \"Positive\"), (\"The film was boring and slow\", \"Negative\"), # Add more samples... ] Preprocessing Pipeline (20 min) Tokenization Split each review into individual words. Stopword Removal Remove common words like \"the\", \"is\", \"and\", using NLTK or spaCy. Lemmatization Convert words to their base forms (e.g., \"running\" \u2192 \"run\").", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 173, "total_chunks": 184}}, {"id": 1073, "text": "Lemmatization Convert words to their base forms (e.g., \"running\" \u2192 \"run\").", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 174, "total_chunks": 184}}, {"id": 1074, "text": "Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer Vectorization Convert cleaned text into numerical format using: CountVectorizer or TF-IDF Vectorizer from sklearn.feature_extraction.text import CountVectorizer Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 175, "total_chunks": 184}}, {"id": 1075, "text": "from sklearn.naive_bayes import MultinomialNB from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score Evaluate Check accuracy on test data. Print 2\u20133 predictions for new reviews. Expected Output Cleaned and lemmatized reviews. A table showing transformed text vectors. Model accuracy score (e.g., 85%).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 176, "total_chunks": 184}}, {"id": 1076, "text": "Model accuracy score (e.g., 85%). Example predictions: Review: \"Absolutely amazing film!\" \u2192 Positive Review: \"Terrible and dull\" \u2192 Negative Code Result Lab Week # 12 LAB 12: Image Classification Using Artificial Neural Networks (ANN). Introduction In this lab, students will build an Artificial Neural Network (ANN) to classify handwritten digits (0\u20139) using the MNIST dataset.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 177, "total_chunks": 184}}, {"id": 1077, "text": "Introduction In this lab, students will build an Artificial Neural Network (ANN) to classify handwritten digits (0\u20139) using the MNIST dataset. Students will train the model, evaluate its accuracy, and test it with their own handwritten digit. Setup: Dataset MNIST Dataset: (given in separate file. 70,000 grayscale images (28\u00d728 pixels). 60,000 training + 10,000 test samples.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 178, "total_chunks": 184}}, {"id": 1078, "text": "60,000 training + 10,000 test samples. Each pixel value: 0 (black) to 255 (white). Library: TensorFlow/Keras, Matplotlib Editor: Any Python-supported IDE or Jupyter Notebook, Google Colab Steps:Algorithm: Step 1. Data Loading & Preprocessing: Load MNIST dataset (60,000 training + 10,000 test images). Normalize pixel values (0\u2013255 \u2192 0\u20131). Reshape images for ANN input (flatten 28x28 \u2192 784 pixels).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 179, "total_chunks": 184}}, {"id": 1079, "text": "Reshape images for ANN input (flatten 28x28 \u2192 784 pixels). One-hot encode labels (e.g., \"3\" \u2192 [0,0,0,1,0,0,0,0,0,0]). Step 2. Model Architecture (ANN): Input Layer: 784 neurons (1 per pixel). Hidden Layer(s): 1\u20132 dense layers with ReLU activation. Output Layer: 10 neurons (Softmax activation for probability distribution). Step 3.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 180, "total_chunks": 184}}, {"id": 1080, "text": "Step 3. Training & Evaluation: Compile model with `adam` optimizer and `categorical_crossentropy` loss. Train for 5\u201310 epochs and validate on test data. Evaluate accuracy and confusion matrix. Step 4. Custom Digit Testing: Draw a digit (using `matplotlib` or external image). Preprocess and predict using the trained model.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 181, "total_chunks": 184}}, {"id": 1081, "text": "Preprocess and predict using the trained model.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 182, "total_chunks": 184}}, {"id": 1082, "text": "(Yes/No) 1 | Sigmoid | 0.86 | 0.14 | Yes 2 | ReLU | 2.03 | 0.00 | Yes 3 | Leaky ReLU | 2.04 | -0.02 | Yes 4 | Tanh | 0.96 | -0.96 | Yes", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 183, "total_chunks": 184}}, {"id": 1083, "text": "DEPARTMENT OF COMPUTER SCIENCE & INFORMATION TECHNOLOGY UNIVERSITY OF ENGINEERING & TECHNOLOGY, PESHAWAR Lab Manual BS(CS) Spring 2025 Artificial Intelligence Table of Contents LAB 01 Implement Breadth-First Search (BFS) using Python ................................. 4 LAB 02 Implement Depth-First Search (DFS) using Python ....................................", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 0, "total_chunks": 184}}, {"id": 1084, "text": "4 LAB 02 Implement Depth-First Search (DFS) using Python .................................... 9 LAB 03 Implementation of River Crossing Puzzle ................................................... 13 LAB 04 Implement N-Puzzle Problem with Admissible Search (A*) ..................... 17 LAB 05 Solve the Traveling Salesman Problem (TSP) using Simulated Annealing ....", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 1, "total_chunks": 184}}, {"id": 1085, "text": "17 LAB 05 Solve the Traveling Salesman Problem (TSP) using Simulated Annealing .... 22 LAB 06 Implementation of Genetic Algorithm ............................................................ 26 LAB 07 Implement the Connect-Four Game using Minimax Algorithm .................. 30 LAB 08 Implement Class Scheduling using Constraint Satisfaction Problem ..........", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 2, "total_chunks": 184}}, {"id": 1086, "text": "30 LAB 08 Implement Class Scheduling using Constraint Satisfaction Problem .......... 35 LAB 09 Image Classification Using Artificial Neural Networks (ANN). Lab Evaluation Summary ..................................................................................................", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 3, "total_chunks": 184}}, {"id": 1087, "text": "Lab Evaluation Summary .................................................................................................. 4 Lab Week # 01 LAB 01: Implement Breadth-First Search BFS using Python Introduction Breadth-First Search (BFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 4, "total_chunks": 184}}, {"id": 1088, "text": "4 Lab Week # 01 LAB 01: Implement Breadth-First Search BFS using Python Introduction Breadth-First Search (BFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically. It operates by visiting all nodes in a graph level by level, starting from a designated source node.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 5, "total_chunks": 184}}, {"id": 1089, "text": "It operates by visiting all nodes in a graph level by level, starting from a designated source node.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 6, "total_chunks": 184}}, {"id": 1090, "text": "Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Dequeue a state current_state from the frontier.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 7, "total_chunks": 184}}, {"id": 1091, "text": "Main Loop: While the frontier is not empty: Dequeue a state current_state from the frontier. If current_state is the goal state, return the path to current_state. Add current_state to the explored set. For each action a in the set of legal actions applicable to current_state: Calculate the successor state next_state by applying action a to current_state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 8, "total_chunks": 184}}, {"id": 1092, "text": "For each action a in the set of legal actions applicable to current_state: Calculate the successor state next_state by applying action a to current_state. If next_state is not in frontier or explored: Enqueue next_state onto the frontier. Set the parent of next_state to current_state. Termination: If the frontier becomes empty without finding the goal state, return failure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 9, "total_chunks": 184}}, {"id": 1093, "text": "Termination: If the frontier becomes empty without finding the goal state, return failure. Task : Implement the above algorithm in Python for the following problem where 12 is the goal state. Solution: Step 1: Importing Required Libraries We import deque from collections to implement the queue structure. We use networkx for graph creation. We use matplotlib.pyplot for visualizing the graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 10, "total_chunks": 184}}, {"id": 1094, "text": "We use matplotlib.pyplot for visualizing the graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 11, "total_chunks": 184}}, {"id": 1095, "text": "A visited set keeps track of explored nodes. The function iterates until the queue is empty, exploring nodes level by level. If the goal is found, the shortest path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 12, "total_chunks": 184}}, {"id": 1096, "text": "If the goal is found, the shortest path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 13, "total_chunks": 184}}, {"id": 1097, "text": "start_node = 1 goal_node = 12 bfs_with_visualization(graph, start_node, goal_node) Output: Lab Week # 02 LAB 02: Implement Depth First Search using Python Introduction Depth-First Search (DFS) is a fundamental graph traversal algorithm used in Artificial Intelligence (AI) for exploring and discovering information systematically.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 14, "total_chunks": 184}}, {"id": 1098, "text": "Unlike BFS, which explores nodes level by level, DFS explores as far as possible along each branch before backtracking.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 15, "total_chunks": 184}}, {"id": 1099, "text": "DFS is widely employed in AI applications such as: Pathfinding State space exploration Solving Puzzle and Mazes By traversing the graph depth-wise, DFS is particularly useful for exploring all possible paths in a graph, making it ideal for problems like cycle detection, topological sorting, and solving constraint satisfaction problems.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 16, "total_chunks": 184}}, {"id": 1100, "text": "Algorithm: Depth-First Search (DFS) for Intelligent Agents Input: Problem: Representation of the problem domain, including initial state, actions, transition model, goal test, and cost function. Output: Solution: Sequence of actions that lead from the initial state to the goal state. Initialization: Initialize an empty queue frontier to store states to be explored.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 17, "total_chunks": 184}}, {"id": 1101, "text": "Initialization: Initialize an empty queue frontier to store states to be explored. Enqueue the initial state onto the frontier. Initialize an empty set explored to store visited states. Main Loop: While the frontier is not empty: Pop a node (current_node) from the frontier. o If current_node is the goal node, return the path to current_node. o Add current_node to the explored set.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 18, "total_chunks": 184}}, {"id": 1102, "text": "o Add current_node to the explored set. For each neighbor of current_node: If the neighbor is not in frontier or explored: Push the neighbor onto the frontier. Set the parent of the neighbor to current_node. Termination: \uf0b7 If the frontier becomes empty without finding the goal node, return failure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 19, "total_chunks": 184}}, {"id": 1103, "text": "Termination: \uf0b7 If the frontier becomes empty without finding the goal node, return failure. Explanation: break down the provided Breadth-First Search (BFS) algorithm for intelligent agents step by step: Initialization: We start by initializing a queue named frontier to keep track of states to be explored. We enqueue the initial state onto the frontier.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 20, "total_chunks": 184}}, {"id": 1104, "text": "We enqueue the initial state onto the frontier. An empty set explored is created to store visited states. Main Loop: We enter a loop that continues until the frontier is not empty. \uf0b7 Within each iteration of the loop: We dequeue a state current_state from the frontier. We check if current_state is the goal state by calling the Problem.goal_test(current_state) function.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 21, "total_chunks": 184}}, {"id": 1105, "text": "We check if current_state is the goal state by calling the Problem.goal_test(current_state) function. If it is, we return the path to this state. If current_state is not the goal state, we mark it as explored by adding it to the explored set. We iterate over all applicable actions for the current_state by calling Problem.actions(current_state).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 22, "total_chunks": 184}}, {"id": 1106, "text": "We iterate over all applicable actions for the current_state by calling Problem.actions(current_state). \uf0b7 For each action: We calculate the successor state next_state by applying the action to the current_state using the Problem.result(current_state, action) function. If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 23, "total_chunks": 184}}, {"id": 1107, "text": "If next_state is not already in the frontier or in the explored set: We enqueue next_state onto the frontier. We set the parent of next_state to current_state. This step is crucial for reconstructing the path once the goal state is found.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 24, "total_chunks": 184}}, {"id": 1108, "text": "This step is crucial for reconstructing the path once the goal state is found. Termination: If the frontier becomes empty without finding the goal state, we return failure, indicating that the goal state is unreachable from the initial state. Output: If the goal state is found during the search, we return the path from the initial state to the goal state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 25, "total_chunks": 184}}, {"id": 1109, "text": "Output: If the goal state is found during the search, we return the path from the initial state to the goal state. This path can be constructed by following the parent pointers from the goal state back to the initial state. Task : Implement the above algorithm in Python for the following problem where 10 is the goal state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 26, "total_chunks": 184}}, {"id": 1110, "text": "Task : Implement the above algorithm in Python for the following problem where 10 is the goal state. Solution: Step 1: Importing Required Libraries We import networkx for graph creation. We use matplotlib.pyplot for visualizing the graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 27, "total_chunks": 184}}, {"id": 1111, "text": "We use matplotlib.pyplot for visualizing the graph. import networkx as nx import matplotlib.pyplot as plt Step 2: Define the Graph as an Adjacency List The graph is represented as a dictionary where keys are node numbers, and values are lists of connected nodes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 28, "total_chunks": 184}}, {"id": 1112, "text": "import networkx as nx import matplotlib.pyplot as plt Step 2: Define the Graph as an Adjacency List The graph is represented as a dictionary where keys are node numbers, and values are lists of connected nodes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 29, "total_chunks": 184}}, {"id": 1113, "text": "graph = { 1: [2, 7, 8], 2: [3, 6], 3: [4, 5], 7: [], 8: [9, 12], 9: [10, 11], 12: [], 4: [], 5: [], 6: [], 10: [], 11: [] } Step 3: Define the DFS Function A stack is initialized with the start node. A visited set keeps track of explored nodes. The function iterates until the stack is empty, exploring nodes deep first. If the goal is found, the path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 30, "total_chunks": 184}}, {"id": 1114, "text": "If the goal is found, the path is displayed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 31, "total_chunks": 184}}, {"id": 1115, "text": "start_node = 1 goal_node = 10 dfs_with_visualization(graph, start_node, goal_node) Output: Task 2: Modify the given tree or create a custom tree and test the DFS implementation. Step 1: Define the Initial Tree The tree is represented as an adjacency list where each node has children.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 32, "total_chunks": 184}}, {"id": 1116, "text": "Step 1: Define the Initial Tree The tree is represented as an adjacency list where each node has children. initial_tree = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': [], 'F': [] } Step 2: Mo Modify the Tree Adding new nodes and edges to expand the tree structure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 33, "total_chunks": 184}}, {"id": 1117, "text": "initial_tree = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': [], 'F': [] } Step 2: Mo Modify the Tree Adding new nodes and edges to expand the tree structure.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 34, "total_chunks": 184}}, {"id": 1118, "text": "modified_tree = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F', 'G'], 'D': ['H'], 'E': [], 'F': [], 'G': ['I'], 'H': [], 'I': [] } Step 3: Define the DFS Function for the Modified Tree The DFS algorithm searches for the goal node in the expanded tree.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 35, "total_chunks": 184}}, {"id": 1119, "text": "start_node = 'A' goal_node = 'I' dfs_for_tree(modified_tree, start_node, goal_node) Step 5: Visualizing the Modified Tree \uf0b7Use networkx and matplotlib to visualize the updated tree.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 36, "total_chunks": 184}}, {"id": 1120, "text": "In this puzzle: A man wants to cross a river with three items: a wolf, a chicken, and a corn. The boat can carry a maximum of two entities (the man plus one item). Constraints: If the wolf and chicken are left alone without the man, the wolf will eat the chicken. If the chicken and corn are left alone without the man, the chicken will eat the corn.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 37, "total_chunks": 184}}, {"id": 1121, "text": "If the chicken and corn are left alone without the man, the chicken will eat the corn. Your task is to help the man safely transport all items to the other side of the river without violating the constraints. Problem Setup Entities: Man, Wolf, Chicken, Corn. Boat Capacity: Maximum of 2 (Man + 1 item). Constraints: Wolf cannot be left alone with Chicken. Chicken cannot be left alone with Corn.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 38, "total_chunks": 184}}, {"id": 1122, "text": "Chicken cannot be left alone with Corn. State Representation Each state can be represented as a tuple: (Man, Wolf, Chicken, Corn) Man: Left or Right (side of the river). Wolf, Chicken, Corn: Left or Right (side of the river).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 39, "total_chunks": 184}}, {"id": 1123, "text": "Wolf, Chicken, Corn: Left or Right (side of the river). Example: Initial State: ('Left', 'Left', 'Left', 'Left') Goal State: ('Right', 'Right', 'Right', 'Right') Task State-Space Search: Represent the problem as a state-space graph. Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 40, "total_chunks": 184}}, {"id": 1124, "text": "Use a search algorithm (e.g., BFS or DFS) to explore valid states and transitions. Find a Valid Sequence: Find a sequence of moves that transports all items to the right side of the river without violating the constraints. Implement the Solution: Write a Python program to solve the puzzle. Solution: Step 1: Import Required Libraries deque from collections is used for BFS queue management.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 41, "total_chunks": 184}}, {"id": 1125, "text": "Solution: Step 1: Import Required Libraries deque from collections is used for BFS queue management. from collections import deque Step 2: Define the Initial and Goal States The initial state has all items on the left side. The goal state has all items on the right side.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 42, "total_chunks": 184}}, {"id": 1126, "text": "The goal state has all items on the right side. initial_state = ({'F', 'W', 'G', 'C'}, set(), 'left') goal_state = (set(), {'F', 'W', 'G', 'C'}, 'right') Step 3: Define a Function to Check State Validity This function ensures that no constraints are violated in a given state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 43, "total_chunks": 184}}, {"id": 1127, "text": "initial_state = ({'F', 'W', 'G', 'C'}, set(), 'left') goal_state = (set(), {'F', 'W', 'G', 'C'}, 'right') Step 3: Define a Function to Check State Validity This function ensures that no constraints are violated in a given state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 44, "total_chunks": 184}}, {"id": 1128, "text": "_state = ({'F', 'W', 'G', 'C'}, set(), 'left') goal_state = (set(), {'F', 'W', 'G', 'C'}, 'right') Step 3: Define a Function to Check State Validity \uf0b7This function ensures that no constraints are violated in a given state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 45, "total_chunks": 184}}, {"id": 1129, "text": "solution = bfs(initial_state, goal_state) Step 7: Print the Solution Display the sequence of valid moves. if solution: print(\"Solution Found!\") for step, state in enumerate(solution): print(f\"Step {step}: {state}\") else: print(\"No solution found.\") Explanation How the Algorithm Works: The algorithm starts from the initial state and generates all possible next states.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 46, "total_chunks": 184}}, {"id": 1130, "text": "if solution: print(\"Solution Found!\") for step, state in enumerate(solution): print(f\"Step {step}: {state}\") else: print(\"No solution found.\") Explanation How the Algorithm Works: The algorithm starts from the initial state and generates all possible next states. It checks each new state for validity to ensure no constraints are violated.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 47, "total_chunks": 184}}, {"id": 1131, "text": "It checks each new state for validity to ensure no constraints are violated. Breadth-First Search (BFS) ensures that the shortest sequence of moves is found. Why the Solution is Valid: The algorithm ensures that: The wolf and goat are never left alone. The goat and cabbage are never left alone. The farmer is always controlling interactions between animals and items.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 48, "total_chunks": 184}}, {"id": 1132, "text": "The farmer is always controlling interactions between animals and items.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 49, "total_chunks": 184}}, {"id": 1133, "text": "In this implementation, we will focus on the 8-puzzle variant, where the puzzle is divided into a 3x3 grid with eight numbered tiles and one empty space. We'll use the A* search algorithm to efficiently find the shortest path from the initial state to the goal state. Learning Objectives Understand the N-Puzzle problem and its rules. Implement the A* search algorithm in Python.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 50, "total_chunks": 184}}, {"id": 1134, "text": "Implement the A* search algorithm in Python. Learn how to represent states, actions, and transitions in the N-Puzzle problem. Gain experience in solving optimization problems using heuristic search techniques. Steps: Algorithm: A* search Input: Receive the initial and goal configurations of the puzzle. Output: Display the steps required to reach the goal state from the initial state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 51, "total_chunks": 184}}, {"id": 1135, "text": "Output: Display the steps required to reach the goal state from the initial state. Explanation: 1. INPUT: - Define the problem domain including the initial state and the goal state of the puzzle. - Define the actions applicable to each state, the transition model, the goal test, and the cost function. 2. OUTPUT: - Return the sequence of actions that lead from the initial state to the goal state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 52, "total_chunks": 184}}, {"id": 1136, "text": "OUTPUT: - Return the sequence of actions that lead from the initial state to the goal state. 3. INITIALIZATION: - Initialize an empty priority queue frontier to store states to be explored. - Enqueue the initial state onto the frontier with a priority of 0. - Initialize an empty set explored to store visited states. 4.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 53, "total_chunks": 184}}, {"id": 1137, "text": "4. MAIN LOOP: - While the frontier is not empty: - Dequeue a state from the frontier. - If the dequeued state is the goal state, return the sequence of actions leading to it. - Add the dequeued state to the explored set. - For each action applicable to the current state: - Calculate the successor state by applying the action.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 54, "total_chunks": 184}}, {"id": 1138, "text": "- For each action applicable to the current state: - Calculate the successor state by applying the action. - If the successor state has not been explored or enqueued: - Enqueue the successor state onto the frontier with a priority calculated using the A* heuristic. - Set the parent of the successor state to the current state.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 55, "total_chunks": 184}}, {"id": 1139, "text": "- Set the parent of the successor state to the current state. TERMINATION: - If the frontier becomes empty without finding the goal state, return failure. Algorithm studied in theory class for more understanding. Explanation Explanation: N-Puzzle or sliding puzzle is a popular puzzle that consists of N tiles where N can be 8, 15, 24 and so on. In our example N = 8.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 56, "total_chunks": 184}}, {"id": 1140, "text": "In our example N = 8. The puzzle is divided into sqrt(N+1) rows and sqrt(N+1) columns. Eg. 15-Puzzle will have 4 rows and 4 columns and an 8-Puzzle will have 3 rows and 3 columns. The puzzle consists of N tiles and one empty space where the tiles can be moved. Start and Goal configurations (also called state) of the puzzle are provided.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 57, "total_chunks": 184}}, {"id": 1141, "text": "Start and Goal configurations (also called state) of the puzzle are provided. The puzzle can be solved by moving the tiles one by one in the single empty space and thus achieving the Goal configuration. Rules for solving the puzzle. Instead of moving the tiles in the empty space we can visualize moving the empty space in place of the tile, basically swapping the tile with the empty space.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 58, "total_chunks": 184}}, {"id": 1142, "text": "Instead of moving the tiles in the empty space we can visualize moving the empty space in place of the tile, basically swapping the tile with the empty space. The empty space can only move in four directions viz., 1. Up 2.Down 3. Right or 4. Left The empty space cannot move diagonally and can take only one step at a time (i.e. move the empty space one position at a time).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 59, "total_chunks": 184}}, {"id": 1143, "text": "move the empty space one position at a time). The tiles in the initial(start) state can be moved in the empty space in a particular order and thus achieve the goal state. The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 60, "total_chunks": 184}}, {"id": 1144, "text": "The A* search algorithm is an informed search algorithm that finds the shortest path or solution to a problem while also considering the cost of reaching the solution. It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 61, "total_chunks": 184}}, {"id": 1145, "text": "It's widely used in pathfinding and graph traversal problems, such as solving puzzles, finding routes, and AI search problems. A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 62, "total_chunks": 184}}, {"id": 1146, "text": "A* combines the principles of Dijkstra's algorithm and Best-First Search by using a heuristic to guide its search. It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 63, "total_chunks": 184}}, {"id": 1147, "text": "It searches the space of possible solutions by evaluating and prioritizing nodes based on a combination of two costs: Path Cost (g): The actual cost to reach a node from the start node. Heuristic Cost (h): An estimated cost from the current node to the goal node (often called the heuristic function). The key to A*'s efficiency lies in its selection of nodes to explore.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 64, "total_chunks": 184}}, {"id": 1148, "text": "The key to A*'s efficiency lies in its selection of nodes to explore. At each step, it chooses the node that minimizes the sum of the path cost g and the estimated remaining cost to the goal h (often represented as f = g + h). This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 65, "total_chunks": 184}}, {"id": 1149, "text": "This makes A* an admissible search algorithm because it guarantees finding the shortest path in a graph with an optimal heuristic function. Task : Implement the above algorithm in Python for the following problem the N-Puzzle. Where Code Implementation Step 1: Define the Problem Representation The puzzle is represented as a 3x3 matrix.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 66, "total_chunks": 184}}, {"id": 1150, "text": "Where Code Implementation Step 1: Define the Problem Representation The puzzle is represented as a 3x3 matrix. The Manhattan Distance heuristic measures how far tiles are from their goal positions.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 67, "total_chunks": 184}}, {"id": 1151, "text": "The Manhattan Distance heuristic measures how far tiles are from their goal positions.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 68, "total_chunks": 184}}, {"id": 1152, "text": "copy def manhattan_distance(state): distance = 0 for i in range(3): for j in range(3): if state[i][j] != 0: goal_row, goal_col = divmod(state[i][j] - 1, 3) distance += abs(i - goal_row) + abs(j - goal_col) return distance Step 2: Generate Neighboring States The function finds valid moves for the empty tile (0) and returns possible next states.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 69, "total_chunks": 184}}, {"id": 1153, "text": "This lab explores solving TSP using the Simulated Annealing (SA) algorithm and analyzing its performance. Algorithm: Input: A set of cities with random (x, y) coordinates. Distance function (e.g., Euclidean distance) to evaluate the path cost. Output: Optimized path with the shortest distance. Graphical representation of the final tour. Initialization: Generate an initial random tour.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 70, "total_chunks": 184}}, {"id": 1154, "text": "Initialization: Generate an initial random tour. Set initial temperature and cooling rate for Simulated Annealing. Define an acceptance probability function. Main Loop: Iteratively swap cities in the tour to generate a new solution. Evaluate the cost difference between current and new solutions. Accept the new solution based on the probability function.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 71, "total_chunks": 184}}, {"id": 1155, "text": "Accept the new solution based on the probability function. Gradually reduce the temperature until termination conditions are met Termination: Stop when the temperature reaches a predefined threshold. Return the best solution found. Task Implement Simulated Annealing (SA) to solve TSP. Visualize the computed shortest tour.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 72, "total_chunks": 184}}, {"id": 1156, "text": "Visualize the computed shortest tour. Analyze performance based on: Path length Execution time Number of iterations Extend the problem to 100 cities and compare results. Implement Tabu Search and evaluate its effectiveness against SA. Solution of Task: Import Necessary Libraries: These libraries are used for numerical operations, plotting, randomness, and time measurement.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 73, "total_chunks": 184}}, {"id": 1157, "text": "Solution of Task: Import Necessary Libraries: These libraries are used for numerical operations, plotting, randomness, and time measurement. Generate Random Cities: His function creates n random cities represented as (x, y) coordinates. Compute Distance Between Two Cities: Calculates the Euclidean distance between two given cities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 74, "total_chunks": 184}}, {"id": 1158, "text": "Compute Distance Between Two Cities: Calculates the Euclidean distance between two given cities. Compute Total Distance of a Tour: Finds the total distance of a given tour by summing up distances between consecutive cities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 75, "total_chunks": 184}}, {"id": 1159, "text": "Compute Total Distance of a Tour: Finds the total distance of a given tour by summing up distances between consecutive cities. Simulated Annealing Algorithm: Uses Simulated Annealing to find an optimal TSP tour by gradually lowering the temperature and allowing occasional worse solutions to escape local optima.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 76, "total_chunks": 184}}, {"id": 1160, "text": "Simulated Annealing Algorithm: Uses Simulated Annealing to find an optimal TSP tour by gradually lowering the temperature and allowing occasional worse solutions to escape local optima.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 77, "total_chunks": 184}}, {"id": 1161, "text": "Run Simulated Annealing for 20 and 100 Cities: Executes the SA algorithm for 20 and 100 cities and displays results.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 78, "total_chunks": 184}}, {"id": 1162, "text": "Genetic Algorithms (GAs) are evolutionary algorithms inspired by natural selection and genetics, commonly used to solve optimization and search problems. Algorithm: Genetic Algorithm Input: A set of cities with their coordinates. Population size. Crossover rate Mutation rate. Termination condition (e.g., maximum number of generations, convergence criteria).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 79, "total_chunks": 184}}, {"id": 1163, "text": "Termination condition (e.g., maximum number of generations, convergence criteria). Output: The best route found (shortest tour) that visits each city exactly once and returns to the original city. Initialization: 1. Create Initial Population: Generate an initial population of candidate solutions (chromosomes).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 80, "total_chunks": 184}}, {"id": 1164, "text": "Create Initial Population: Generate an initial population of candidate solutions (chromosomes). Each chromosome represents a possible route for the salesman, typically represented as a permutation of city indices. 2.Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 81, "total_chunks": 184}}, {"id": 1165, "text": "2.Evaluate Fitness: Calculate the fitness of each chromosome based on the total distance traveled for the corresponding route. Main Loop: 1.Repeat until Termination Condition is met: 2.Selection: Perform Roulette Wheel Selection: Select parents for mating based on their fitness. The probability of selection is proportional to the fitness of each chromosome.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 82, "total_chunks": 184}}, {"id": 1166, "text": "The probability of selection is proportional to the fitness of each chromosome. 3.Crossover: Apply Crossover Operation: Generate offspring by combining genetic material (routes) from selected parents. Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 83, "total_chunks": 184}}, {"id": 1167, "text": "Commonly used crossovers are Order Crossover (OX), Partially Mapped Crossover (PMX), etc. 4.Mutation: Introduce Mutation: Randomly alter some chromosomes in the offspring population to maintain diversity. For TSP, swapping cities in a route is a typical mutation. 5.Evaluate Fitness: Calculate the fitness of each offspring. 6.Replacement: Select individuals for the next generation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 84, "total_chunks": 184}}, {"id": 1168, "text": "6.Replacement: Select individuals for the next generation. This could involve elitism (keeping the best solutions from the current generation) or replacing the entire population. 7.Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 85, "total_chunks": 184}}, {"id": 1169, "text": "7.Termination: Stop when a termination condition is met, such as reaching a maximum number of generations or achieving convergence (e.g., no significant improvement over several generations). Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 86, "total_chunks": 184}}, {"id": 1170, "text": "Explanation: Genetic Algorithms iteratively improve solutions over generations through the principles of natural selection, crossover, and mutation. Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 87, "total_chunks": 184}}, {"id": 1171, "text": "Roulette Wheel Selection Method biases the selection of parents towards fitter individuals, increasing the likelihood of propagating better solutions to the next generation. Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 88, "total_chunks": 184}}, {"id": 1172, "text": "Through the iterative process of selection, crossover, and mutation, the algorithm converges towards an optimal or near-optimal solution for the TSP. The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 89, "total_chunks": 184}}, {"id": 1173, "text": "The final output is the best route found, which represents the shortest tour that visits each city exactly once and returns to the original city. Task :Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 90, "total_chunks": 184}}, {"id": 1174, "text": "Task :Implement the given travelling salesman problem with GA algorithm using Python An e-commerce company in Pakistan wants to optimize its delivery routes for nationwide order fulfillment. The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 91, "total_chunks": 184}}, {"id": 1175, "text": "The company has 10 major warehouses in different cities, and delivery trucks need to visit all of them exactly once before returning to the starting point. The goal is to find the shortest route that minimizes fuel costs and travel time using a Genetic Algorithm (GA). List of Cities (Warehouses) in Pakistan.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 92, "total_chunks": 184}}, {"id": 1176, "text": "List of Cities (Warehouses) in Pakistan. Consider 10 major cities with approximate road distances (in kilometers) between them: Step 1: Load City Distance Data Loads city names and distance matrix from a CSV and JSON file for the Traveling Salesman Problem (TSP).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 93, "total_chunks": 184}}, {"id": 1177, "text": "Consider 10 major cities with approximate road distances (in kilometers) between them: Step 1: Load City Distance Data Loads city names and distance matrix from a CSV and JSON file for the Traveling Salesman Problem (TSP).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 94, "total_chunks": 184}}, {"id": 1178, "text": "def calculate_route_distance(route): \"\"\"Calculate total distance of a given route\"\"\" total_distance = sum(distance_matrix[route[i], route[i + 1]] for i in range(len(route) - 1)) total_distance += distance_matrix[route[-1], route[0]] # Return to starting city return total_distance Step 3: Selection Mechanism Uses Roulette Wheel Selection to probabilistically select the best routes for reproduction.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 95, "total_chunks": 184}}, {"id": 1179, "text": "def swap_mutation(route): \"\"\"Perform swap mutation by randomly swapping two cities\"\"\" a, b = random.sample(range(len(route)), 2) route[a], route[b] = route[b], route[a] return route Step 6: Genetic Algorithm Execution Runs the Genetic Algorithm for multiple generations, selecting, crossing over, and mutating routes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 96, "total_chunks": 184}}, {"id": 1180, "text": "# Run the algorithm best_route, best_distance = genetic_algorithm() # Display resultsprint(\"Optimized Route:\")print([city_names[i] for i in best_route])print(\"Total Distance:\", best_distance) Output: Step 8: Visualization Uses NetworkX and Matplotlib to display the optimized delivery route as a graph.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 97, "total_chunks": 184}}, {"id": 1181, "text": "Comparison of Initial vs. Optimized Routes (route_comparison.png) \u2192 Visualizes the reduction in total distance. Performance Analysis (performance_report.txt) \u2192 Records execution time, final optimized distance, and areas for improvement. Limitations & Future Improvements \u2192 Suggests enhancements like better mutation strategies, additional crossover techniques, and parallel execution for efficiency.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 98, "total_chunks": 184}}, {"id": 1182, "text": "Limitations & Future Improvements \u2192 Suggests enhancements like better mutation strategies, additional crossover techniques, and parallel execution for efficiency.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 99, "total_chunks": 184}}, {"id": 1183, "text": "Optimized Route plt.figure(figsize=(10, 5)) plt.bar([\"Initial Route\", \"Optimized Route\"], [max(fitness_over_generations), best_distance], color=[\"red\", \"green\"]) plt.ylabel(\"Total Distance\") plt.title(\"Comparison of Initial vs.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 100, "total_chunks": 184}}, {"id": 1184, "text": "Advanced Crossover Techniques \u2192 Experiment with different methods for better convergence. Parallel Execution \u2192 Utilize multi-threading or GPU acceleration for faster computation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 101, "total_chunks": 184}}, {"id": 1185, "text": "Parallel Execution \u2192 Utilize multi-threading or GPU acceleration for faster computation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 102, "total_chunks": 184}}, {"id": 1186, "text": "Lab Week # 07 LAB 07: Implement the connect-four game using minmax algorithm with python language Introduction Connect Four is a classic two-player strategy game where players take turns dropping colored discs into a vertical grid with the goal of connecting four of their own discs in a row, either horizontally, vertically, or diagonally.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 103, "total_chunks": 184}}, {"id": 1187, "text": "Implementing Connect Four with the Minimax algorithm provides an excellent opportunity to delve into the field of artificial intelligence and game theory. The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 104, "total_chunks": 184}}, {"id": 1188, "text": "The Minimax algorithm is a decision-making algorithm commonly used in adversarial games, like Connect Four, to determine the optimal moves for players while considering the potential outcomes of each decision. Setup: The game board is positioned vertically, with six rows and seven columns. Each player is assigned a color, typically red and yellow. But this time we choose Green and Yellow instead.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 105, "total_chunks": 184}}, {"id": 1189, "text": "But this time we choose Green and Yellow instead. The game begins with an empty board. Gameplay: Players take turns dropping one of their colored discs into any column of the board. The disc falls to the lowest available empty cell in the selected column.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 106, "total_chunks": 184}}, {"id": 1190, "text": "The disc falls to the lowest available empty cell in the selected column. Players alternate turns until one player achieves a winning four-in-a-row line or the board is completely filled without a winner (resulting in a draw). Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 107, "total_chunks": 184}}, {"id": 1191, "text": "Winning: A player wins the game if they successfully connect four of their colored discs either horizontally, vertically, or diagonally. The game ends immediately once a winning condition is met. Steps: Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 108, "total_chunks": 184}}, {"id": 1192, "text": "Steps: Algorithm: Minimax algorithm for Connect-Four Input: The number of rows and columns for the game board (typically 6 rows and 7 columns in Connect Four). The choice of colors for Player 1 and Player 2 (e.g., \"Green\" and \"Yellow\"). The option to choose between two human players or one human player and one AI player. Game must include both options.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 109, "total_chunks": 184}}, {"id": 1193, "text": "Game must include both options. Output: Display the game board after each move. Inform the players when a player wins, loses, or when the game ends in a draw. Prompt the players for their moves (column number to drop their disc into). INITIALIZATION: Create a 2D array to represent the game board with the specified number of rows and columns. Initialize the game board with empty cells.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 110, "total_chunks": 184}}, {"id": 1194, "text": "Initialize the game board with empty cells. Assign colors to Player 1 and Player 2. MAIN LOOP: Display the initial empty game board. Repeat the following steps until the game ends: Prompt the current player for their move (column number to drop their disc into). Update the game board with the player's move. Check for a winning condition (four connected discs in a row).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 111, "total_chunks": 184}}, {"id": 1195, "text": "Check for a winning condition (four connected discs in a row). If a winning condition is met, declare the current player as the winner and end the game. - Check for a draw condition (all cells on the board are filled without a winner). If a draw condition is met, end the game with a draw. Switch to the next player. TERMINATION: Display the final game board. If a player wins, announce the winner.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 112, "total_chunks": 184}}, {"id": 1196, "text": "If a player wins, announce the winner. If the game ends in a draw, announce the draw. End the game.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 113, "total_chunks": 184}}, {"id": 1197, "text": "End the game.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 114, "total_chunks": 184}}, {"id": 1198, "text": "It can be implemented in various programming languages, adapting the syntax and specific functionalities accordingly. Task : Implement the above algorithm in Python for the following problem the Connect -Four Game for a grid of 12X12. Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 115, "total_chunks": 184}}, {"id": 1199, "text": "Player A is assigned \u201cGreen\u201d while Player B is assigned Yellow Color.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 116, "total_chunks": 184}}, {"id": 1200, "text": "class scheduling, we often face constraints that make manual planning Bayesian Networks (BNs) are powerful probabilistic models that represent dependencies among variables using directed acyclic graphs (DAGs). They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 117, "total_chunks": 184}}, {"id": 1201, "text": "They are widely used in decision-making systems, medical diagnosis, risk assessment, and artificial intelligence. In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 118, "total_chunks": 184}}, {"id": 1202, "text": "In this lab, students will construct a BN to predict a student's exam performance based on factors like intelligence, exam difficulty, preparation level, and recommendation letter eligibility. Learning Objectives By the end of this lab, students will be able to: Understand the structure and components of a Bayesian Network. Define conditional probability tables (CPTs) for given dependencies.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 119, "total_chunks": 184}}, {"id": 1203, "text": "Define conditional probability tables (CPTs) for given dependencies. Compute joint and marginal probabilities using the BN. (Optional) Implement the BN in Python using pgmpy.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 120, "total_chunks": 184}}, {"id": 1204, "text": "(Optional) Implement the BN in Python using pgmpy. Steps of Algorithm: Step 1: INITIALIZATION Initialization Define the random variables: D: Exam Difficulty (Hard, Easy) I: Intelligence (High, Low) P: Preparation (Good, Poor) S: Exam Score (Pass, Fail) R: Recommendation Letter (Yes, No) Establish dependencies: D, I, and P influence S. S influences R.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 121, "total_chunks": 184}}, {"id": 1205, "text": "S influences R. Step 2: MAIN LOOP (STEP-BY-STEP CONSTRUCTION) Step 1: Draw the Bayesian Network Structure (DAG) Represent nodes and add edges: add directed arrows as per dependencies.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 122, "total_chunks": 184}}, {"id": 1206, "text": "Step 2: MAIN LOOP (STEP-BY-STEP CONSTRUCTION) Step 1: Draw the Bayesian Network Structure (DAG) Represent nodes and add edges: add directed arrows as per dependencies.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 123, "total_chunks": 184}}, {"id": 1207, "text": "(Define other CPTs) model.add_cpds(cpd_d, ...) # Perform inference from pgmpy.inference import VariableElimination infer = VariableElimination(model) result = infer.query(variables=['R'], evidence={'I': 'High'}) print(result) 3. Termination Verify computed probabilities match expected reasoning. Ensure all CPTs are correctly defined.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 124, "total_chunks": 184}}, {"id": 1208, "text": "Ensure all CPTs are correctly defined. (If implemented) Confirm Python output aligns with manual calculations. Problem Statement Given the BN for student performance: Construct the DAG and CPTs. Compute P(R=Yes | I=High) manually. Implement the BN in Python and compare results. Deliverables Draw digital BN structure. Completed CPTs with assigned probabilities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 125, "total_chunks": 184}}, {"id": 1209, "text": "Completed CPTs with assigned probabilities. Step-by-step probability calculation for the query. Python code and output. Upload the solution 1.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 126, "total_chunks": 184}}, {"id": 1210, "text": "Upload the solution 1. Digital BN Structure (DAG) Here's the Bayesian Network structure: [D] [I] [P] \\ | / \\ | / [S] | [R] Nodes: D: Exam Difficulty (Hard, Easy) I: Intelligence (High, Low) P: Preparation (Good, Poor) S: Exam Score (Pass, Fail) R: Recommendation Letter (Yes, No) Edges: D \u2192 S I \u2192 S P \u2192 S S \u2192 R 2.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 127, "total_chunks": 184}}, {"id": 1211, "text": "Digital BN Structure (DAG) Here's the Bayesian Network structure: [D] [I] [P] \\ | / \\ | / [S] | [R] Nodes: D: Exam Difficulty (Hard, Easy) I: Intelligence (High, Low) P: Preparation (Good, Poor) S: Exam Score (Pass, Fail) R: Recommendation Letter (Yes, No) Edges: D \u2192 S I \u2192 S P \u2192 S S \u2192 R 2.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 128, "total_chunks": 184}}, {"id": 1212, "text": "Completed CPTs with Assigned Probabilities P(D): Exam Difficulty P(I): Intelligence P(P): Preparation P(S|D,I,P): Exam Score D I P P(S=Pass) P(S=Fail) P(R|S): Recommendation Letter 3.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 129, "total_chunks": 184}}, {"id": 1213, "text": "Step-by-Step Probability Calculation for P(R=Yes | I=High) To compute P(R=Yes | I=High), we need to marginalize over all other variables: Expand using chain rule: P(R=Yes | I=High) = \u03a3_D,P,S P(R=Yes|S) \u00d7 P(S|D,I=High,P) \u00d7 P(D) \u00d7 P(P) Calculate for all combinations: There are 2 (D) \u00d7 2 (P) \u00d7 2 (S) = 8 combinations to consider.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 130, "total_chunks": 184}}, {"id": 1214, "text": "Python Implementation and Output Jupyter File are Aploaded Python Output: 5.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 131, "total_chunks": 184}}, {"id": 1215, "text": "Comparison of Results Manual Calculation: P(R=Yes | I=High) = 0.604 Python Output: P(R=Yes | I=High) = 0.6040 Lab 10: Implementing ANN Activation Functions with Bias Detection Introduction Artificial Neural Networks (ANNs) have revolutionized the field of machine learning and artificial intelligence by enabling computers to perform tasks that previously required human intelligence.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 132, "total_chunks": 184}}, {"id": 1216, "text": "At the heart of these networks lies a crucial component known as the activation function. Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 133, "total_chunks": 184}}, {"id": 1217, "text": "Activation functions play a pivotal role in the functioning of ANNs, transforming the linear outputs of neurons into complex, non-linear patterns that enable the network to learn and model intricate data relationships. An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 134, "total_chunks": 184}}, {"id": 1218, "text": "An ANN is composed of layers of interconnected neurons, where each neuron receives input, processes it, and passes the output to the next layer. The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 135, "total_chunks": 184}}, {"id": 1219, "text": "The process begins with the input layer, traverses through one or more hidden layers, and finally reaches the output layer. However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 136, "total_chunks": 184}}, {"id": 1220, "text": "However, without activation functions, this process would merely be a series of linear transformations, limiting the network's ability to solve complex problems. Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 137, "total_chunks": 184}}, {"id": 1221, "text": "Activation functions introduce non-linearity into the network, allowing it to capture and represent a wide range of data patterns. They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 138, "total_chunks": 184}}, {"id": 1222, "text": "They enable neurons to learn and represent intricate features of the input data, making it possible for the network to tackle tasks such as image recognition, natural language processing, and predictive analytics. By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 139, "total_chunks": 184}}, {"id": 1223, "text": "By determining whether a neuron should be activated or not, activation functions directly influence the network's learning capabilities and performance. There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 140, "total_chunks": 184}}, {"id": 1224, "text": "There are various types of activation functions, each with its unique properties and applications.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 141, "total_chunks": 184}}, {"id": 1225, "text": "Choosing the appropriate activation function is critical, as it affects the network's convergence speed, stability, and overall performance. The selection often depends on the specific problem being addressed and the characteristics of the data.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 142, "total_chunks": 184}}, {"id": 1226, "text": "The selection often depends on the specific problem being addressed and the characteristics of the data. Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 143, "total_chunks": 184}}, {"id": 1227, "text": "Understanding and leveraging the power of activation functions is essential for designing effective and efficient neural networks that can achieve state-of-the-art results in various applications. Algorithm: Activation functions Sigmoid Activation Function Definition: The Sigmoid function, also known as the logistic function, maps any input to a value between 0 and 1.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 144, "total_chunks": 184}}, {"id": 1228, "text": "Algorithm: Activation functions Sigmoid Activation Function Definition: The Sigmoid function, also known as the logistic function, maps any input to a value between 0 and 1. It is defined as: Characteristics: Range: (0, 1) Smooth gradient: The output is smooth and continuous, which helps gradient-based optimization methods.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 145, "total_chunks": 184}}, {"id": 1229, "text": "It is defined as: Characteristics: Range: (0, 1) Smooth gradient: The output is smooth and continuous, which helps gradient-based optimization methods. Output bounds: Outputs values in a limited range, which can be interpreted as probabilities.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 146, "total_chunks": 184}}, {"id": 1230, "text": "Output bounds: Outputs values in a limited range, which can be interpreted as probabilities. Derivatives: The derivative is simple and computationally efficient, given by: Advantages: Useful for binary classification problems as it can output probabilities. Activations are bounded, making it stable during forward and backward propagation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 147, "total_chunks": 184}}, {"id": 1231, "text": "Activations are bounded, making it stable during forward and backward propagation. Disadvantages: Vanishing gradient problem: When the input is very large or very small, the gradient can be extremely small, making it hard for the network to learn. Output not zero-centered: This can slow down the convergence of the gradient descent optimization.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 148, "total_chunks": 184}}, {"id": 1232, "text": "Output not zero-centered: This can slow down the convergence of the gradient descent optimization. Usage: Typically used in the output layer of binary classification models. 2.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 149, "total_chunks": 184}}, {"id": 1233, "text": "2. ReLU (Rectified Linear Unit) Activation Function Definition: The ReLU function is defined as: Characteristics: Range: [0, \u221e) Non-linear: Despite being piecewise linear, ReLU introduces non-linearity, which is crucial for learning complex patterns. Sparsity: Activations are sparse, meaning many neurons output 0, which can lead to efficient computation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 150, "total_chunks": 184}}, {"id": 1234, "text": "Sparsity: Activations are sparse, meaning many neurons output 0, which can lead to efficient computation. Advantages: Efficient computation: Simple and fast to compute. Alleviates the vanishing gradient problem: Unlike sigmoid and tanh, ReLU does not saturate for positive values.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 151, "total_chunks": 184}}, {"id": 1235, "text": "Alleviates the vanishing gradient problem: Unlike sigmoid and tanh, ReLU does not saturate for positive values. Disadvantages: Dying ReLU problem: Neurons can get \"stuck\" during training, outputting 0 for all inputs, and thus stop learning. Unbounded output: Can produce very large values, which might lead to numerical instability.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 152, "total_chunks": 184}}, {"id": 1236, "text": "Unbounded output: Can produce very large values, which might lead to numerical instability. Usage: Commonly used in the hidden layers of neural networks, especially in deep learning models. 3. Tanh (Hyperbolic Tangent) Activation Function Definition: The Tanh function maps the input to a value between -1 and 1.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 153, "total_chunks": 184}}, {"id": 1237, "text": "Tanh (Hyperbolic Tangent) Activation Function Definition: The Tanh function maps the input to a value between -1 and 1. It is defined as: Characteristics: Range: (-1, 1) Zero-centered output: Unlike the sigmoid, the outputs of the tanh function are centered around 0, which can help with convergence.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 154, "total_chunks": 184}}, {"id": 1238, "text": "It is defined as: Characteristics: Range: (-1, 1) Zero-centered output: Unlike the sigmoid, the outputs of the tanh function are centered around 0, which can help with convergence. Advantages: Zero-centered: Helps with convergence during training by producing zero-centered outputs. Stronger gradients: Compared to sigmoid, tanh can provide stronger gradients for backpropagation.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 155, "total_chunks": 184}}, {"id": 1239, "text": "Stronger gradients: Compared to sigmoid, tanh can provide stronger gradients for backpropagation. Disadvantages: Vanishing gradient problem: Similar to sigmoid, tanh can suffer from the vanishing gradient problem for very large or very small inputs. Computationally more expensive: Slightly more expensive to compute compared to ReLU.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 156, "total_chunks": 184}}, {"id": 1240, "text": "Computationally more expensive: Slightly more expensive to compute compared to ReLU. Usage: Often used in hidden layers, especially when zero-centered outputs are beneficial. These activation functions are foundational to neural network design, each with its specific strengths and trade-offs.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 157, "total_chunks": 184}}, {"id": 1241, "text": "These activation functions are foundational to neural network design, each with its specific strengths and trade-offs. Understanding their characteristics helps in choosing the right activation function for a given task and architecture.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 158, "total_chunks": 184}}, {"id": 1242, "text": "Understanding their characteristics helps in choosing the right activation function for a given task and architecture.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 159, "total_chunks": 184}}, {"id": 1243, "text": "Generate synthetic data with intentional bias: - Class A: `np.random.normal(loc=2, scale=1, size=100)` - Class B: `np.random.normal(loc=-2, scale=1, size=100)` 2. Train a single-neuron ANN (no hidden layers) using each activation function. 3. Analyze bias by comparing: - Output distribution (histogram of predictions). - Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 160, "total_chunks": 184}}, {"id": 1244, "text": "- Decision boundaries (use `plt.scatter` with predictions).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 161, "total_chunks": 184}}, {"id": 1245, "text": "Class B: Task 3: Mitigation Strategies Experiment: Add a trainable bias term (`b`) to the neuron: Python Code: def forward(x, w, b, activation): return activation(np.dot(x, w) + b) Retrain and observe if bias reduces.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 162, "total_chunks": 184}}, {"id": 1246, "text": "|\") print(\"|---|----------------------|------------------------|------------------------|----------------|\") for row in results_with_bias: print(f\"| {row[0]} | {row[1]:<20} | {row[2]:<22} | {row[3]:<22} | {row[4]} |\") Output: Questions: Which activation function amplified bias the most? Why?", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 163, "total_chunks": 184}}, {"id": 1247, "text": "Why? Answer: ReLU showed the most bias, especially for negative inputs (Class B), outputting zero for all negative values and failing to capture variation. This is due to its zero output for all inputs < 0. How did the bias term affect ReLU vs. Sigmoid? Answer: For ReLU, the bias term helped shift the inputs into the positive range, reducing the dying neuron issue.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 164, "total_chunks": 184}}, {"id": 1248, "text": "Answer: For ReLU, the bias term helped shift the inputs into the positive range, reducing the dying neuron issue. For Sigmoid, the bias term slightly shifted the output curve but did not significantly change the bias since the sigmoid already compresses values. Can activation functions themselves be a source of algorithmic bias? Answer: Yes.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 165, "total_chunks": 184}}, {"id": 1249, "text": "Answer: Yes. Functions like ReLU inherently favor positive values and ignore negative ones, creating asymmetry in output behavior. This can lead to algorithmic bias especially if data is not balanced or preprocessed.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 166, "total_chunks": 184}}, {"id": 1250, "text": "This can lead to algorithmic bias especially if data is not balanced or preprocessed. Lab Week # 11 LAB 11: Building an NLP Pipeline \u2013 From Text to Intelligence using python Introduction Natural Language Processing (NLP) is a core area of Artificial Intelligence that enables machines to understand, interpret, and generate human language.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 167, "total_chunks": 184}}, {"id": 1251, "text": "Lab Week # 11 LAB 11: Building an NLP Pipeline \u2013 From Text to Intelligence using python Introduction Natural Language Processing (NLP) is a core area of Artificial Intelligence that enables machines to understand, interpret, and generate human language. In this hands-on lab, you will walk through the complete NLP pipeline\u2014from raw text to classification\u2014using Python.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 168, "total_chunks": 184}}, {"id": 1252, "text": "In this hands-on lab, you will walk through the complete NLP pipeline\u2014from raw text to classification\u2014using Python. You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 169, "total_chunks": 184}}, {"id": 1253, "text": "You will explore how real-world applications like chatbots, sentiment analysis, and automated summarization depend on structured language processing. By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 170, "total_chunks": 184}}, {"id": 1254, "text": "By breaking down raw text into meaningful tokens, removing noise, lemmatizing, vectorizing, and finally classifying using a machine learning algorithm, you will develop a foundational understanding of how machines extract meaning from language.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 171, "total_chunks": 184}}, {"id": 1255, "text": "This lab is designed to give you a practical grip on how the theoretical components of the NLP pipeline translate into functioning code used in AI applications. Steps: Load Dataset Load the provided dataset of 10\u201315 short movie reviews with sentiment labels. data = [ (\"I loved the movie, it was fantastic!\", \"Positive\"), (\"The film was boring and slow\", \"Negative\"), # Add more samples...", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 172, "total_chunks": 184}}, {"id": 1256, "text": "data = [ (\"I loved the movie, it was fantastic!\", \"Positive\"), (\"The film was boring and slow\", \"Negative\"), # Add more samples... ] Preprocessing Pipeline (20 min) Tokenization Split each review into individual words. Stopword Removal Remove common words like \"the\", \"is\", \"and\", using NLTK or spaCy. Lemmatization Convert words to their base forms (e.g., \"running\" \u2192 \"run\").", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 173, "total_chunks": 184}}, {"id": 1257, "text": "Lemmatization Convert words to their base forms (e.g., \"running\" \u2192 \"run\").", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 174, "total_chunks": 184}}, {"id": 1258, "text": "Example: from nltk.corpus import stopwords from nltk.tokenize import word_tokenize from nltk.stem import WordNetLemmatizer Vectorization Convert cleaned text into numerical format using: CountVectorizer or TF-IDF Vectorizer from sklearn.feature_extraction.text import CountVectorizer Classification Train a simple classifier (e.g., Multinomial Naive Bayes) to predict sentiment.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 175, "total_chunks": 184}}, {"id": 1259, "text": "from sklearn.naive_bayes import MultinomialNB from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score Evaluate Check accuracy on test data. Print 2\u20133 predictions for new reviews. Expected Output Cleaned and lemmatized reviews. A table showing transformed text vectors. Model accuracy score (e.g., 85%).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 176, "total_chunks": 184}}, {"id": 1260, "text": "Model accuracy score (e.g., 85%). Example predictions: Review: \"Absolutely amazing film!\" \u2192 Positive Review: \"Terrible and dull\" \u2192 Negative Code Result Lab Week # 12 LAB 12: Image Classification Using Artificial Neural Networks (ANN). Introduction In this lab, students will build an Artificial Neural Network (ANN) to classify handwritten digits (0\u20139) using the MNIST dataset.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 177, "total_chunks": 184}}, {"id": 1261, "text": "Introduction In this lab, students will build an Artificial Neural Network (ANN) to classify handwritten digits (0\u20139) using the MNIST dataset. Students will train the model, evaluate its accuracy, and test it with their own handwritten digit. Setup: Dataset MNIST Dataset: (given in separate file. 70,000 grayscale images (28\u00d728 pixels). 60,000 training + 10,000 test samples.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 178, "total_chunks": 184}}, {"id": 1262, "text": "60,000 training + 10,000 test samples. Each pixel value: 0 (black) to 255 (white). Library: TensorFlow/Keras, Matplotlib Editor: Any Python-supported IDE or Jupyter Notebook, Google Colab Steps:Algorithm: Step 1. Data Loading & Preprocessing: Load MNIST dataset (60,000 training + 10,000 test images). Normalize pixel values (0\u2013255 \u2192 0\u20131). Reshape images for ANN input (flatten 28x28 \u2192 784 pixels).", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 179, "total_chunks": 184}}, {"id": 1263, "text": "Reshape images for ANN input (flatten 28x28 \u2192 784 pixels). One-hot encode labels (e.g., \"3\" \u2192 [0,0,0,1,0,0,0,0,0,0]). Step 2. Model Architecture (ANN): Input Layer: 784 neurons (1 per pixel). Hidden Layer(s): 1\u20132 dense layers with ReLU activation. Output Layer: 10 neurons (Softmax activation for probability distribution). Step 3.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 180, "total_chunks": 184}}, {"id": 1264, "text": "Step 3. Training & Evaluation: Compile model with `adam` optimizer and `categorical_crossentropy` loss. Train for 5\u201310 epochs and validate on test data. Evaluate accuracy and confusion matrix. Step 4. Custom Digit Testing: Draw a digit (using `matplotlib` or external image). Preprocess and predict using the trained model.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 181, "total_chunks": 184}}, {"id": 1265, "text": "Preprocess and predict using the trained model.", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 182, "total_chunks": 184}}, {"id": 1266, "text": "(Yes/No) 1 | Sigmoid | 0.86 | 0.14 | Yes 2 | ReLU | 2.03 | 0.00 | Yes 3 | Leaky ReLU | 2.04 | -0.02 | Yes 4 | Tanh | 0.96 | -0.96 | Yes", "metadata": {"filename": "Lab manual AI.docx", "chunk_index": 183, "total_chunks": 184}}, {"id": 1267, "text": "SECURITIES AND EXCHANGE COMMISSION OF PAKISTAN Business Centre at Head Office Islamabad CERTIFICATE OF INCORPORATION [Under section 16 of the Companies Act, 2017 (XIX of 2017)] Corporate Unique Identification No. 0308562 I hereby certify that TECHKHWA (PRIVATE) LIMITED is this day incorporated under the Companies Act, 2017 (XIX of 2017) and that the company is Limited by shares.", "metadata": {"filename": "Incorporation Letter for 20250910_4171415 CTC (1).pdf", "chunk_index": 0, "total_chunks": 2}}, {"id": 1268, "text": "0308562 I hereby certify that TECHKHWA (PRIVATE) LIMITED is this day incorporated under the Companies Act, 2017 (XIX of 2017) and that the company is Limited by shares.", "metadata": {"filename": "Incorporation Letter for 20250910_4171415 CTC (1).pdf", "chunk_index": 1, "total_chunks": 2}}, {"id": 1269, "text": "1. Introduction 1.1 Purpose The purpose of this Software Requirements Specification (SRS) is to provide a complete and detailed description of the Multi-Tenant SaaS Marketplace Platform, a system designed to simplify the creation, publication, and distribution of Software-as-a-Service (SaaS) applications using WordPress Engine as the development foundation.", "metadata": {"filename": "SRS.docx", "chunk_index": 0, "total_chunks": 94}}, {"id": 1270, "text": "Introduction 1.1 Purpose The purpose of this Software Requirements Specification (SRS) is to provide a complete and detailed description of the Multi-Tenant SaaS Marketplace Platform, a system designed to simplify the creation, publication, and distribution of Software-as-a-Service (SaaS) applications using WordPress Engine as the development foundation.", "metadata": {"filename": "SRS.docx", "chunk_index": 1, "total_chunks": 94}}, {"id": 1271, "text": "The platform aims to enable developers to build SaaS products using their own WordPress installations, register and publish those products on a centralized marketplace, and monetize them through customer subscriptions.", "metadata": {"filename": "SRS.docx", "chunk_index": 2, "total_chunks": 94}}, {"id": 1272, "text": "This SRS outlines all functional and nonfunctional requirements, system architecture expectations, interface specifications, constraints, and interactions necessary for successful implementation.", "metadata": {"filename": "SRS.docx", "chunk_index": 3, "total_chunks": 94}}, {"id": 1273, "text": "It will serve as a formal agreement between the project team and the supervisor, ensuring that all stakeholders share a common understanding of the system\u2019s objectives, capabilities, and operational behavior. Additionally, it will guide developers during implementation and testers during validation and verification of system functionality.", "metadata": {"filename": "SRS.docx", "chunk_index": 4, "total_chunks": 94}}, {"id": 1274, "text": "Additionally, it will guide developers during implementation and testers during validation and verification of system functionality. 1.2 Document Conventions This SRS follows the structure defined by the IEEE 830 standard. Requirement statements appear in descriptive paragraphs and are expressed in clear, testable language.", "metadata": {"filename": "SRS.docx", "chunk_index": 5, "total_chunks": 94}}, {"id": 1275, "text": "Requirement statements appear in descriptive paragraphs and are expressed in clear, testable language. Functional requirements will later be assigned unique identifiers under Section 4 to ensure traceability and simplify validation.", "metadata": {"filename": "SRS.docx", "chunk_index": 6, "total_chunks": 94}}, {"id": 1276, "text": "Functional requirements will later be assigned unique identifiers under Section 4 to ensure traceability and simplify validation. Technical keywords such as \u201cplatform,\u201d \u201cdeveloper,\u201d \u201ccustomer,\u201d \u201cWordPress site,\u201d and \u201csubscription\u201d carry consistent meaning throughout the document and are defined in the Glossary.", "metadata": {"filename": "SRS.docx", "chunk_index": 7, "total_chunks": 94}}, {"id": 1277, "text": "Technical keywords such as \u201cplatform,\u201d \u201cdeveloper,\u201d \u201ccustomer,\u201d \u201cWordPress site,\u201d and \u201csubscription\u201d carry consistent meaning throughout the document and are defined in the Glossary. Text is presented in paragraph form to support readability and academic documentation standards.", "metadata": {"filename": "SRS.docx", "chunk_index": 8, "total_chunks": 94}}, {"id": 1278, "text": "Text is presented in paragraph form to support readability and academic documentation standards.", "metadata": {"filename": "SRS.docx", "chunk_index": 9, "total_chunks": 94}}, {"id": 1279, "text": "1.3 Intended Audience and Reading Suggestions This document is intended for a wide range of stakeholders involved in the planning, development, evaluation, and testing of the platform: Project Supervisors and Evaluators, who require a complete understanding of the system\u2019s goals, features, and design logic to assess its feasibility and academic merit.", "metadata": {"filename": "SRS.docx", "chunk_index": 10, "total_chunks": 94}}, {"id": 1280, "text": "Software Developers, who will rely on the functional and technical specifications contained herein to implement backend services, frontend interfaces, database structures, and WordPress plugin interactions. Test Engineers, who need clear behavioral descriptions and requirement definitions to construct test cases and ensure system correctness.", "metadata": {"filename": "SRS.docx", "chunk_index": 11, "total_chunks": 94}}, {"id": 1281, "text": "Test Engineers, who need clear behavioral descriptions and requirement definitions to construct test cases and ensure system correctness. UI/UX Designers, who will use the descriptions of system workflows and user interactions to design intuitive and efficient user interfaces.", "metadata": {"filename": "SRS.docx", "chunk_index": 12, "total_chunks": 94}}, {"id": 1282, "text": "UI/UX Designers, who will use the descriptions of system workflows and user interactions to design intuitive and efficient user interfaces. Readers unfamiliar with the system should begin with Section 1 (Introduction) and Section 2 (Overall Description) to understand the context and high-level objectives.", "metadata": {"filename": "SRS.docx", "chunk_index": 13, "total_chunks": 94}}, {"id": 1283, "text": "Readers unfamiliar with the system should begin with Section 1 (Introduction) and Section 2 (Overall Description) to understand the context and high-level objectives. Those involved in implementation should focus on Section 3 (External Interfaces) and Section 4 (System Features), while evaluators will find Sections 5 and 6 most relevant.", "metadata": {"filename": "SRS.docx", "chunk_index": 14, "total_chunks": 94}}, {"id": 1284, "text": "Those involved in implementation should focus on Section 3 (External Interfaces) and Section 4 (System Features), while evaluators will find Sections 5 and 6 most relevant. 1.4 Product Scope The Multi-Tenant SaaS Marketplace Platform provides a unified environment where developers can transform their WordPress websites into fully functional SaaS products without building custom infrastructure.", "metadata": {"filename": "SRS.docx", "chunk_index": 15, "total_chunks": 94}}, {"id": 1285, "text": "1.4 Product Scope The Multi-Tenant SaaS Marketplace Platform provides a unified environment where developers can transform their WordPress websites into fully functional SaaS products without building custom infrastructure.", "metadata": {"filename": "SRS.docx", "chunk_index": 16, "total_chunks": 94}}, {"id": 1286, "text": "The system allows developers to integrate their WordPress sites with the platform using a lightweight plugin, configure product metadata, pricing, and subscription plans, and publish those SaaS offerings to customers. For end-users, the system offers a centralized marketplace containing a variety of SaaS tools, each created and managed by independent developers.", "metadata": {"filename": "SRS.docx", "chunk_index": 17, "total_chunks": 94}}, {"id": 1287, "text": "For end-users, the system offers a centralized marketplace containing a variety of SaaS tools, each created and managed by independent developers. Users can browse products, review features, subscribe to pricing tiers, and directly access the SaaS through the developer\u2019s WordPress environment.", "metadata": {"filename": "SRS.docx", "chunk_index": 18, "total_chunks": 94}}, {"id": 1288, "text": "Users can browse products, review features, subscribe to pricing tiers, and directly access the SaaS through the developer\u2019s WordPress environment. The platform further automates recurring billing, manages subscription lifecycles, and calculates revenue splits between developers and the system owner.", "metadata": {"filename": "SRS.docx", "chunk_index": 19, "total_chunks": 94}}, {"id": 1289, "text": "The platform further automates recurring billing, manages subscription lifecycles, and calculates revenue splits between developers and the system owner. Administrators maintain full oversight through an admin panel that facilitates user and product approvals, financial oversight, and platform governance.", "metadata": {"filename": "SRS.docx", "chunk_index": 20, "total_chunks": 94}}, {"id": 1290, "text": "Administrators maintain full oversight through an admin panel that facilitates user and product approvals, financial oversight, and platform governance. The long-term vision is to create an ecosystem that reduces the barriers to SaaS development, empowers developers with monetization opportunities, and delivers a user-friendly marketplace for SaaS consumption.", "metadata": {"filename": "SRS.docx", "chunk_index": 21, "total_chunks": 94}}, {"id": 1291, "text": "The long-term vision is to create an ecosystem that reduces the barriers to SaaS development, empowers developers with monetization opportunities, and delivers a user-friendly marketplace for SaaS consumption.", "metadata": {"filename": "SRS.docx", "chunk_index": 22, "total_chunks": 94}}, {"id": 1292, "text": "2. Overall Description 2.1 Product Perspective The Multi-Tenant SaaS Marketplace Platform is a newly developed system that integrates several independent components into a cohesive architecture. While the marketplace operates as a standalone product, it depends heavily on external systems such as WordPress websites belonging to developers and a third-party payment gateway such as Stripe/Payoneer.", "metadata": {"filename": "SRS.docx", "chunk_index": 23, "total_chunks": 94}}, {"id": 1293, "text": "While the marketplace operates as a standalone product, it depends heavily on external systems such as WordPress websites belonging to developers and a third-party payment gateway such as Stripe/Payoneer.", "metadata": {"filename": "SRS.docx", "chunk_index": 24, "total_chunks": 94}}, {"id": 1294, "text": "The platform consists of the following major components: Frontend User Interface (React): This web-based interface provides all user-facing screens, including the marketplace, subscription pages, developer dashboard, and administrator console. It communicates exclusively with the backend through secure REST APIs.", "metadata": {"filename": "SRS.docx", "chunk_index": 25, "total_chunks": 94}}, {"id": 1295, "text": "It communicates exclusively with the backend through secure REST APIs. Backend API Server (Node.js +Django + Express): This component handles authentication, business logic, payment interactions, subscription lifecycle events, tenant isolation, and communication with WordPress sites. It also receives webhook notifications from external services and processes them accordingly.", "metadata": {"filename": "SRS.docx", "chunk_index": 26, "total_chunks": 94}}, {"id": 1296, "text": "It also receives webhook notifications from external services and processes them accordingly. Database Layer (PostgreSQL or Supabase): A centralized relational database is used to store users, subscriptions, products, pricing plans, revenue data, WordPress integration tokens, audit logs, and other critical records.", "metadata": {"filename": "SRS.docx", "chunk_index": 27, "total_chunks": 94}}, {"id": 1297, "text": "Database Layer (PostgreSQL or Supabase): A centralized relational database is used to store users, subscriptions, products, pricing plans, revenue data, WordPress integration tokens, audit logs, and other critical records. Supabase may be used for ease of setup and built-in authentication and storage capabilities.", "metadata": {"filename": "SRS.docx", "chunk_index": 28, "total_chunks": 94}}, {"id": 1298, "text": "Supabase may be used for ease of setup and built-in authentication and storage capabilities. WordPress Integration Plugin: Developers install a custom WordPress plugin on their website to link their SaaS environment with the marketplace. The plugin authenticates with the platform, verifies site ownership, and communicates subscription access permissions.", "metadata": {"filename": "SRS.docx", "chunk_index": 29, "total_chunks": 94}}, {"id": 1299, "text": "The plugin authenticates with the platform, verifies site ownership, and communicates subscription access permissions. It may also relay usage statistics for analytics. Payment Gateway: A payment service such as Stripe manages secure payments, recurring billing, invoicing, and failed payment handling.", "metadata": {"filename": "SRS.docx", "chunk_index": 30, "total_chunks": 94}}, {"id": 1300, "text": "Payment Gateway: A payment service such as Stripe manages secure payments, recurring billing, invoicing, and failed payment handling. The platform processes revenue splits between developers and the platform owner based on these transactions. This distributed design emphasizes scalability, security, and modular integration while ensuring a seamless experience for all stakeholders.", "metadata": {"filename": "SRS.docx", "chunk_index": 31, "total_chunks": 94}}, {"id": 1301, "text": "This distributed design emphasizes scalability, security, and modular integration while ensuring a seamless experience for all stakeholders. 2.2 Product Functions The platform delivers a wide range of interconnected functions: User Management: Handles authentication, role assignment, profile management, access control, and user session handling.", "metadata": {"filename": "SRS.docx", "chunk_index": 32, "total_chunks": 94}}, {"id": 1302, "text": "2.2 Product Functions The platform delivers a wide range of interconnected functions: User Management: Handles authentication, role assignment, profile management, access control, and user session handling.", "metadata": {"filename": "SRS.docx", "chunk_index": 33, "total_chunks": 94}}, {"id": 1303, "text": "Developer Onboarding and Verification: Allows developers to register as SaaS creators, submit their website details, install the WordPress plugin, and verify site ownership before publishing a product. Product Creation and Management: Developers can create SaaS offerings by defining product descriptions, feature lists, pricing plans, and trial periods.", "metadata": {"filename": "SRS.docx", "chunk_index": 34, "total_chunks": 94}}, {"id": 1304, "text": "Product Creation and Management: Developers can create SaaS offerings by defining product descriptions, feature lists, pricing plans, and trial periods. They can publish or unpublish products at any time. Marketplace Browsing: Customers can explore available SaaS tools, view product details, compare pricing, access screenshots, and read developer information.", "metadata": {"filename": "SRS.docx", "chunk_index": 35, "total_chunks": 94}}, {"id": 1305, "text": "Marketplace Browsing: Customers can explore available SaaS tools, view product details, compare pricing, access screenshots, and read developer information. Subscription Management: Customers can subscribe to products, upgrade or downgrade their plans, cancel subscriptions, and view billing history. The system automatically handles recurring billing and trial conversions.", "metadata": {"filename": "SRS.docx", "chunk_index": 36, "total_chunks": 94}}, {"id": 1306, "text": "The system automatically handles recurring billing and trial conversions. Revenue and Payout Management: The platform calculates developer earnings, deducts the platform\u2019s fee, and schedules payouts. Developers can monitor financial performance through their dashboards.", "metadata": {"filename": "SRS.docx", "chunk_index": 37, "total_chunks": 94}}, {"id": 1307, "text": "Developers can monitor financial performance through their dashboards. Administration and Moderation: Administrators supervise developer profiles, approve SaaS products, manage payouts, view platform analytics, respond to disputes, and maintain system integrity. These functions collectively ensure the platform fulfills its purpose as a multi-tenant SaaS marketplace.", "metadata": {"filename": "SRS.docx", "chunk_index": 38, "total_chunks": 94}}, {"id": 1308, "text": "These functions collectively ensure the platform fulfills its purpose as a multi-tenant SaaS marketplace. 2.3 User Classes and Characteristics The platform serves three distinct user groups, each with different expectations and expertise levels: Customers: These users have minimal technical knowledge and primarily interact with the marketplace to discover and subscribe to SaaS products.", "metadata": {"filename": "SRS.docx", "chunk_index": 39, "total_chunks": 94}}, {"id": 1309, "text": "2.3 User Classes and Characteristics The platform serves three distinct user groups, each with different expectations and expertise levels: Customers: These users have minimal technical knowledge and primarily interact with the marketplace to discover and subscribe to SaaS products.", "metadata": {"filename": "SRS.docx", "chunk_index": 40, "total_chunks": 94}}, {"id": 1310, "text": "They require a simple, intuitive interface with clear pricing, easy checkout processes, and reliable subscription management features. Developers: These users possess moderate technical skills and typically understand WordPress administration and plugin installation. Their main concerns involve product creation, integration with their WordPress site, managing subscribers, and monitoring revenue.", "metadata": {"filename": "SRS.docx", "chunk_index": 41, "total_chunks": 94}}, {"id": 1311, "text": "Their main concerns involve product creation, integration with their WordPress site, managing subscribers, and monitoring revenue. They require robust analytics and seamless integration tools. Administrators: These users are technically proficient and responsible for managing platform operations, including developer approvals, product verifications, financial oversight, and system governance.", "metadata": {"filename": "SRS.docx", "chunk_index": 42, "total_chunks": 94}}, {"id": 1312, "text": "Administrators: These users are technically proficient and responsible for managing platform operations, including developer approvals, product verifications, financial oversight, and system governance. Their interface must provide comprehensive visibility and control. 2.4 Operating Environment The system is designed to operate within widely used and stable environments.", "metadata": {"filename": "SRS.docx", "chunk_index": 43, "total_chunks": 94}}, {"id": 1313, "text": "2.4 Operating Environment The system is designed to operate within widely used and stable environments. Users access the platform via modern web browsers such as Google Chrome, Mozilla Firefox, and Microsoft Edge. The backend services run on Linux-based servers, ensuring compatibility with Node.js and Express.", "metadata": {"filename": "SRS.docx", "chunk_index": 44, "total_chunks": 94}}, {"id": 1314, "text": "The backend services run on Linux-based servers, ensuring compatibility with Node.js and Express. The WordPress plugin requires a WordPress 6.x installation running PHP 8 or above with HTTPS enabled. The database operates on PostgreSQL or Supabase, both of which offer strong relational capabilities and support for scalable architectures.", "metadata": {"filename": "SRS.docx", "chunk_index": 45, "total_chunks": 94}}, {"id": 1315, "text": "The database operates on PostgreSQL or Supabase, both of which offer strong relational capabilities and support for scalable architectures. Network communications are conducted exclusively over HTTPS to guarantee security. 2.5 Design and Implementation Constraints The platform must adhere to several technical constraints: It must use Node.js and Express for backend services.", "metadata": {"filename": "SRS.docx", "chunk_index": 46, "total_chunks": 94}}, {"id": 1316, "text": "2.5 Design and Implementation Constraints The platform must adhere to several technical constraints: It must use Node.js and Express for backend services. The database must be PostgreSQL or Supabase. All communication between frontend, backend, WordPress sites, and payment gateway must occur over secure HTTPS connections. Authentication must use JWT tokens.", "metadata": {"filename": "SRS.docx", "chunk_index": 47, "total_chunks": 94}}, {"id": 1317, "text": "Authentication must use JWT tokens. Multi-tenancy must be enforced at both the application and database layers. The WordPress plugin must conform to WordPress coding standards and REST API conventions. The payment system must support recurring billing and revenue distribution. These constraints shape the technical design and ensure the long-term maintainability and extensibility of the platform.", "metadata": {"filename": "SRS.docx", "chunk_index": 48, "total_chunks": 94}}, {"id": 1318, "text": "These constraints shape the technical design and ensure the long-term maintainability and extensibility of the platform. 2.6 User Documentation The system will include a complete set of user documentation to support onboarding and usage.", "metadata": {"filename": "SRS.docx", "chunk_index": 49, "total_chunks": 94}}, {"id": 1319, "text": "2.6 User Documentation The system will include a complete set of user documentation to support onboarding and usage. This includes developer onboarding guides, WordPress plugin installation instructions, product publishing documentation, customer usage manuals, subscription guides, and an administrative operations manual.", "metadata": {"filename": "SRS.docx", "chunk_index": 50, "total_chunks": 94}}, {"id": 1320, "text": "This includes developer onboarding guides, WordPress plugin installation instructions, product publishing documentation, customer usage manuals, subscription guides, and an administrative operations manual. In addition, API documentation will be provided through Swagger or similar tools for developers who require deeper integration.", "metadata": {"filename": "SRS.docx", "chunk_index": 51, "total_chunks": 94}}, {"id": 1321, "text": "In addition, API documentation will be provided through Swagger or similar tools for developers who require deeper integration. 2.7 Assumptions and Dependencies This system assumes that developers are capable of managing their WordPress installations and can install and configure plugins.", "metadata": {"filename": "SRS.docx", "chunk_index": 52, "total_chunks": 94}}, {"id": 1322, "text": "2.7 Assumptions and Dependencies This system assumes that developers are capable of managing their WordPress installations and can install and configure plugins. It also assumes reliable internet connectivity for all transactions, especially during WordPress plugin interactions and payment processing.", "metadata": {"filename": "SRS.docx", "chunk_index": 53, "total_chunks": 94}}, {"id": 1323, "text": "It also assumes reliable internet connectivity for all transactions, especially during WordPress plugin interactions and payment processing. The platform depends heavily on the payment gateway\u2019s uptime, email service reliability, database stability, and continued availability of the WordPress REST API. Failure of any dependency may temporarily impact system functionality. 3.", "metadata": {"filename": "SRS.docx", "chunk_index": 54, "total_chunks": 94}}, {"id": 1324, "text": "3. External Interface Requirements 3.1 User Interfaces The platform provides three distinct user interfaces: the Customer Interface, the Developer Dashboard, and the Administrator Console. All interfaces will be implemented as responsive web applications built using React. They will follow consistent visual design, typography, and navigation structures to ensure ease of use and accessibility.", "metadata": {"filename": "SRS.docx", "chunk_index": 55, "total_chunks": 94}}, {"id": 1325, "text": "They will follow consistent visual design, typography, and navigation structures to ensure ease of use and accessibility. Each interface will interact with the backend exclusively through secure HTTPS REST API calls. Customer Interface The Customer Interface serves as the public-facing portion of the marketplace.", "metadata": {"filename": "SRS.docx", "chunk_index": 56, "total_chunks": 94}}, {"id": 1326, "text": "Customer Interface The Customer Interface serves as the public-facing portion of the marketplace. It includes the home page, product catalog, search and filtering tools, product detail pages, checkout and subscription pages, and a personal account dashboard.", "metadata": {"filename": "SRS.docx", "chunk_index": 57, "total_chunks": 94}}, {"id": 1327, "text": "It includes the home page, product catalog, search and filtering tools, product detail pages, checkout and subscription pages, and a personal account dashboard. Customers will be able to view their active subscriptions, billing history, saved payment methods (managed by the payment gateway, not locally), and invoices.", "metadata": {"filename": "SRS.docx", "chunk_index": 58, "total_chunks": 94}}, {"id": 1328, "text": "Customers will be able to view their active subscriptions, billing history, saved payment methods (managed by the payment gateway, not locally), and invoices. The interface must present pricing information clearly and provide transparent explanations of trial periods, billing cycles, and cancellation policies.", "metadata": {"filename": "SRS.docx", "chunk_index": 59, "total_chunks": 94}}, {"id": 1329, "text": "The interface must present pricing information clearly and provide transparent explanations of trial periods, billing cycles, and cancellation policies. Error messages, payment failures, or subscription-related alerts must be displayed with clear wording and actionable guidance. Developer Dashboard The Developer Dashboard is a restricted interface accessible only to users registered as developers.", "metadata": {"filename": "SRS.docx", "chunk_index": 60, "total_chunks": 94}}, {"id": 1330, "text": "Developer Dashboard The Developer Dashboard is a restricted interface accessible only to users registered as developers. It provides onboarding wizards, WordPress integration steps, product creation tools, and revenue analytics. Developers should be able to register a WordPress site, verify ownership through a verification token, and install the required plugin.", "metadata": {"filename": "SRS.docx", "chunk_index": 61, "total_chunks": 94}}, {"id": 1331, "text": "Developers should be able to register a WordPress site, verify ownership through a verification token, and install the required plugin. The dashboard will allow developers to create and publish SaaS products by defining metadata, pricing plans, feature descriptions, and trial configurations.", "metadata": {"filename": "SRS.docx", "chunk_index": 62, "total_chunks": 94}}, {"id": 1332, "text": "The dashboard will allow developers to create and publish SaaS products by defining metadata, pricing plans, feature descriptions, and trial configurations. The dashboard also includes earnings summaries, payout history, subscriber counts, and product performance charts.", "metadata": {"filename": "SRS.docx", "chunk_index": 63, "total_chunks": 94}}, {"id": 1333, "text": "The dashboard also includes earnings summaries, payout history, subscriber counts, and product performance charts. All sensitive actions (e.g., publishing products, modifying payment details) must prompt confirmation messages or multi-step flows to prevent accidental changes.", "metadata": {"filename": "SRS.docx", "chunk_index": 64, "total_chunks": 94}}, {"id": 1334, "text": "All sensitive actions (e.g., publishing products, modifying payment details) must prompt confirmation messages or multi-step flows to prevent accidental changes. Administrator Console The Administrator Console is designed for platform administrators who manage approvals, financial oversight, and system governance.", "metadata": {"filename": "SRS.docx", "chunk_index": 65, "total_chunks": 94}}, {"id": 1335, "text": "Administrator Console The Administrator Console is designed for platform administrators who manage approvals, financial oversight, and system governance. It includes interfaces for reviewing developer applications, approving or rejecting SaaS products, inspecting subscription records, triggering payouts, and reviewing financial reports.", "metadata": {"filename": "SRS.docx", "chunk_index": 66, "total_chunks": 94}}, {"id": 1336, "text": "It includes interfaces for reviewing developer applications, approving or rejecting SaaS products, inspecting subscription records, triggering payouts, and reviewing financial reports. Administrators must have visibility into system logs, error reports, user activity, and revenue analytics.", "metadata": {"filename": "SRS.docx", "chunk_index": 67, "total_chunks": 94}}, {"id": 1337, "text": "Administrators must have visibility into system logs, error reports, user activity, and revenue analytics. The interface must include filtering, sorting, and export features for data tables to facilitate operational efficiency.", "metadata": {"filename": "SRS.docx", "chunk_index": 68, "total_chunks": 94}}, {"id": 1338, "text": "The interface must include filtering, sorting, and export features for data tables to facilitate operational efficiency. Since administrators will handle sensitive financial data and platform-wide settings, the console must enforce the highest level of security, including role verification and audit logging of administrative actions.", "metadata": {"filename": "SRS.docx", "chunk_index": 69, "total_chunks": 94}}, {"id": 1339, "text": "Since administrators will handle sensitive financial data and platform-wide settings, the console must enforce the highest level of security, including role verification and audit logging of administrative actions. 3.2 Hardware Interfaces The system does not require any specialized hardware interfaces because it is fully web-based and cloud-hosted.", "metadata": {"filename": "SRS.docx", "chunk_index": 70, "total_chunks": 94}}, {"id": 1340, "text": "3.2 Hardware Interfaces The system does not require any specialized hardware interfaces because it is fully web-based and cloud-hosted. All interactions occur via standard consumer devices such as laptops, desktops, and mobile phones. The backend runs on cloud servers (physical or virtual) that meet minimum specifications for running Node.js and PostgreSQL.", "metadata": {"filename": "SRS.docx", "chunk_index": 71, "total_chunks": 94}}, {"id": 1341, "text": "The backend runs on cloud servers (physical or virtual) that meet minimum specifications for running Node.js and PostgreSQL. The only relevant hardware interactions involve the servers hosting the WordPress websites used by developers. These hosting environments must support PHP 8+, HTTPS, and WordPress 6.x or later, ensuring compatibility with the custom plugin.", "metadata": {"filename": "SRS.docx", "chunk_index": 72, "total_chunks": 94}}, {"id": 1342, "text": "These hosting environments must support PHP 8+, HTTPS, and WordPress 6.x or later, ensuring compatibility with the custom plugin. Beyond this, there are no custom hardware requirements such as embedded devices, sensors, or device drivers. 3.3 Software Interfaces The platform interacts with several external software systems.", "metadata": {"filename": "SRS.docx", "chunk_index": 73, "total_chunks": 94}}, {"id": 1343, "text": "3.3 Software Interfaces The platform interacts with several external software systems. These interfaces must be clearly defined to ensure reliable communication and prevent data inconsistencies. WordPress Plugin Interface The custom WordPress plugin is a critical component of the system.", "metadata": {"filename": "SRS.docx", "chunk_index": 74, "total_chunks": 94}}, {"id": 1344, "text": "WordPress Plugin Interface The custom WordPress plugin is a critical component of the system. It must expose a set of REST endpoints that the marketplace backend can use to: Verify site ownership Validate active subscriptions Synchronize product information Enforce access control to SaaS features The plugin must authenticate requests using the API key generated during developer onboarding.", "metadata": {"filename": "SRS.docx", "chunk_index": 75, "total_chunks": 94}}, {"id": 1345, "text": "It must expose a set of REST endpoints that the marketplace backend can use to: Verify site ownership Validate active subscriptions Synchronize product information Enforce access control to SaaS features The plugin must authenticate requests using the API key generated during developer onboarding.", "metadata": {"filename": "SRS.docx", "chunk_index": 76, "total_chunks": 94}}, {"id": 1346, "text": "It must also register webhooks or callback endpoints to receive subscription status notifications from the platform. The plugin should be compatible with the WordPress REST API, respecting permission callbacks and the WP security model.", "metadata": {"filename": "SRS.docx", "chunk_index": 77, "total_chunks": 94}}, {"id": 1347, "text": "The plugin should be compatible with the WordPress REST API, respecting permission callbacks and the WP security model. Payment Gateway Interface The payment gateway (e.g., Stripe/Payoneer) provides interfaces for processing payments, managing subscriptions, handling trial periods, generating invoices, and receiving webhook notifications.", "metadata": {"filename": "SRS.docx", "chunk_index": 78, "total_chunks": 94}}, {"id": 1348, "text": "Payment Gateway Interface The payment gateway (e.g., Stripe/Payoneer) provides interfaces for processing payments, managing subscriptions, handling trial periods, generating invoices, and receiving webhook notifications. The platform must integrate with the gateway using its official SDK or REST APIs.", "metadata": {"filename": "SRS.docx", "chunk_index": 79, "total_chunks": 94}}, {"id": 1349, "text": "The platform must integrate with the gateway using its official SDK or REST APIs.", "metadata": {"filename": "SRS.docx", "chunk_index": 80, "total_chunks": 94}}, {"id": 1350, "text": "Communication includes: Creating checkout sessions Attaching payment methods Managing subscription cycles Responding to payment successes or failures Handling webhook events for renewals, cancellations, and chargebacks The system must never store raw credit card information; all sensitive data is tokenized and maintained by the payment provider.", "metadata": {"filename": "SRS.docx", "chunk_index": 81, "total_chunks": 94}}, {"id": 1351, "text": "Email Service Interface The platform will integrate with an email delivery service (e.g., SendGrid, Mailgun, or Supabase built-in email support). This service handles account verification emails, password reset requests, subscription confirmations, payment receipts, trial reminders, and developer notifications. Emails must follow templated formats and support dynamic fields.", "metadata": {"filename": "SRS.docx", "chunk_index": 82, "total_chunks": 94}}, {"id": 1352, "text": "Emails must follow templated formats and support dynamic fields. Backend API Interface The frontend and WordPress plugin communicate with the backend exclusively through REST APIs. Endpoints must follow predictable naming conventions, use JSON as the data exchange format, and enforce role-based authorization.", "metadata": {"filename": "SRS.docx", "chunk_index": 83, "total_chunks": 94}}, {"id": 1353, "text": "Endpoints must follow predictable naming conventions, use JSON as the data exchange format, and enforce role-based authorization. The backend API layer will expose endpoints for authentication, product creation, subscription management, developer onboarding, payout scheduling, and administrative operations. The API must return meaningful response codes and structured error messages.", "metadata": {"filename": "SRS.docx", "chunk_index": 84, "total_chunks": 94}}, {"id": 1354, "text": "The API must return meaningful response codes and structured error messages. Database Interface The system interacts with PostgreSQL using an ORM or SQL queries. The database schema must be consistent with multi-tenant architecture, ensuring that all tables either include a tenant identifier or follow schema-per-tenant separation.", "metadata": {"filename": "SRS.docx", "chunk_index": 85, "total_chunks": 94}}, {"id": 1355, "text": "The database schema must be consistent with multi-tenant architecture, ensuring that all tables either include a tenant identifier or follow schema-per-tenant separation. The backend must implement strict row-level security or access rules to prevent cross-tenant data exposures.", "metadata": {"filename": "SRS.docx", "chunk_index": 86, "total_chunks": 94}}, {"id": 1356, "text": "The backend must implement strict row-level security or access rules to prevent cross-tenant data exposures. 3.4 Communications Interfaces All interactions across the platform must occur over secure HTTPS connections to prevent data interception or manipulation. The system employs REST-style JSON messaging for communication between the frontend, backend, WordPress plugin, and external services.", "metadata": {"filename": "SRS.docx", "chunk_index": 87, "total_chunks": 94}}, {"id": 1357, "text": "The system employs REST-style JSON messaging for communication between the frontend, backend, WordPress plugin, and external services. For asynchronous operations, such as subscription renewals and payment events, the platform relies on webhook mechanisms provided by the payment gateway.", "metadata": {"filename": "SRS.docx", "chunk_index": 88, "total_chunks": 94}}, {"id": 1358, "text": "For asynchronous operations, such as subscription renewals and payment events, the platform relies on webhook mechanisms provided by the payment gateway. The WordPress plugin and the backend use token-based authentication (API key + site verification token) to authenticate requests. The plugin must refuse any requests lacking valid tokens or signatures.", "metadata": {"filename": "SRS.docx", "chunk_index": 89, "total_chunks": 94}}, {"id": 1359, "text": "The plugin must refuse any requests lacking valid tokens or signatures. Similarly, webhook payloads from the payment gateway must be verified using signature headers to ensure authenticity. Error handling within communication interfaces must follow a consistent pattern. For example, API failures should return error messages in JSON format with fields such as error_code, message, and details.", "metadata": {"filename": "SRS.docx", "chunk_index": 90, "total_chunks": 94}}, {"id": 1360, "text": "For example, API failures should return error messages in JSON format with fields such as error_code, message, and details. The system must also implement retry mechanisms for transient communication failures, especially during webhook processing or payment-related events. The communication layer must support rate limiting, input validation, and payload sanitization to mitigate security risks.", "metadata": {"filename": "SRS.docx", "chunk_index": 91, "total_chunks": 94}}, {"id": 1361, "text": "The communication layer must support rate limiting, input validation, and payload sanitization to mitigate security risks. Logs of communication errors, failed requests, and suspicious activities must be maintained for auditing purposes.", "metadata": {"filename": "SRS.docx", "chunk_index": 92, "total_chunks": 94}}, {"id": 1362, "text": "Logs of communication errors, failed requests, and suspicious activities must be maintained for auditing purposes.", "metadata": {"filename": "SRS.docx", "chunk_index": 93, "total_chunks": 94}}, {"id": 1363, "text": "1. Introduction 1.1 Purpose The purpose of this Software Requirements Specification (SRS) is to provide a complete and detailed description of the Multi-Tenant SaaS Marketplace Platform, a system designed to simplify the creation, publication, and distribution of Software-as-a-Service (SaaS) applications using WordPress Engine as the development foundation.", "metadata": {"filename": "SRS.docx", "chunk_index": 0, "total_chunks": 94}}, {"id": 1364, "text": "Introduction 1.1 Purpose The purpose of this Software Requirements Specification (SRS) is to provide a complete and detailed description of the Multi-Tenant SaaS Marketplace Platform, a system designed to simplify the creation, publication, and distribution of Software-as-a-Service (SaaS) applications using WordPress Engine as the development foundation.", "metadata": {"filename": "SRS.docx", "chunk_index": 1, "total_chunks": 94}}, {"id": 1365, "text": "The platform aims to enable developers to build SaaS products using their own WordPress installations, register and publish those products on a centralized marketplace, and monetize them through customer subscriptions.", "metadata": {"filename": "SRS.docx", "chunk_index": 2, "total_chunks": 94}}, {"id": 1366, "text": "This SRS outlines all functional and nonfunctional requirements, system architecture expectations, interface specifications, constraints, and interactions necessary for successful implementation.", "metadata": {"filename": "SRS.docx", "chunk_index": 3, "total_chunks": 94}}, {"id": 1367, "text": "It will serve as a formal agreement between the project team and the supervisor, ensuring that all stakeholders share a common understanding of the system\u2019s objectives, capabilities, and operational behavior. Additionally, it will guide developers during implementation and testers during validation and verification of system functionality.", "metadata": {"filename": "SRS.docx", "chunk_index": 4, "total_chunks": 94}}, {"id": 1368, "text": "Additionally, it will guide developers during implementation and testers during validation and verification of system functionality. 1.2 Document Conventions This SRS follows the structure defined by the IEEE 830 standard. Requirement statements appear in descriptive paragraphs and are expressed in clear, testable language.", "metadata": {"filename": "SRS.docx", "chunk_index": 5, "total_chunks": 94}}, {"id": 1369, "text": "Requirement statements appear in descriptive paragraphs and are expressed in clear, testable language. Functional requirements will later be assigned unique identifiers under Section 4 to ensure traceability and simplify validation.", "metadata": {"filename": "SRS.docx", "chunk_index": 6, "total_chunks": 94}}, {"id": 1370, "text": "Functional requirements will later be assigned unique identifiers under Section 4 to ensure traceability and simplify validation. Technical keywords such as \u201cplatform,\u201d \u201cdeveloper,\u201d \u201ccustomer,\u201d \u201cWordPress site,\u201d and \u201csubscription\u201d carry consistent meaning throughout the document and are defined in the Glossary.", "metadata": {"filename": "SRS.docx", "chunk_index": 7, "total_chunks": 94}}, {"id": 1371, "text": "Technical keywords such as \u201cplatform,\u201d \u201cdeveloper,\u201d \u201ccustomer,\u201d \u201cWordPress site,\u201d and \u201csubscription\u201d carry consistent meaning throughout the document and are defined in the Glossary. Text is presented in paragraph form to support readability and academic documentation standards.", "metadata": {"filename": "SRS.docx", "chunk_index": 8, "total_chunks": 94}}, {"id": 1372, "text": "Text is presented in paragraph form to support readability and academic documentation standards.", "metadata": {"filename": "SRS.docx", "chunk_index": 9, "total_chunks": 94}}, {"id": 1373, "text": "1.3 Intended Audience and Reading Suggestions This document is intended for a wide range of stakeholders involved in the planning, development, evaluation, and testing of the platform: Project Supervisors and Evaluators, who require a complete understanding of the system\u2019s goals, features, and design logic to assess its feasibility and academic merit.", "metadata": {"filename": "SRS.docx", "chunk_index": 10, "total_chunks": 94}}, {"id": 1374, "text": "Software Developers, who will rely on the functional and technical specifications contained herein to implement backend services, frontend interfaces, database structures, and WordPress plugin interactions. Test Engineers, who need clear behavioral descriptions and requirement definitions to construct test cases and ensure system correctness.", "metadata": {"filename": "SRS.docx", "chunk_index": 11, "total_chunks": 94}}, {"id": 1375, "text": "Test Engineers, who need clear behavioral descriptions and requirement definitions to construct test cases and ensure system correctness. UI/UX Designers, who will use the descriptions of system workflows and user interactions to design intuitive and efficient user interfaces.", "metadata": {"filename": "SRS.docx", "chunk_index": 12, "total_chunks": 94}}, {"id": 1376, "text": "UI/UX Designers, who will use the descriptions of system workflows and user interactions to design intuitive and efficient user interfaces. Readers unfamiliar with the system should begin with Section 1 (Introduction) and Section 2 (Overall Description) to understand the context and high-level objectives.", "metadata": {"filename": "SRS.docx", "chunk_index": 13, "total_chunks": 94}}, {"id": 1377, "text": "Readers unfamiliar with the system should begin with Section 1 (Introduction) and Section 2 (Overall Description) to understand the context and high-level objectives. Those involved in implementation should focus on Section 3 (External Interfaces) and Section 4 (System Features), while evaluators will find Sections 5 and 6 most relevant.", "metadata": {"filename": "SRS.docx", "chunk_index": 14, "total_chunks": 94}}, {"id": 1378, "text": "Those involved in implementation should focus on Section 3 (External Interfaces) and Section 4 (System Features), while evaluators will find Sections 5 and 6 most relevant. 1.4 Product Scope The Multi-Tenant SaaS Marketplace Platform provides a unified environment where developers can transform their WordPress websites into fully functional SaaS products without building custom infrastructure.", "metadata": {"filename": "SRS.docx", "chunk_index": 15, "total_chunks": 94}}, {"id": 1379, "text": "1.4 Product Scope The Multi-Tenant SaaS Marketplace Platform provides a unified environment where developers can transform their WordPress websites into fully functional SaaS products without building custom infrastructure.", "metadata": {"filename": "SRS.docx", "chunk_index": 16, "total_chunks": 94}}, {"id": 1380, "text": "The system allows developers to integrate their WordPress sites with the platform using a lightweight plugin, configure product metadata, pricing, and subscription plans, and publish those SaaS offerings to customers. For end-users, the system offers a centralized marketplace containing a variety of SaaS tools, each created and managed by independent developers.", "metadata": {"filename": "SRS.docx", "chunk_index": 17, "total_chunks": 94}}, {"id": 1381, "text": "For end-users, the system offers a centralized marketplace containing a variety of SaaS tools, each created and managed by independent developers. Users can browse products, review features, subscribe to pricing tiers, and directly access the SaaS through the developer\u2019s WordPress environment.", "metadata": {"filename": "SRS.docx", "chunk_index": 18, "total_chunks": 94}}, {"id": 1382, "text": "Users can browse products, review features, subscribe to pricing tiers, and directly access the SaaS through the developer\u2019s WordPress environment. The platform further automates recurring billing, manages subscription lifecycles, and calculates revenue splits between developers and the system owner.", "metadata": {"filename": "SRS.docx", "chunk_index": 19, "total_chunks": 94}}, {"id": 1383, "text": "The platform further automates recurring billing, manages subscription lifecycles, and calculates revenue splits between developers and the system owner. Administrators maintain full oversight through an admin panel that facilitates user and product approvals, financial oversight, and platform governance.", "metadata": {"filename": "SRS.docx", "chunk_index": 20, "total_chunks": 94}}, {"id": 1384, "text": "Administrators maintain full oversight through an admin panel that facilitates user and product approvals, financial oversight, and platform governance. The long-term vision is to create an ecosystem that reduces the barriers to SaaS development, empowers developers with monetization opportunities, and delivers a user-friendly marketplace for SaaS consumption.", "metadata": {"filename": "SRS.docx", "chunk_index": 21, "total_chunks": 94}}, {"id": 1385, "text": "The long-term vision is to create an ecosystem that reduces the barriers to SaaS development, empowers developers with monetization opportunities, and delivers a user-friendly marketplace for SaaS consumption.", "metadata": {"filename": "SRS.docx", "chunk_index": 22, "total_chunks": 94}}, {"id": 1386, "text": "2. Overall Description 2.1 Product Perspective The Multi-Tenant SaaS Marketplace Platform is a newly developed system that integrates several independent components into a cohesive architecture. While the marketplace operates as a standalone product, it depends heavily on external systems such as WordPress websites belonging to developers and a third-party payment gateway such as Stripe/Payoneer.", "metadata": {"filename": "SRS.docx", "chunk_index": 23, "total_chunks": 94}}, {"id": 1387, "text": "While the marketplace operates as a standalone product, it depends heavily on external systems such as WordPress websites belonging to developers and a third-party payment gateway such as Stripe/Payoneer.", "metadata": {"filename": "SRS.docx", "chunk_index": 24, "total_chunks": 94}}, {"id": 1388, "text": "The platform consists of the following major components: Frontend User Interface (React): This web-based interface provides all user-facing screens, including the marketplace, subscription pages, developer dashboard, and administrator console. It communicates exclusively with the backend through secure REST APIs.", "metadata": {"filename": "SRS.docx", "chunk_index": 25, "total_chunks": 94}}, {"id": 1389, "text": "It communicates exclusively with the backend through secure REST APIs. Backend API Server (Node.js +Django + Express): This component handles authentication, business logic, payment interactions, subscription lifecycle events, tenant isolation, and communication with WordPress sites. It also receives webhook notifications from external services and processes them accordingly.", "metadata": {"filename": "SRS.docx", "chunk_index": 26, "total_chunks": 94}}, {"id": 1390, "text": "It also receives webhook notifications from external services and processes them accordingly. Database Layer (PostgreSQL or Supabase): A centralized relational database is used to store users, subscriptions, products, pricing plans, revenue data, WordPress integration tokens, audit logs, and other critical records.", "metadata": {"filename": "SRS.docx", "chunk_index": 27, "total_chunks": 94}}, {"id": 1391, "text": "Database Layer (PostgreSQL or Supabase): A centralized relational database is used to store users, subscriptions, products, pricing plans, revenue data, WordPress integration tokens, audit logs, and other critical records. Supabase may be used for ease of setup and built-in authentication and storage capabilities.", "metadata": {"filename": "SRS.docx", "chunk_index": 28, "total_chunks": 94}}, {"id": 1392, "text": "Supabase may be used for ease of setup and built-in authentication and storage capabilities. WordPress Integration Plugin: Developers install a custom WordPress plugin on their website to link their SaaS environment with the marketplace. The plugin authenticates with the platform, verifies site ownership, and communicates subscription access permissions.", "metadata": {"filename": "SRS.docx", "chunk_index": 29, "total_chunks": 94}}, {"id": 1393, "text": "The plugin authenticates with the platform, verifies site ownership, and communicates subscription access permissions. It may also relay usage statistics for analytics. Payment Gateway: A payment service such as Stripe manages secure payments, recurring billing, invoicing, and failed payment handling.", "metadata": {"filename": "SRS.docx", "chunk_index": 30, "total_chunks": 94}}, {"id": 1394, "text": "Payment Gateway: A payment service such as Stripe manages secure payments, recurring billing, invoicing, and failed payment handling. The platform processes revenue splits between developers and the platform owner based on these transactions. This distributed design emphasizes scalability, security, and modular integration while ensuring a seamless experience for all stakeholders.", "metadata": {"filename": "SRS.docx", "chunk_index": 31, "total_chunks": 94}}, {"id": 1395, "text": "This distributed design emphasizes scalability, security, and modular integration while ensuring a seamless experience for all stakeholders. 2.2 Product Functions The platform delivers a wide range of interconnected functions: User Management: Handles authentication, role assignment, profile management, access control, and user session handling.", "metadata": {"filename": "SRS.docx", "chunk_index": 32, "total_chunks": 94}}, {"id": 1396, "text": "2.2 Product Functions The platform delivers a wide range of interconnected functions: User Management: Handles authentication, role assignment, profile management, access control, and user session handling.", "metadata": {"filename": "SRS.docx", "chunk_index": 33, "total_chunks": 94}}, {"id": 1397, "text": "Developer Onboarding and Verification: Allows developers to register as SaaS creators, submit their website details, install the WordPress plugin, and verify site ownership before publishing a product. Product Creation and Management: Developers can create SaaS offerings by defining product descriptions, feature lists, pricing plans, and trial periods.", "metadata": {"filename": "SRS.docx", "chunk_index": 34, "total_chunks": 94}}, {"id": 1398, "text": "Product Creation and Management: Developers can create SaaS offerings by defining product descriptions, feature lists, pricing plans, and trial periods. They can publish or unpublish products at any time. Marketplace Browsing: Customers can explore available SaaS tools, view product details, compare pricing, access screenshots, and read developer information.", "metadata": {"filename": "SRS.docx", "chunk_index": 35, "total_chunks": 94}}, {"id": 1399, "text": "Marketplace Browsing: Customers can explore available SaaS tools, view product details, compare pricing, access screenshots, and read developer information. Subscription Management: Customers can subscribe to products, upgrade or downgrade their plans, cancel subscriptions, and view billing history. The system automatically handles recurring billing and trial conversions.", "metadata": {"filename": "SRS.docx", "chunk_index": 36, "total_chunks": 94}}, {"id": 1400, "text": "The system automatically handles recurring billing and trial conversions. Revenue and Payout Management: The platform calculates developer earnings, deducts the platform\u2019s fee, and schedules payouts. Developers can monitor financial performance through their dashboards.", "metadata": {"filename": "SRS.docx", "chunk_index": 37, "total_chunks": 94}}, {"id": 1401, "text": "Developers can monitor financial performance through their dashboards. Administration and Moderation: Administrators supervise developer profiles, approve SaaS products, manage payouts, view platform analytics, respond to disputes, and maintain system integrity. These functions collectively ensure the platform fulfills its purpose as a multi-tenant SaaS marketplace.", "metadata": {"filename": "SRS.docx", "chunk_index": 38, "total_chunks": 94}}, {"id": 1402, "text": "These functions collectively ensure the platform fulfills its purpose as a multi-tenant SaaS marketplace. 2.3 User Classes and Characteristics The platform serves three distinct user groups, each with different expectations and expertise levels: Customers: These users have minimal technical knowledge and primarily interact with the marketplace to discover and subscribe to SaaS products.", "metadata": {"filename": "SRS.docx", "chunk_index": 39, "total_chunks": 94}}, {"id": 1403, "text": "2.3 User Classes and Characteristics The platform serves three distinct user groups, each with different expectations and expertise levels: Customers: These users have minimal technical knowledge and primarily interact with the marketplace to discover and subscribe to SaaS products.", "metadata": {"filename": "SRS.docx", "chunk_index": 40, "total_chunks": 94}}, {"id": 1404, "text": "They require a simple, intuitive interface with clear pricing, easy checkout processes, and reliable subscription management features. Developers: These users possess moderate technical skills and typically understand WordPress administration and plugin installation. Their main concerns involve product creation, integration with their WordPress site, managing subscribers, and monitoring revenue.", "metadata": {"filename": "SRS.docx", "chunk_index": 41, "total_chunks": 94}}, {"id": 1405, "text": "Their main concerns involve product creation, integration with their WordPress site, managing subscribers, and monitoring revenue. They require robust analytics and seamless integration tools. Administrators: These users are technically proficient and responsible for managing platform operations, including developer approvals, product verifications, financial oversight, and system governance.", "metadata": {"filename": "SRS.docx", "chunk_index": 42, "total_chunks": 94}}, {"id": 1406, "text": "Administrators: These users are technically proficient and responsible for managing platform operations, including developer approvals, product verifications, financial oversight, and system governance. Their interface must provide comprehensive visibility and control. 2.4 Operating Environment The system is designed to operate within widely used and stable environments.", "metadata": {"filename": "SRS.docx", "chunk_index": 43, "total_chunks": 94}}, {"id": 1407, "text": "2.4 Operating Environment The system is designed to operate within widely used and stable environments. Users access the platform via modern web browsers such as Google Chrome, Mozilla Firefox, and Microsoft Edge. The backend services run on Linux-based servers, ensuring compatibility with Node.js and Express.", "metadata": {"filename": "SRS.docx", "chunk_index": 44, "total_chunks": 94}}, {"id": 1408, "text": "The backend services run on Linux-based servers, ensuring compatibility with Node.js and Express. The WordPress plugin requires a WordPress 6.x installation running PHP 8 or above with HTTPS enabled. The database operates on PostgreSQL or Supabase, both of which offer strong relational capabilities and support for scalable architectures.", "metadata": {"filename": "SRS.docx", "chunk_index": 45, "total_chunks": 94}}, {"id": 1409, "text": "The database operates on PostgreSQL or Supabase, both of which offer strong relational capabilities and support for scalable architectures. Network communications are conducted exclusively over HTTPS to guarantee security. 2.5 Design and Implementation Constraints The platform must adhere to several technical constraints: It must use Node.js and Express for backend services.", "metadata": {"filename": "SRS.docx", "chunk_index": 46, "total_chunks": 94}}, {"id": 1410, "text": "2.5 Design and Implementation Constraints The platform must adhere to several technical constraints: It must use Node.js and Express for backend services. The database must be PostgreSQL or Supabase. All communication between frontend, backend, WordPress sites, and payment gateway must occur over secure HTTPS connections. Authentication must use JWT tokens.", "metadata": {"filename": "SRS.docx", "chunk_index": 47, "total_chunks": 94}}, {"id": 1411, "text": "Authentication must use JWT tokens. Multi-tenancy must be enforced at both the application and database layers. The WordPress plugin must conform to WordPress coding standards and REST API conventions. The payment system must support recurring billing and revenue distribution. These constraints shape the technical design and ensure the long-term maintainability and extensibility of the platform.", "metadata": {"filename": "SRS.docx", "chunk_index": 48, "total_chunks": 94}}, {"id": 1412, "text": "These constraints shape the technical design and ensure the long-term maintainability and extensibility of the platform. 2.6 User Documentation The system will include a complete set of user documentation to support onboarding and usage.", "metadata": {"filename": "SRS.docx", "chunk_index": 49, "total_chunks": 94}}, {"id": 1413, "text": "2.6 User Documentation The system will include a complete set of user documentation to support onboarding and usage. This includes developer onboarding guides, WordPress plugin installation instructions, product publishing documentation, customer usage manuals, subscription guides, and an administrative operations manual.", "metadata": {"filename": "SRS.docx", "chunk_index": 50, "total_chunks": 94}}, {"id": 1414, "text": "This includes developer onboarding guides, WordPress plugin installation instructions, product publishing documentation, customer usage manuals, subscription guides, and an administrative operations manual. In addition, API documentation will be provided through Swagger or similar tools for developers who require deeper integration.", "metadata": {"filename": "SRS.docx", "chunk_index": 51, "total_chunks": 94}}, {"id": 1415, "text": "In addition, API documentation will be provided through Swagger or similar tools for developers who require deeper integration. 2.7 Assumptions and Dependencies This system assumes that developers are capable of managing their WordPress installations and can install and configure plugins.", "metadata": {"filename": "SRS.docx", "chunk_index": 52, "total_chunks": 94}}, {"id": 1416, "text": "2.7 Assumptions and Dependencies This system assumes that developers are capable of managing their WordPress installations and can install and configure plugins. It also assumes reliable internet connectivity for all transactions, especially during WordPress plugin interactions and payment processing.", "metadata": {"filename": "SRS.docx", "chunk_index": 53, "total_chunks": 94}}, {"id": 1417, "text": "It also assumes reliable internet connectivity for all transactions, especially during WordPress plugin interactions and payment processing. The platform depends heavily on the payment gateway\u2019s uptime, email service reliability, database stability, and continued availability of the WordPress REST API. Failure of any dependency may temporarily impact system functionality. 3.", "metadata": {"filename": "SRS.docx", "chunk_index": 54, "total_chunks": 94}}, {"id": 1418, "text": "3. External Interface Requirements 3.1 User Interfaces The platform provides three distinct user interfaces: the Customer Interface, the Developer Dashboard, and the Administrator Console. All interfaces will be implemented as responsive web applications built using React. They will follow consistent visual design, typography, and navigation structures to ensure ease of use and accessibility.", "metadata": {"filename": "SRS.docx", "chunk_index": 55, "total_chunks": 94}}, {"id": 1419, "text": "They will follow consistent visual design, typography, and navigation structures to ensure ease of use and accessibility. Each interface will interact with the backend exclusively through secure HTTPS REST API calls. Customer Interface The Customer Interface serves as the public-facing portion of the marketplace.", "metadata": {"filename": "SRS.docx", "chunk_index": 56, "total_chunks": 94}}, {"id": 1420, "text": "Customer Interface The Customer Interface serves as the public-facing portion of the marketplace. It includes the home page, product catalog, search and filtering tools, product detail pages, checkout and subscription pages, and a personal account dashboard.", "metadata": {"filename": "SRS.docx", "chunk_index": 57, "total_chunks": 94}}, {"id": 1421, "text": "It includes the home page, product catalog, search and filtering tools, product detail pages, checkout and subscription pages, and a personal account dashboard. Customers will be able to view their active subscriptions, billing history, saved payment methods (managed by the payment gateway, not locally), and invoices.", "metadata": {"filename": "SRS.docx", "chunk_index": 58, "total_chunks": 94}}, {"id": 1422, "text": "Customers will be able to view their active subscriptions, billing history, saved payment methods (managed by the payment gateway, not locally), and invoices. The interface must present pricing information clearly and provide transparent explanations of trial periods, billing cycles, and cancellation policies.", "metadata": {"filename": "SRS.docx", "chunk_index": 59, "total_chunks": 94}}, {"id": 1423, "text": "The interface must present pricing information clearly and provide transparent explanations of trial periods, billing cycles, and cancellation policies. Error messages, payment failures, or subscription-related alerts must be displayed with clear wording and actionable guidance. Developer Dashboard The Developer Dashboard is a restricted interface accessible only to users registered as developers.", "metadata": {"filename": "SRS.docx", "chunk_index": 60, "total_chunks": 94}}, {"id": 1424, "text": "Developer Dashboard The Developer Dashboard is a restricted interface accessible only to users registered as developers. It provides onboarding wizards, WordPress integration steps, product creation tools, and revenue analytics. Developers should be able to register a WordPress site, verify ownership through a verification token, and install the required plugin.", "metadata": {"filename": "SRS.docx", "chunk_index": 61, "total_chunks": 94}}, {"id": 1425, "text": "Developers should be able to register a WordPress site, verify ownership through a verification token, and install the required plugin. The dashboard will allow developers to create and publish SaaS products by defining metadata, pricing plans, feature descriptions, and trial configurations.", "metadata": {"filename": "SRS.docx", "chunk_index": 62, "total_chunks": 94}}, {"id": 1426, "text": "The dashboard will allow developers to create and publish SaaS products by defining metadata, pricing plans, feature descriptions, and trial configurations. The dashboard also includes earnings summaries, payout history, subscriber counts, and product performance charts.", "metadata": {"filename": "SRS.docx", "chunk_index": 63, "total_chunks": 94}}, {"id": 1427, "text": "The dashboard also includes earnings summaries, payout history, subscriber counts, and product performance charts. All sensitive actions (e.g., publishing products, modifying payment details) must prompt confirmation messages or multi-step flows to prevent accidental changes.", "metadata": {"filename": "SRS.docx", "chunk_index": 64, "total_chunks": 94}}, {"id": 1428, "text": "All sensitive actions (e.g., publishing products, modifying payment details) must prompt confirmation messages or multi-step flows to prevent accidental changes. Administrator Console The Administrator Console is designed for platform administrators who manage approvals, financial oversight, and system governance.", "metadata": {"filename": "SRS.docx", "chunk_index": 65, "total_chunks": 94}}, {"id": 1429, "text": "Administrator Console The Administrator Console is designed for platform administrators who manage approvals, financial oversight, and system governance. It includes interfaces for reviewing developer applications, approving or rejecting SaaS products, inspecting subscription records, triggering payouts, and reviewing financial reports.", "metadata": {"filename": "SRS.docx", "chunk_index": 66, "total_chunks": 94}}, {"id": 1430, "text": "It includes interfaces for reviewing developer applications, approving or rejecting SaaS products, inspecting subscription records, triggering payouts, and reviewing financial reports. Administrators must have visibility into system logs, error reports, user activity, and revenue analytics.", "metadata": {"filename": "SRS.docx", "chunk_index": 67, "total_chunks": 94}}, {"id": 1431, "text": "Administrators must have visibility into system logs, error reports, user activity, and revenue analytics. The interface must include filtering, sorting, and export features for data tables to facilitate operational efficiency.", "metadata": {"filename": "SRS.docx", "chunk_index": 68, "total_chunks": 94}}, {"id": 1432, "text": "The interface must include filtering, sorting, and export features for data tables to facilitate operational efficiency. Since administrators will handle sensitive financial data and platform-wide settings, the console must enforce the highest level of security, including role verification and audit logging of administrative actions.", "metadata": {"filename": "SRS.docx", "chunk_index": 69, "total_chunks": 94}}, {"id": 1433, "text": "Since administrators will handle sensitive financial data and platform-wide settings, the console must enforce the highest level of security, including role verification and audit logging of administrative actions. 3.2 Hardware Interfaces The system does not require any specialized hardware interfaces because it is fully web-based and cloud-hosted.", "metadata": {"filename": "SRS.docx", "chunk_index": 70, "total_chunks": 94}}, {"id": 1434, "text": "3.2 Hardware Interfaces The system does not require any specialized hardware interfaces because it is fully web-based and cloud-hosted. All interactions occur via standard consumer devices such as laptops, desktops, and mobile phones. The backend runs on cloud servers (physical or virtual) that meet minimum specifications for running Node.js and PostgreSQL.", "metadata": {"filename": "SRS.docx", "chunk_index": 71, "total_chunks": 94}}, {"id": 1435, "text": "The backend runs on cloud servers (physical or virtual) that meet minimum specifications for running Node.js and PostgreSQL. The only relevant hardware interactions involve the servers hosting the WordPress websites used by developers. These hosting environments must support PHP 8+, HTTPS, and WordPress 6.x or later, ensuring compatibility with the custom plugin.", "metadata": {"filename": "SRS.docx", "chunk_index": 72, "total_chunks": 94}}, {"id": 1436, "text": "These hosting environments must support PHP 8+, HTTPS, and WordPress 6.x or later, ensuring compatibility with the custom plugin. Beyond this, there are no custom hardware requirements such as embedded devices, sensors, or device drivers. 3.3 Software Interfaces The platform interacts with several external software systems.", "metadata": {"filename": "SRS.docx", "chunk_index": 73, "total_chunks": 94}}, {"id": 1437, "text": "3.3 Software Interfaces The platform interacts with several external software systems. These interfaces must be clearly defined to ensure reliable communication and prevent data inconsistencies. WordPress Plugin Interface The custom WordPress plugin is a critical component of the system.", "metadata": {"filename": "SRS.docx", "chunk_index": 74, "total_chunks": 94}}, {"id": 1438, "text": "WordPress Plugin Interface The custom WordPress plugin is a critical component of the system. It must expose a set of REST endpoints that the marketplace backend can use to: Verify site ownership Validate active subscriptions Synchronize product information Enforce access control to SaaS features The plugin must authenticate requests using the API key generated during developer onboarding.", "metadata": {"filename": "SRS.docx", "chunk_index": 75, "total_chunks": 94}}, {"id": 1439, "text": "It must expose a set of REST endpoints that the marketplace backend can use to: Verify site ownership Validate active subscriptions Synchronize product information Enforce access control to SaaS features The plugin must authenticate requests using the API key generated during developer onboarding.", "metadata": {"filename": "SRS.docx", "chunk_index": 76, "total_chunks": 94}}, {"id": 1440, "text": "It must also register webhooks or callback endpoints to receive subscription status notifications from the platform. The plugin should be compatible with the WordPress REST API, respecting permission callbacks and the WP security model.", "metadata": {"filename": "SRS.docx", "chunk_index": 77, "total_chunks": 94}}, {"id": 1441, "text": "The plugin should be compatible with the WordPress REST API, respecting permission callbacks and the WP security model. Payment Gateway Interface The payment gateway (e.g., Stripe/Payoneer) provides interfaces for processing payments, managing subscriptions, handling trial periods, generating invoices, and receiving webhook notifications.", "metadata": {"filename": "SRS.docx", "chunk_index": 78, "total_chunks": 94}}, {"id": 1442, "text": "Payment Gateway Interface The payment gateway (e.g., Stripe/Payoneer) provides interfaces for processing payments, managing subscriptions, handling trial periods, generating invoices, and receiving webhook notifications. The platform must integrate with the gateway using its official SDK or REST APIs.", "metadata": {"filename": "SRS.docx", "chunk_index": 79, "total_chunks": 94}}, {"id": 1443, "text": "The platform must integrate with the gateway using its official SDK or REST APIs.", "metadata": {"filename": "SRS.docx", "chunk_index": 80, "total_chunks": 94}}, {"id": 1444, "text": "Communication includes: Creating checkout sessions Attaching payment methods Managing subscription cycles Responding to payment successes or failures Handling webhook events for renewals, cancellations, and chargebacks The system must never store raw credit card information; all sensitive data is tokenized and maintained by the payment provider.", "metadata": {"filename": "SRS.docx", "chunk_index": 81, "total_chunks": 94}}, {"id": 1445, "text": "Email Service Interface The platform will integrate with an email delivery service (e.g., SendGrid, Mailgun, or Supabase built-in email support). This service handles account verification emails, password reset requests, subscription confirmations, payment receipts, trial reminders, and developer notifications. Emails must follow templated formats and support dynamic fields.", "metadata": {"filename": "SRS.docx", "chunk_index": 82, "total_chunks": 94}}, {"id": 1446, "text": "Emails must follow templated formats and support dynamic fields. Backend API Interface The frontend and WordPress plugin communicate with the backend exclusively through REST APIs. Endpoints must follow predictable naming conventions, use JSON as the data exchange format, and enforce role-based authorization.", "metadata": {"filename": "SRS.docx", "chunk_index": 83, "total_chunks": 94}}, {"id": 1447, "text": "Endpoints must follow predictable naming conventions, use JSON as the data exchange format, and enforce role-based authorization. The backend API layer will expose endpoints for authentication, product creation, subscription management, developer onboarding, payout scheduling, and administrative operations. The API must return meaningful response codes and structured error messages.", "metadata": {"filename": "SRS.docx", "chunk_index": 84, "total_chunks": 94}}, {"id": 1448, "text": "The API must return meaningful response codes and structured error messages. Database Interface The system interacts with PostgreSQL using an ORM or SQL queries. The database schema must be consistent with multi-tenant architecture, ensuring that all tables either include a tenant identifier or follow schema-per-tenant separation.", "metadata": {"filename": "SRS.docx", "chunk_index": 85, "total_chunks": 94}}, {"id": 1449, "text": "The database schema must be consistent with multi-tenant architecture, ensuring that all tables either include a tenant identifier or follow schema-per-tenant separation. The backend must implement strict row-level security or access rules to prevent cross-tenant data exposures.", "metadata": {"filename": "SRS.docx", "chunk_index": 86, "total_chunks": 94}}, {"id": 1450, "text": "The backend must implement strict row-level security or access rules to prevent cross-tenant data exposures. 3.4 Communications Interfaces All interactions across the platform must occur over secure HTTPS connections to prevent data interception or manipulation. The system employs REST-style JSON messaging for communication between the frontend, backend, WordPress plugin, and external services.", "metadata": {"filename": "SRS.docx", "chunk_index": 87, "total_chunks": 94}}, {"id": 1451, "text": "The system employs REST-style JSON messaging for communication between the frontend, backend, WordPress plugin, and external services. For asynchronous operations, such as subscription renewals and payment events, the platform relies on webhook mechanisms provided by the payment gateway.", "metadata": {"filename": "SRS.docx", "chunk_index": 88, "total_chunks": 94}}, {"id": 1452, "text": "For asynchronous operations, such as subscription renewals and payment events, the platform relies on webhook mechanisms provided by the payment gateway. The WordPress plugin and the backend use token-based authentication (API key + site verification token) to authenticate requests. The plugin must refuse any requests lacking valid tokens or signatures.", "metadata": {"filename": "SRS.docx", "chunk_index": 89, "total_chunks": 94}}, {"id": 1453, "text": "The plugin must refuse any requests lacking valid tokens or signatures. Similarly, webhook payloads from the payment gateway must be verified using signature headers to ensure authenticity. Error handling within communication interfaces must follow a consistent pattern. For example, API failures should return error messages in JSON format with fields such as error_code, message, and details.", "metadata": {"filename": "SRS.docx", "chunk_index": 90, "total_chunks": 94}}, {"id": 1454, "text": "For example, API failures should return error messages in JSON format with fields such as error_code, message, and details. The system must also implement retry mechanisms for transient communication failures, especially during webhook processing or payment-related events. The communication layer must support rate limiting, input validation, and payload sanitization to mitigate security risks.", "metadata": {"filename": "SRS.docx", "chunk_index": 91, "total_chunks": 94}}, {"id": 1455, "text": "The communication layer must support rate limiting, input validation, and payload sanitization to mitigate security risks. Logs of communication errors, failed requests, and suspicious activities must be maintained for auditing purposes.", "metadata": {"filename": "SRS.docx", "chunk_index": 92, "total_chunks": 94}}, {"id": 1456, "text": "Logs of communication errors, failed requests, and suspicious activities must be maintained for auditing purposes.", "metadata": {"filename": "SRS.docx", "chunk_index": 93, "total_chunks": 94}}]